{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":""},{"location":"#documentation","title":"Documentation","text":"<p>Apache Iceberg is an open table format for huge analytic datasets. Iceberg adds tables to compute engines including Spark, Trino, PrestoDB, Flink, Hive and Impala using a high-performance table format that works just like a SQL table.</p>"},{"location":"#user-experience","title":"User experience","text":"<p>Iceberg avoids unpleasant surprises. Schema evolution works and won't inadvertently un-delete data. Users don't need to know about partitioning to get fast queries.</p> <ul> <li>Schema evolution supports add, drop, update, or rename, and has no side-effects</li> <li>Hidden partitioning prevents user mistakes that cause silently incorrect results or extremely slow queries</li> <li>Partition layout evolution can update the layout of a table as data volume or query patterns change</li> <li>Time travel enables reproducible queries that use exactly the same table snapshot, or lets users easily examine changes</li> <li>Version rollback allows users to quickly correct problems by resetting tables to a good state</li> </ul>"},{"location":"#reliability-and-performance","title":"Reliability and performance","text":"<p>Iceberg was built for huge tables. Iceberg is used in production where a single table can contain tens of petabytes of data and even these huge tables can be read without a distributed SQL engine.</p> <ul> <li>Scan planning is fast -- a distributed SQL engine isn't needed to read a table or find files</li> <li>Advanced filtering -- data files are pruned with partition and column-level stats, using table metadata</li> </ul> <p>Iceberg was designed to solve correctness problems in eventually-consistent cloud object stores.</p> <ul> <li>Works with any cloud store and reduces NN congestion when in HDFS, by avoiding listing and renames</li> <li>Serializable isolation -- table changes are atomic and readers never see partial or uncommitted changes</li> <li>Multiple concurrent writers use optimistic concurrency and will retry to ensure that compatible updates succeed, even when writes conflict</li> </ul>"},{"location":"#open-standard","title":"Open standard","text":"<p>Iceberg has been designed and developed to be an open community standard with a specification to ensure compatibility across languages and implementations.</p> <p>Apache Iceberg is open source, and is developed at the Apache Software Foundation.</p>"},{"location":"api/","title":"Java API","text":""},{"location":"api/#iceberg-java-api","title":"Iceberg Java API","text":""},{"location":"api/#tables","title":"Tables","text":"<p>The main purpose of the Iceberg API is to manage table metadata, like schema, partition spec, metadata, and data files that store table data.</p> <p>Table metadata and operations are accessed through the <code>Table</code> interface. This interface will return table information.</p>"},{"location":"api/#table-metadata","title":"Table metadata","text":"<p>The <code>Table</code> interface provides access to the table metadata:</p> <ul> <li><code>schema</code> returns the current table schema</li> <li><code>spec</code> returns the current table partition spec</li> <li><code>properties</code> returns a map of key-value properties</li> <li><code>currentSnapshot</code> returns the current table snapshot</li> <li><code>snapshots</code> returns all valid snapshots for the table</li> <li><code>snapshot(id)</code> returns a specific snapshot by ID</li> <li><code>location</code> returns the table's base location</li> </ul> <p>Tables also provide <code>refresh</code> to update the table to the latest version, and expose helpers:</p> <ul> <li><code>io</code> returns the <code>FileIO</code> used to read and write table files</li> <li><code>locationProvider</code> returns a <code>LocationProvider</code> used to create paths for data and metadata files</li> </ul>"},{"location":"api/#scanning","title":"Scanning","text":""},{"location":"api/#file-level","title":"File level","text":"<p>Iceberg table scans start by creating a <code>TableScan</code> object with <code>newScan</code>.</p> <pre><code>TableScan scan = table.newScan();\n</code></pre> <p>To configure a scan, call <code>filter</code> and <code>select</code> on the <code>TableScan</code> to get a new <code>TableScan</code> with those changes.</p> <pre><code>TableScan filteredScan = scan.filter(Expressions.equal(\"id\", 5))\n</code></pre> <p>Calls to configuration methods create a new <code>TableScan</code> so that each <code>TableScan</code> is immutable and won't change unexpectedly if shared across threads.</p> <p>When a scan is configured, <code>planFiles</code>, <code>planTasks</code>, and <code>schema</code> are used to return files, tasks, and the read projection.</p> <pre><code>TableScan scan = table.newScan()\n.filter(Expressions.equal(\"id\", 5))\n.select(\"id\", \"data\");\nSchema projection = scan.schema();\nIterable&lt;CombinedScanTask&gt; tasks = scan.planTasks();\n</code></pre> <p>Use <code>asOfTime</code> or <code>useSnapshot</code> to configure the table snapshot for time travel queries.</p>"},{"location":"api/#row-level","title":"Row level","text":"<p>Iceberg table scans start by creating a <code>ScanBuilder</code> object with <code>IcebergGenerics.read</code>.</p> <pre><code>ScanBuilder scanBuilder = IcebergGenerics.read(table)\n</code></pre> <p>To configure a scan, call <code>where</code> and <code>select</code> on the <code>ScanBuilder</code> to get a new <code>ScanBuilder</code> with those changes.</p> <pre><code>scanBuilder.where(Expressions.equal(\"id\", 5))\n</code></pre> <p>When a scan is configured, call method <code>build</code> to execute scan. <code>build</code> return <code>CloseableIterable&lt;Record&gt;</code></p> <p><pre><code>CloseableIterable&lt;Record&gt; result = IcebergGenerics.read(table)\n.where(Expressions.lessThan(\"id\", 5))\n.build();\n</code></pre> where <code>Record</code> is Iceberg record for iceberg-data module <code>org.apache.iceberg.data.Record</code>.</p>"},{"location":"api/#update-operations","title":"Update operations","text":"<p><code>Table</code> also exposes operations that update the table. These operations use a builder pattern, <code>PendingUpdate</code>, that commits when <code>PendingUpdate#commit</code> is called.</p> <p>For example, updating the table schema is done by calling <code>updateSchema</code>, adding updates to the builder, and finally calling <code>commit</code> to commit the pending changes to the table:</p> <pre><code>table.updateSchema()\n.addColumn(\"count\", Types.LongType.get())\n.commit();\n</code></pre> <p>Available operations to update a table are:</p> <ul> <li><code>updateSchema</code> -- update the table schema</li> <li><code>updateProperties</code> -- update table properties</li> <li><code>updateLocation</code> -- update the table's base location</li> <li><code>newAppend</code> -- used to append data files</li> <li><code>newFastAppend</code> -- used to append data files, will not compact metadata</li> <li><code>newOverwrite</code> -- used to append data files and remove files that are overwritten</li> <li><code>newDelete</code> -- used to delete data files</li> <li><code>newRewrite</code> -- used to rewrite data files; will replace existing files with new versions</li> <li><code>newTransaction</code> -- create a new table-level transaction</li> <li><code>rewriteManifests</code> -- rewrite manifest data by clustering files, for faster scan planning</li> <li><code>rollback</code> -- rollback the table state to a specific snapshot</li> </ul>"},{"location":"api/#transactions","title":"Transactions","text":"<p>Transactions are used to commit multiple table changes in a single atomic operation. A transaction is used to create individual operations using factory methods, like <code>newAppend</code>, just like working with a <code>Table</code>. Operations created by a transaction are committed as a group when <code>commitTransaction</code> is called.</p> <p>For example, deleting and appending a file in the same transaction: <pre><code>Transaction t = table.newTransaction();\n// commit operations to the transaction\nt.newDelete().deleteFromRowFilter(filter).commit();\nt.newAppend().appendFile(data).commit();\n// commit all the changes to the table\nt.commitTransaction();\n</code></pre></p>"},{"location":"api/#types","title":"Types","text":"<p>Iceberg data types are located in the <code>org.apache.iceberg.types</code> package.</p>"},{"location":"api/#primitives","title":"Primitives","text":"<p>Primitive type instances are available from static methods in each type class. Types without parameters use <code>get</code>, and types like <code>decimal</code> use factory methods:</p> <pre><code>Types.IntegerType.get()    // int\nTypes.DoubleType.get()     // double\nTypes.DecimalType.of(9, 2) // decimal(9, 2)\n</code></pre>"},{"location":"api/#nested-types","title":"Nested types","text":"<p>Structs, maps, and lists are created using factory methods in type classes.</p> <p>Like struct fields, map keys or values and list elements are tracked as nested fields. Nested fields track field IDs and nullability.</p> <p>Struct fields are created using <code>NestedField.optional</code> or <code>NestedField.required</code>. Map value and list element nullability is set in the map and list factory methods.</p> <p><pre><code>// struct&lt;1 id: int, 2 data: optional string&gt;\nStructType struct = Struct.of(\nTypes.NestedField.required(1, \"id\", Types.IntegerType.get()),\nTypes.NestedField.optional(2, \"data\", Types.StringType.get())\n)\n</code></pre> <pre><code>// map&lt;1 key: int, 2 value: optional string&gt;\nMapType map = MapType.ofOptional(\n1, 2,\nTypes.IntegerType.get(),\nTypes.StringType.get()\n)\n</code></pre> <pre><code>// array&lt;1 element: int&gt;\nListType list = ListType.ofRequired(1, IntegerType.get());\n</code></pre></p>"},{"location":"api/#expressions","title":"Expressions","text":"<p>Iceberg's expressions are used to configure table scans. To create expressions, use the factory methods in <code>Expressions</code>.</p> <p>Supported predicate expressions are:</p> <ul> <li><code>isNull</code></li> <li><code>notNull</code></li> <li><code>equal</code></li> <li><code>notEqual</code></li> <li><code>lessThan</code></li> <li><code>lessThanOrEqual</code></li> <li><code>greaterThan</code></li> <li><code>greaterThanOrEqual</code></li> <li><code>in</code></li> <li><code>notIn</code></li> <li><code>startsWith</code></li> <li><code>notStartsWith</code></li> </ul> <p>Supported expression operations are:</p> <ul> <li><code>and</code></li> <li><code>or</code></li> <li><code>not</code></li> </ul> <p>Constant expressions are:</p> <ul> <li><code>alwaysTrue</code></li> <li><code>alwaysFalse</code></li> </ul>"},{"location":"api/#expression-binding","title":"Expression binding","text":"<p>When created, expressions are unbound. Before an expression is used, it will be bound to a data type to find the field ID the expression name represents, and to convert predicate literals.</p> <p>For example, before using the expression <code>lessThan(\"x\", 10)</code>, Iceberg needs to determine which column <code>\"x\"</code> refers to and convert <code>10</code> to that column's data type.</p> <p>If the expression could be bound to the type <code>struct&lt;1 x: long, 2 y: long&gt;</code> or to <code>struct&lt;11 x: int, 12 y: int&gt;</code>.</p>"},{"location":"api/#expression-example","title":"Expression example","text":"<pre><code>table.newScan()\n.filter(Expressions.greaterThanOrEqual(\"x\", 5))\n.filter(Expressions.lessThan(\"x\", 10))\n</code></pre>"},{"location":"api/#modules","title":"Modules","text":"<p>Iceberg table support is organized in library modules:</p> <ul> <li><code>iceberg-common</code> contains utility classes used in other modules</li> <li><code>iceberg-api</code> contains the public Iceberg API, including expressions, types, tables, and operations</li> <li><code>iceberg-arrow</code> is an implementation of the Iceberg type system for reading and writing data stored in Iceberg tables using Apache Arrow as the in-memory data format</li> <li><code>iceberg-aws</code> contains implementations of the Iceberg API to be used with tables stored on AWS S3 and/or for tables defined using the AWS Glue data catalog</li> <li><code>iceberg-core</code> contains implementations of the Iceberg API and support for Avro data files, this is what processing engines should depend on</li> <li><code>iceberg-parquet</code> is an optional module for working with tables backed by Parquet files</li> <li><code>iceberg-orc</code> is an optional module for working with tables backed by ORC files (experimental)</li> <li><code>iceberg-hive-metastore</code> is an implementation of Iceberg tables backed by the Hive metastore Thrift client</li> </ul> <p>This project Iceberg also has modules for adding Iceberg support to processing engines and associated tooling:</p> <ul> <li><code>iceberg-spark</code> is an implementation of Spark's Datasource V2 API for Iceberg with submodules for each spark versions (use runtime jars for a shaded version)</li> <li><code>iceberg-flink</code> is an implementation of Flink's Table and DataStream API for Iceberg (use iceberg-flink-runtime for a shaded version)</li> <li><code>iceberg-hive3</code> is an implementation of Hive 3 specific SerDe's for Timestamp, TimestampWithZone, and Date object inspectors (use iceberg-hive-runtime for a shaded version).</li> <li><code>iceberg-mr</code> is an implementation of MapReduce and Hive InputFormats and SerDes for Iceberg (use iceberg-hive-runtime for a shaded version for use with Hive)</li> <li><code>iceberg-nessie</code> is a module used to integrate Iceberg table metadata history and operations with Project Nessie</li> <li><code>iceberg-data</code> is a client library used to read Iceberg tables from JVM applications</li> <li><code>iceberg-pig</code> is an implementation of Pig's LoadFunc API for Iceberg</li> <li><code>iceberg-runtime</code> generates a shaded runtime jar for Spark to integrate with iceberg tables</li> </ul>"},{"location":"aws/","title":"AWS","text":""},{"location":"aws/#iceberg-aws-integrations","title":"Iceberg AWS Integrations","text":"<p>Iceberg provides integration with different AWS services through the <code>iceberg-aws</code> module.  This section describes how to use Iceberg with AWS.</p>"},{"location":"aws/#enabling-aws-integration","title":"Enabling AWS Integration","text":"<p>The <code>iceberg-aws</code> module is bundled with Spark and Flink engine runtimes for all versions from <code>0.11.0</code> onwards. However, the AWS clients are not bundled so that you can use the same client version as your application. You will need to provide the AWS v2 SDK because that is what Iceberg depends on. You can choose to use the AWS SDK bundle,  or individual AWS client packages (Glue, S3, DynamoDB, KMS, STS) if you would like to have a minimal dependency footprint.</p> <p>All the default AWS clients use the URL Connection HTTP Client for HTTP connection management. This dependency is not part of the AWS SDK bundle and needs to be added separately. To choose a different HTTP client library such as Apache HTTP Client, see the section client customization for more details.</p> <p>All the AWS module features can be loaded through custom catalog properties, you can go to the documentations of each engine to see how to load a custom catalog. Here are some examples.</p>"},{"location":"aws/#spark","title":"Spark","text":"<p>For example, to use AWS features with Spark 3.3 (with scala 2.12) and AWS clients version 2.20.18, you can start the Spark SQL shell with:</p> <pre><code># add Iceberg dependency\nICEBERG_VERSION={{ icebergVersion }}\nDEPENDENCIES=\"org.apache.iceberg:iceberg-spark-runtime-3.3_2.12:$ICEBERG_VERSION\"\n# add AWS dependency\nAWS_SDK_VERSION=2.20.18\nAWS_MAVEN_GROUP=software.amazon.awssdk\nAWS_PACKAGES=(\n\"bundle\"\n)\nfor pkg in \"${AWS_PACKAGES[@]}\"; do\nDEPENDENCIES+=\",$AWS_MAVEN_GROUP:$pkg:$AWS_SDK_VERSION\"\ndone\n# start Spark SQL client shell\nspark-sql --packages $DEPENDENCIES \\\n--conf spark.sql.defaultCatalog=my_catalog \\\n--conf spark.sql.catalog.my_catalog=org.apache.iceberg.spark.SparkCatalog \\\n--conf spark.sql.catalog.my_catalog.warehouse=s3://my-bucket/my/key/prefix \\\n--conf spark.sql.catalog.my_catalog.catalog-impl=org.apache.iceberg.aws.glue.GlueCatalog \\\n--conf spark.sql.catalog.my_catalog.io-impl=org.apache.iceberg.aws.s3.S3FileIO\n</code></pre> <p>As you can see, In the shell command, we use <code>--packages</code> to specify the additional AWS bundle and HTTP client dependencies with their version as <code>2.20.18</code>.</p>"},{"location":"aws/#flink","title":"Flink","text":"<p>To use AWS module with Flink, you can download the necessary dependencies and specify them when starting the Flink SQL client:</p> <pre><code># download Iceberg dependency\nICEBERG_VERSION={{ icebergVersion }}\nMAVEN_URL=https://repo1.maven.org/maven2\nICEBERG_MAVEN_URL=$MAVEN_URL/org/apache/iceberg\nwget $ICEBERG_MAVEN_URL/iceberg-flink-runtime/$ICEBERG_VERSION/iceberg-flink-runtime-$ICEBERG_VERSION.jar\n\n# download AWS dependency\nAWS_SDK_VERSION=2.20.18\nAWS_MAVEN_URL=$MAVEN_URL/software/amazon/awssdk\nAWS_PACKAGES=(\n\"bundle\"\n)\nfor pkg in \"${AWS_PACKAGES[@]}\"; do\nwget $AWS_MAVEN_URL/$pkg/$AWS_SDK_VERSION/$pkg-$AWS_SDK_VERSION.jar\ndone\n# start Flink SQL client shell\n/path/to/bin/sql-client.sh embedded \\\n-j iceberg-flink-runtime-$ICEBERG_VERSION.jar \\\n-j bundle-$AWS_SDK_VERSION.jar \\\nshell\n</code></pre> <p>With those dependencies, you can create a Flink catalog like the following:</p> <pre><code>CREATE CATALOG my_catalog WITH (\n'type'='iceberg',\n'warehouse'='s3://my-bucket/my/key/prefix',\n'catalog-impl'='org.apache.iceberg.aws.glue.GlueCatalog',\n'io-impl'='org.apache.iceberg.aws.s3.S3FileIO'\n);\n</code></pre> <p>You can also specify the catalog configurations in <code>sql-client-defaults.yaml</code> to preload it:</p> <pre><code>catalogs: - name: my_catalog\ntype: iceberg\nwarehouse: s3://my-bucket/my/key/prefix\ncatalog-impl: org.apache.iceberg.aws.glue.GlueCatalog\nio-impl: org.apache.iceberg.aws.s3.S3FileIO\n</code></pre>"},{"location":"aws/#hive","title":"Hive","text":"<p>To use AWS module with Hive, you can download the necessary dependencies similar to the Flink example, and then add them to the Hive classpath or add the jars at runtime in CLI:</p> <pre><code>add jar /my/path/to/iceberg-hive-runtime.jar;\nadd jar /my/path/to/aws/bundle.jar;\n</code></pre> <p>With those dependencies, you can register a Glue catalog and create external tables in Hive at runtime in CLI by:</p> <pre><code>SET iceberg.engine.hive.enabled=true;\nSET hive.vectorized.execution.enabled=false;\nSET iceberg.catalog.glue.catalog-impl=org.apache.iceberg.aws.glue.GlueCatalog;\nSET iceberg.catalog.glue.warehouse=s3://my-bucket/my/key/prefix;\n-- suppose you have an Iceberg table database_a.table_a created by GlueCatalog\nCREATE EXTERNAL TABLE database_a.table_a\nSTORED BY 'org.apache.iceberg.mr.hive.HiveIcebergStorageHandler'\nTBLPROPERTIES ('iceberg.catalog'='glue');\n</code></pre> <p>You can also preload the catalog by setting the configurations above in <code>hive-site.xml</code>.</p>"},{"location":"aws/#catalogs","title":"Catalogs","text":"<p>There are multiple different options that users can choose to build an Iceberg catalog with AWS.</p>"},{"location":"aws/#glue-catalog","title":"Glue Catalog","text":"<p>Iceberg enables the use of AWS Glue as the <code>Catalog</code> implementation. When used, an Iceberg namespace is stored as a Glue Database,  an Iceberg table is stored as a Glue Table, and every Iceberg table version is stored as a Glue TableVersion.  You can start using Glue catalog by specifying the <code>catalog-impl</code> as <code>org.apache.iceberg.aws.glue.GlueCatalog</code>, just like what is shown in the enabling AWS integration section above.  More details about loading the catalog can be found in individual engine pages, such as Spark and Flink.</p>"},{"location":"aws/#glue-catalog-id","title":"Glue Catalog ID","text":"<p>There is a unique Glue metastore in each AWS account and each AWS region. By default, <code>GlueCatalog</code> chooses the Glue metastore to use based on the user's default AWS client credential and region setup. You can specify the Glue catalog ID through <code>glue.id</code> catalog property to point to a Glue catalog in a different AWS account. The Glue catalog ID is your numeric AWS account ID. If the Glue catalog is in a different region, you should configure your AWS client to point to the correct region,  see more details in AWS client customization.</p>"},{"location":"aws/#skip-archive","title":"Skip Archive","text":"<p>AWS Glue has the ability to archive older table versions and a user can roll back the table to any historical version if needed. By default, the Iceberg Glue Catalog will skip the archival of older table versions. If a user wishes to archive older table versions, they can set <code>glue.skip-archive</code> to false. Do note for streaming ingestion into Iceberg tables, setting <code>glue.skip-archive</code> to false will quickly create a lot of Glue table versions. For more details, please read Glue Quotas and the UpdateTable API.</p>"},{"location":"aws/#skip-name-validation","title":"Skip Name Validation","text":"<p>Allow user to skip name validation for table name and namespaces. It is recommended to stick to Glue best practice in https://docs.aws.amazon.com/athena/latest/ug/glue-best-practices.html to make sure operations are Hive compatible. This is only added for users that have existing conventions using non-standard characters. When database name and table name validation are skipped, there is no guarantee that downstream systems would all support the names.</p>"},{"location":"aws/#optimistic-locking","title":"Optimistic Locking","text":"<p>By default, Iceberg uses Glue's optimistic locking for concurrent updates to a table. With optimistic locking, each table has a version id.  If users retrieve the table metadata, Iceberg records the version id of that table.  Users can update the table as long as the version ID on the server side remains unchanged.  Version mismatch occurs if someone else modified the table before you did, causing an update failure.  Iceberg then refreshes metadata and checks if there is a conflict. If there is no commit conflict, the operation will be retried. Optimistic locking guarantees atomic transaction of Iceberg tables in Glue. It also prevents others from accidentally overwriting your changes.</p> <p>Info</p> <p>Please use AWS SDK version &gt;= 2.17.131 to leverage Glue's Optimistic Locking. If the AWS SDK version is below 2.17.131, only in-memory lock is used. To ensure atomic transaction, you need to set up a DynamoDb Lock Manager.</p>"},{"location":"aws/#warehouse-location","title":"Warehouse Location","text":"<p>Similar to all other catalog implementations, <code>warehouse</code> is a required catalog property to determine the root path of the data warehouse in storage. By default, Glue only allows a warehouse location in S3 because of the use of <code>S3FileIO</code>. To store data in a different local or cloud store, Glue catalog can switch to use <code>HadoopFileIO</code> or any custom FileIO by setting the <code>io-impl</code> catalog property. Details about this feature can be found in the custom FileIO section.</p>"},{"location":"aws/#table-location","title":"Table Location","text":"<p>By default, the root location for a table <code>my_table</code> of namespace <code>my_ns</code> is at <code>my-warehouse-location/my-ns.db/my-table</code>. This default root location can be changed at both namespace and table level.</p> <p>To use a different path prefix for all tables under a namespace, use AWS console or any AWS Glue client SDK you like to update the <code>locationUri</code> attribute of the corresponding Glue database. For example, you can update the <code>locationUri</code> of <code>my_ns</code> to <code>s3://my-ns-bucket</code>,  then any newly created table will have a default root location under the new prefix. For instance, a new table <code>my_table_2</code> will have its root location at <code>s3://my-ns-bucket/my_table_2</code>.</p> <p>To use a completely different root path for a specific table, set the <code>location</code> table property to the desired root path value you want. For example, in Spark SQL you can do:</p> <pre><code>CREATE TABLE my_catalog.my_ns.my_table (\nid bigint,\ndata string,\ncategory string)\nUSING iceberg\nOPTIONS ('location'='s3://my-special-table-bucket')\nPARTITIONED BY (category);\n</code></pre> <p>For engines like Spark that support the <code>LOCATION</code> keyword, the above SQL statement is equivalent to:</p> <pre><code>CREATE TABLE my_catalog.my_ns.my_table (\nid bigint,\ndata string,\ncategory string)\nUSING iceberg\nLOCATION 's3://my-special-table-bucket'\nPARTITIONED BY (category);\n</code></pre>"},{"location":"aws/#dynamodb-catalog","title":"DynamoDB Catalog","text":"<p>Iceberg supports using a DynamoDB table to record and manage database and table information.</p>"},{"location":"aws/#configurations","title":"Configurations","text":"<p>The DynamoDB catalog supports the following configurations:</p> Property Default Description dynamodb.table-name iceberg name of the DynamoDB table used by DynamoDbCatalog"},{"location":"aws/#internal-table-design","title":"Internal Table Design","text":"<p>The DynamoDB table is designed with the following columns:</p> Column Key Type Description identifier partition key string table identifier such as <code>db1.table1</code>, or string <code>NAMESPACE</code> for namespaces namespace sort key string namespace name. A global secondary index (GSI) is created with namespace as partition key, identifier as sort key, no other projected columns v string row version, used for optimistic locking updated_at number timestamp (millis) of the last update created_at number timestamp (millis) of the table creation p.&lt;property_key&gt; string Iceberg-defined table properties including <code>table_type</code>, <code>metadata_location</code> and <code>previous_metadata_location</code> or namespace properties <p>This design has the following benefits:</p> <ol> <li>it avoids potential hot partition issue if there are heavy write traffic to the tables within the same namespace because the partition key is at the table level</li> <li>namespace operations are clustered in a single partition to avoid affecting table commit operations</li> <li>a sort key to partition key reverse GSI is used for list table operation, and all other operations are single row ops or single partition query. No full table scan is needed for any operation in the catalog.</li> <li>a string UUID version field <code>v</code> is used instead of <code>updated_at</code> to avoid 2 processes committing at the same millisecond</li> <li>multi-row transaction is used for <code>catalog.renameTable</code> to ensure idempotency</li> <li>properties are flattened as top level columns so that user can add custom GSI on any property field to customize the catalog. For example, users can store owner information as table property <code>owner</code>, and search tables by owner by adding a GSI on the <code>p.owner</code> column.</li> </ol>"},{"location":"aws/#rds-jdbc-catalog","title":"RDS JDBC Catalog","text":"<p>Iceberg also supports the JDBC catalog which uses a table in a relational database to manage Iceberg tables. You can configure to use the JDBC catalog with relational database services like AWS RDS. Read the JDBC integration page for guides and examples about using the JDBC catalog. Read this AWS documentation for more details about configuring the JDBC catalog with IAM authentication. </p>"},{"location":"aws/#which-catalog-to-choose","title":"Which catalog to choose?","text":"<p>With all the available options, we offer the following guidelines when choosing the right catalog to use for your application:</p> <ol> <li>if your organization has an existing Glue metastore or plans to use the AWS analytics ecosystem including Glue, Athena, EMR, Redshift and LakeFormation, Glue catalog provides the easiest integration.</li> <li>if your application requires frequent updates to table or high read and write throughput (e.g. streaming write), Glue and DynamoDB catalog provides the best performance through optimistic locking.</li> <li>if you would like to enforce access control for tables in a catalog, Glue tables can be managed as an IAM resource, whereas DynamoDB catalog tables can only be managed through item-level permission which is much more complicated.</li> <li>if you would like to query tables based on table property information without the need to scan the entire catalog, DynamoDB catalog allows you to build secondary indexes for any arbitrary property field and provide efficient query performance.</li> <li>if you would like to have the benefit of DynamoDB catalog while also connect to Glue, you can enable DynamoDB stream with Lambda trigger to asynchronously update your Glue metastore with table information in the DynamoDB catalog. </li> <li>if your organization already maintains an existing relational database in RDS or uses serverless Aurora to manage tables, the JDBC catalog provides the easiest integration.</li> </ol>"},{"location":"aws/#dynamodb-lock-manager","title":"DynamoDb Lock Manager","text":"<p>Amazon DynamoDB can be used by <code>HadoopCatalog</code> or <code>HadoopTables</code> so that for every commit, the catalog first obtains a lock using a helper DynamoDB table and then try to safely modify the Iceberg table. This is necessary for a file system-based catalog to ensure atomic transaction in storages like S3 that do not provide file write mutual exclusion.</p> <p>This feature requires the following lock related catalog properties:</p> <ol> <li>Set <code>lock-impl</code> as <code>org.apache.iceberg.aws.dynamodb.DynamoDbLockManager</code>.</li> <li>Set <code>lock.table</code> as the DynamoDB table name you would like to use. If the lock table with the given name does not exist in DynamoDB, a new table is created with billing mode set as pay-per-request.</li> </ol> <p>Other lock related catalog properties can also be used to adjust locking behaviors such as heartbeat interval. For more details, please refer to Lock catalog properties.</p>"},{"location":"aws/#s3-fileio","title":"S3 FileIO","text":"<p>Iceberg allows users to write data to S3 through <code>S3FileIO</code>. <code>GlueCatalog</code> by default uses this <code>FileIO</code>, and other catalogs can load this <code>FileIO</code> using the <code>io-impl</code> catalog property.</p>"},{"location":"aws/#progressive-multipart-upload","title":"Progressive Multipart Upload","text":"<p><code>S3FileIO</code> implements a customized progressive multipart upload algorithm to upload data. Data files are uploaded by parts in parallel as soon as each part is ready, and each file part is deleted as soon as its upload process completes. This provides maximized upload speed and minimized local disk usage during uploads. Here are the configurations that users can tune related to this feature:</p> Property Default Description s3.multipart.num-threads the available number of processors in the system number of threads to use for uploading parts to S3 (shared across all output streams) s3.multipart.part-size-bytes 32MB the size of a single part for multipart upload requests s3.multipart.threshold 1.5 the threshold expressed as a factor times the multipart size at which to switch from uploading using a single put object request to uploading using multipart upload s3.staging-dir <code>java.io.tmpdir</code> property value the directory to hold temporary files"},{"location":"aws/#s3-server-side-encryption","title":"S3 Server Side Encryption","text":"<p><code>S3FileIO</code> supports all 3 S3 server side encryption modes:</p> <ul> <li>SSE-S3: When you use Server-Side Encryption with Amazon S3-Managed Keys (SSE-S3), each object is encrypted with a unique key. As an additional safeguard, it encrypts the key itself with a master key that it regularly rotates. Amazon S3 server-side encryption uses one of the strongest block ciphers available, 256-bit Advanced Encryption Standard (AES-256), to encrypt your data.</li> <li>SSE-KMS: Server-Side Encryption with Customer Master Keys (CMKs) Stored in AWS Key Management Service (SSE-KMS) is similar to SSE-S3, but with some additional benefits and charges for using this service. There are separate permissions for the use of a CMK that provides added protection against unauthorized access of your objects in Amazon S3. SSE-KMS also provides you with an audit trail that shows when your CMK was used and by whom. Additionally, you can create and manage customer managed CMKs or use AWS managed CMKs that are unique to you, your service, and your Region.</li> <li>SSE-C: With Server-Side Encryption with Customer-Provided Keys (SSE-C), you manage the encryption keys and Amazon S3 manages the encryption, as it writes to disks, and decryption when you access your objects.</li> </ul> <p>To enable server side encryption, use the following configuration properties:</p> Property Default Description s3.sse.type <code>none</code> <code>none</code>, <code>s3</code>, <code>kms</code> or <code>custom</code> s3.sse.key <code>aws/s3</code> for <code>kms</code> type, null otherwise A KMS Key ID or ARN for <code>kms</code> type, or a custom base-64 AES256 symmetric key for <code>custom</code> type. s3.sse.md5 null If SSE type is <code>custom</code>, this value must be set as the base-64 MD5 digest of the symmetric key to ensure integrity."},{"location":"aws/#s3-access-control-list","title":"S3 Access Control List","text":"<p><code>S3FileIO</code> supports S3 access control list (ACL) for detailed access control.  User can choose the ACL level by setting the <code>s3.acl</code> property. For more details, please read S3 ACL Documentation.</p>"},{"location":"aws/#object-store-file-layout","title":"Object Store File Layout","text":"<p>S3 and many other cloud storage services throttle requests based on object prefix. Data stored in S3 with a traditional Hive storage layout can face S3 request throttling as objects are stored under the same file path prefix.</p> <p>Iceberg by default uses the Hive storage layout but can be switched to use the <code>ObjectStoreLocationProvider</code>.  With <code>ObjectStoreLocationProvider</code>, a deterministic hash is generated for each stored file, with the hash appended  directly after the <code>write.data.path</code>. This ensures files written to s3 are equally distributed across multiple prefixes in the S3 bucket. Resulting in minimized throttling and maximized throughput for S3-related IO operations. When using <code>ObjectStoreLocationProvider</code> having a shared and short <code>write.data.path</code> across your Iceberg tables will improve performance.</p> <p>For more information on how S3 scales API QPS, check out the 2018 re:Invent session on Best Practices for Amazon S3 and Amazon S3 Glacier. At 53:39 it covers how S3 scales/partitions &amp; at 54:50 it discusses the 30-60 minute wait time before new partitions are created.</p> <p>To use the <code>ObjectStorageLocationProvider</code> add <code>'write.object-storage.enabled'=true</code> in the table's properties.  Below is an example Spark SQL command to create a table using the <code>ObjectStorageLocationProvider</code>: <pre><code>CREATE TABLE my_catalog.my_ns.my_table (\nid bigint,\ndata string,\ncategory string)\nUSING iceberg\nOPTIONS (\n'write.object-storage.enabled'=true, 'write.data.path'='s3://my-table-data-bucket')\nPARTITIONED BY (category);\n</code></pre></p> <p>We can then insert a single row into this new table <pre><code>INSERT INTO my_catalog.my_ns.my_table VALUES (1, \"Pizza\", \"orders\");\n</code></pre></p> <p>Which will write the data to S3 with a hash (<code>2d3905f8</code>) appended directly after the <code>write.object-storage.path</code>, ensuring reads to the table are spread evenly  across S3 bucket prefixes, and improving performance. <pre><code>s3://my-table-data-bucket/2d3905f8/my_ns.db/my_table/category=orders/00000-0-5affc076-96a4-48f2-9cd2-d5efbc9f0c94-00001.parquet\n</code></pre></p> <p>Note, the path resolution logic for <code>ObjectStoreLocationProvider</code> is <code>write.data.path</code> then <code>&lt;tableLocation&gt;/data</code>. However, for the older versions up to 0.12.0, the logic is as follows: - before 0.12.0, <code>write.object-storage.path</code> must be set. - at 0.12.0, <code>write.object-storage.path</code> then <code>write.folder-storage.path</code> then <code>&lt;tableLocation&gt;/data</code>.</p> <p>For more details, please refer to the LocationProvider Configuration section.  </p>"},{"location":"aws/#s3-strong-consistency","title":"S3 Strong Consistency","text":"<p>In November 2020, S3 announced strong consistency for all read operations, and Iceberg is updated to fully leverage this feature. There is no redundant consistency wait and check which might negatively impact performance during IO operations.</p>"},{"location":"aws/#hadoop-s3a-filesystem","title":"Hadoop S3A FileSystem","text":"<p>Before <code>S3FileIO</code> was introduced, many Iceberg users choose to use <code>HadoopFileIO</code> to write data to S3 through the S3A FileSystem. As introduced in the previous sections, <code>S3FileIO</code> adopts the latest AWS clients and S3 features for optimized security and performance  and is thus recommended for S3 use cases rather than the S3A FileSystem.</p> <p><code>S3FileIO</code> writes data with <code>s3://</code> URI scheme, but it is also compatible with schemes written by the S3A FileSystem. This means for any table manifests containing <code>s3a://</code> or <code>s3n://</code> file paths, <code>S3FileIO</code> is still able to read them. This feature allows people to easily switch from S3A to <code>S3FileIO</code>.</p> <p>If for any reason you have to use S3A, here are the instructions:</p> <ol> <li>To store data using S3A, specify the <code>warehouse</code> catalog property to be an S3A path, e.g. <code>s3a://my-bucket/my-warehouse</code> </li> <li>For <code>HiveCatalog</code>, to also store metadata using S3A, specify the Hadoop config property <code>hive.metastore.warehouse.dir</code> to be an S3A path.</li> <li>Add hadoop-aws as a runtime dependency of your compute engine.</li> <li>Configure AWS settings based on hadoop-aws documentation (make sure you check the version, S3A configuration varies a lot based on the version you use).   </li> </ol>"},{"location":"aws/#s3-write-checksum-verification","title":"S3 Write Checksum Verification","text":"<p>To ensure integrity of uploaded objects, checksum validations for S3 writes can be turned on by setting catalog property <code>s3.checksum-enabled</code> to <code>true</code>.  This is turned off by default.</p>"},{"location":"aws/#s3-tags","title":"S3 Tags","text":"<p>Custom tags can be added to S3 objects while writing and deleting. For example, to write S3 tags with Spark 3.3, you can start the Spark SQL shell with: <pre><code>spark-sql --conf spark.sql.catalog.my_catalog=org.apache.iceberg.spark.SparkCatalog \\\n    --conf spark.sql.catalog.my_catalog.warehouse=s3://my-bucket/my/key/prefix \\\n    --conf spark.sql.catalog.my_catalog.catalog-impl=org.apache.iceberg.aws.glue.GlueCatalog \\\n    --conf spark.sql.catalog.my_catalog.io-impl=org.apache.iceberg.aws.s3.S3FileIO \\\n    --conf spark.sql.catalog.my_catalog.s3.write.tags.my_key1=my_val1 \\\n    --conf spark.sql.catalog.my_catalog.s3.write.tags.my_key2=my_val2\n</code></pre> For the above example, the objects in S3 will be saved with tags: <code>my_key1=my_val1</code> and <code>my_key2=my_val2</code>. Do note that the specified write tags will be saved only while object creation.</p> <p>When the catalog property <code>s3.delete-enabled</code> is set to <code>false</code>, the objects are not hard-deleted from S3. This is expected to be used in combination with S3 delete tagging, so objects are tagged and removed using S3 lifecycle policy. The property is set to <code>true</code> by default.</p> <p>With the <code>s3.delete.tags</code> config, objects are tagged with the configured key-value pairs before deletion. Users can configure tag-based object lifecycle policy at bucket level to transition objects to different tiers. For example, to add S3 delete tags with Spark 3.3, you can start the Spark SQL shell with: </p> <pre><code>sh spark-sql --conf spark.sql.catalog.my_catalog=org.apache.iceberg.spark.SparkCatalog \\\n    --conf spark.sql.catalog.my_catalog.warehouse=s3://iceberg-warehouse/s3-tagging \\\n    --conf spark.sql.catalog.my_catalog.catalog-impl=org.apache.iceberg.aws.glue.GlueCatalog \\\n    --conf spark.sql.catalog.my_catalog.io-impl=org.apache.iceberg.aws.s3.S3FileIO \\\n    --conf spark.sql.catalog.my_catalog.s3.delete.tags.my_key3=my_val3 \\\n    --conf spark.sql.catalog.my_catalog.s3.delete-enabled=false\n</code></pre> <p>For the above example, the objects in S3 will be saved with tags: <code>my_key3=my_val3</code> before deletion. Users can also use the catalog property <code>s3.delete.num-threads</code> to mention the number of threads to be used for adding delete tags to the S3 objects.</p> <p>When the catalog property <code>s3.write.table-tag-enabled</code> and <code>s3.write.namespace-tag-enabled</code> is set to <code>true</code> then the objects in S3 will be saved with tags: <code>iceberg.table=&lt;table-name&gt;</code> and <code>iceberg.namespace=&lt;namespace-name&gt;</code>. Users can define access and data retention policy per namespace or table based on these tags. For example, to write table and namespace name as S3 tags with Spark 3.3, you can start the Spark SQL shell with: <pre><code>sh spark-sql --conf spark.sql.catalog.my_catalog=org.apache.iceberg.spark.SparkCatalog \\\n    --conf spark.sql.catalog.my_catalog.warehouse=s3://iceberg-warehouse/s3-tagging \\\n    --conf spark.sql.catalog.my_catalog.catalog-impl=org.apache.iceberg.aws.glue.GlueCatalog \\\n    --conf spark.sql.catalog.my_catalog.io-impl=org.apache.iceberg.aws.s3.S3FileIO \\\n    --conf spark.sql.catalog.my_catalog.s3.write.table-tag-enabled=true \\\n    --conf spark.sql.catalog.my_catalog.s3.write.namespace-tag-enabled=true\n</code></pre> For more details on tag restrictions, please refer User-Defined Tag Restrictions.</p>"},{"location":"aws/#s3-access-points","title":"S3 Access Points","text":"<p>Access Points can be used to perform  S3 operations by specifying a mapping of bucket to access points. This is useful for multi-region access, cross-region access, disaster recovery, etc.</p> <p>For using cross-region access points, we need to additionally set <code>use-arn-region-enabled</code> catalog property to <code>true</code> to enable <code>S3FileIO</code> to make cross-region calls, it's not required for same / multi-region access points.</p> <p>For example, to use S3 access-point with Spark 3.3, you can start the Spark SQL shell with: <pre><code>spark-sql --conf spark.sql.catalog.my_catalog=org.apache.iceberg.spark.SparkCatalog \\\n    --conf spark.sql.catalog.my_catalog.warehouse=s3://my-bucket2/my/key/prefix \\\n    --conf spark.sql.catalog.my_catalog.catalog-impl=org.apache.iceberg.aws.glue.GlueCatalog \\\n    --conf spark.sql.catalog.my_catalog.io-impl=org.apache.iceberg.aws.s3.S3FileIO \\\n    --conf spark.sql.catalog.my_catalog.s3.use-arn-region-enabled=false \\\n    --conf spark.sql.catalog.test.s3.access-points.my-bucket1=arn:aws:s3::123456789012:accesspoint:mfzwi23gnjvgw.mrap \\\n    --conf spark.sql.catalog.test.s3.access-points.my-bucket2=arn:aws:s3::123456789012:accesspoint:mfzwi23gnjvgw.mrap\n</code></pre> For the above example, the objects in S3 on <code>my-bucket1</code> and <code>my-bucket2</code> buckets will use <code>arn:aws:s3::123456789012:accesspoint:mfzwi23gnjvgw.mrap</code> access-point for all S3 operations.</p> <p>For more details on using access-points, please refer Using access points with compatible Amazon S3 operations.</p>"},{"location":"aws/#s3-acceleration","title":"S3 Acceleration","text":"<p>S3 Acceleration can be used to speed up transfers to and from Amazon S3 by as much as 50-500% for long-distance transfer of larger objects.</p> <p>To use S3 Acceleration, we need to set <code>s3.acceleration-enabled</code> catalog property to <code>true</code> to enable <code>S3FileIO</code> to make accelerated S3 calls.</p> <p>For example, to use S3 Acceleration with Spark 3.3, you can start the Spark SQL shell with: <pre><code>spark-sql --conf spark.sql.catalog.my_catalog=org.apache.iceberg.spark.SparkCatalog \\\n    --conf spark.sql.catalog.my_catalog.warehouse=s3://my-bucket2/my/key/prefix \\\n    --conf spark.sql.catalog.my_catalog.catalog-impl=org.apache.iceberg.aws.glue.GlueCatalog \\\n    --conf spark.sql.catalog.my_catalog.io-impl=org.apache.iceberg.aws.s3.S3FileIO \\\n    --conf spark.sql.catalog.my_catalog.s3.acceleration-enabled=true\n</code></pre></p> <p>For more details on using S3 Acceleration, please refer to Configuring fast, secure file transfers using Amazon S3 Transfer Acceleration.</p>"},{"location":"aws/#s3-dual-stack","title":"S3 Dual-stack","text":"<p>S3 Dual-stack allows a client to access an S3 bucket through a dual-stack endpoint.  When clients request a dual-stack endpoint, the bucket URL resolves to an IPv6 address if possible, otherwise fallback to IPv4.</p> <p>To use S3 Dual-stack, we need to set <code>s3.dualstack-enabled</code> catalog property to <code>true</code> to enable <code>S3FileIO</code> to make dual-stack S3 calls.</p> <p>For example, to use S3 Dual-stack with Spark 3.3, you can start the Spark SQL shell with: <pre><code>spark-sql --conf spark.sql.catalog.my_catalog=org.apache.iceberg.spark.SparkCatalog \\\n    --conf spark.sql.catalog.my_catalog.warehouse=s3://my-bucket2/my/key/prefix \\\n    --conf spark.sql.catalog.my_catalog.catalog-impl=org.apache.iceberg.aws.glue.GlueCatalog \\\n    --conf spark.sql.catalog.my_catalog.io-impl=org.apache.iceberg.aws.s3.S3FileIO \\\n    --conf spark.sql.catalog.my_catalog.s3.dualstack-enabled=true\n</code></pre></p> <p>For more details on using S3 Dual-stack, please refer Using dual-stack endpoints from the AWS CLI and the AWS SDKs</p>"},{"location":"aws/#aws-client-customization","title":"AWS Client Customization","text":"<p>Many organizations have customized their way of configuring AWS clients with their own credential provider, access proxy, retry strategy, etc. Iceberg allows users to plug in their own implementation of <code>org.apache.iceberg.aws.AwsClientFactory</code> by setting the <code>client.factory</code> catalog property.</p>"},{"location":"aws/#cross-account-and-cross-region-access","title":"Cross-Account and Cross-Region Access","text":"<p>It is a common use case for organizations to have a centralized AWS account for Glue metastore and S3 buckets, and use different AWS accounts and regions for different teams to access those resources. In this case, a cross-account IAM role is needed to access those centralized resources. Iceberg provides an AWS client factory <code>AssumeRoleAwsClientFactory</code> to support this common use case. This also serves as an example for users who would like to implement their own AWS client factory.</p> <p>This client factory has the following configurable catalog properties:</p> Property Default Description client.assume-role.arn null, requires user input ARN of the role to assume, e.g. arn:aws:iam::123456789:role/myRoleToAssume client.assume-role.region null, requires user input All AWS clients except the STS client will use the given region instead of the default region chain client.assume-role.external-id null An optional external ID client.assume-role.timeout-sec 1 hour Timeout of each assume role session. At the end of the timeout, a new set of role session credentials will be fetched through an STS client. <p>By using this client factory, an STS client is initialized with the default credential and region to assume the specified role. The Glue, S3 and DynamoDB clients are then initialized with the assume-role credential and region to access resources. Here is an example to start Spark shell with this client factory:</p> <pre><code>spark-sql --packages org.apache.iceberg:iceberg-spark-runtime:{{ icebergVersion }},software.amazon.awssdk:bundle:2.20.18 \\\n--conf spark.sql.catalog.my_catalog=org.apache.iceberg.spark.SparkCatalog \\\n--conf spark.sql.catalog.my_catalog.warehouse=s3://my-bucket/my/key/prefix \\    --conf spark.sql.catalog.my_catalog.catalog-impl=org.apache.iceberg.aws.glue.GlueCatalog \\\n--conf spark.sql.catalog.my_catalog.client.factory=org.apache.iceberg.aws.AssumeRoleAwsClientFactory \\\n--conf spark.sql.catalog.my_catalog.client.assume-role.arn=arn:aws:iam::123456789:role/myRoleToAssume \\\n--conf spark.sql.catalog.my_catalog.client.assume-role.region=ap-northeast-1\n</code></pre>"},{"location":"aws/#http-client-configurations","title":"HTTP Client Configurations","text":"<p>AWS clients support two types of HTTP Client, URL Connection HTTP Client  and Apache HTTP Client. By default, AWS clients use URL Connection HTTP Client to communicate with the service.  This HTTP client optimizes for minimum dependencies and startup latency but supports less functionality than other implementations.  In contrast, Apache HTTP Client supports more functionalities and more customized settings, such as expect-continue handshake and TCP KeepAlive, at the cost of extra dependency and additional startup latency. </p> <p>For more details of configuration, see sections URL Connection HTTP Client Configurations and Apache HTTP Client Configurations.</p> <p>Configure the following property to set the type of HTTP client:</p> Property Default Description http-client.type apache Types of HTTP Client.  <code>urlconnection</code>: URL Connection HTTP Client  <code>apache</code>: Apache HTTP Client"},{"location":"aws/#url-connection-http-client-configurations","title":"URL Connection HTTP Client Configurations","text":"<p>URL Connection HTTP Client has the following configurable properties:</p> Property Default Description http-client.urlconnection.socket-timeout-ms null An optional socket timeout in milliseconds http-client.urlconnection.connection-timeout-ms null An optional connection timeout in milliseconds <p>Users can use catalog properties to override the defaults. For example, to configure the socket timeout for URL Connection HTTP Client when starting a spark shell, one can add: <pre><code>--conf spark.sql.catalog.my_catalog.http-client.urlconnection.socket-timeout-ms=80\n</code></pre></p>"},{"location":"aws/#apache-http-client-configurations","title":"Apache HTTP Client Configurations","text":"<p>Apache HTTP Client has the following configurable properties:</p> Property Default Description http-client.apache.socket-timeout-ms null An optional socket timeout in milliseconds http-client.apache.connection-timeout-ms null An optional connection timeout in milliseconds http-client.apache.connection-acquisition-timeout-ms null An optional connection acquisition timeout in milliseconds http-client.apache.connection-max-idle-time-ms null An optional connection max idle timeout in milliseconds http-client.apache.connection-time-to-live-ms null An optional connection time to live in milliseconds http-client.apache.expect-continue-enabled null, disabled by default An optional <code>true/false</code> setting that controls whether expect continue is enabled http-client.apache.max-connections null An optional max connections  in integer http-client.apache.tcp-keep-alive-enabled null, disabled by default An optional <code>true/false</code> setting that controls whether tcp keep alive is enabled http-client.apache.use-idle-connection-reaper-enabled null, enabled by default An optional <code>true/false</code> setting that controls whether use idle connection reaper is used <p>Users can use catalog properties to override the defaults. For example, to configure the max connections for Apache HTTP Client when starting a spark shell, one can add: <pre><code>--conf spark.sql.catalog.my_catalog.http-client.apache.max-connections=5\n</code></pre></p>"},{"location":"aws/#run-iceberg-on-aws","title":"Run Iceberg on AWS","text":""},{"location":"aws/#amazon-athena","title":"Amazon Athena","text":"<p>Amazon Athena provides a serverless query engine that could be used to perform read, write, update and optimization tasks against Iceberg tables. More details could be found here.</p>"},{"location":"aws/#amazon-emr","title":"Amazon EMR","text":"<p>Amazon EMR can provision clusters with Spark (EMR 6 for Spark 3, EMR 5 for Spark 2), Hive, Flink, Trino that can run Iceberg.</p> <p>Starting with EMR version 6.5.0, EMR clusters can be configured to have the necessary Apache Iceberg dependencies installed without requiring bootstrap actions.  Please refer to the official documentation on how to create a cluster with Iceberg installed.</p> <p>For versions before 6.5.0, you can use a bootstrap action similar to the following to pre-install all necessary dependencies: <pre><code>#!/bin/bash\nAWS_SDK_VERSION=2.20.18\nICEBERG_VERSION={{ icebergVersion }}\nMAVEN_URL=https://repo1.maven.org/maven2\nICEBERG_MAVEN_URL=$MAVEN_URL/org/apache/iceberg\nAWS_MAVEN_URL=$MAVEN_URL/software/amazon/awssdk\n# NOTE: this is just an example shared class path between Spark and Flink,\n#  please choose a proper class path for production.\nLIB_PATH=/usr/share/aws/aws-java-sdk/\n\nAWS_PACKAGES=(\n\"bundle\"\n)\nICEBERG_PACKAGES=(\n\"iceberg-spark-runtime-3.3_2.12\"\n\"iceberg-flink-runtime\"\n)\ninstall_dependencies () {\ninstall_path=$1\ndownload_url=$2\nversion=$3\nshift\npkgs=(\"$@\")\nfor pkg in \"${pkgs[@]}\"; do\nsudo wget -P $install_path $download_url/$pkg/$version/$pkg-$version.jar\n  done\n}\ninstall_dependencies $LIB_PATH $ICEBERG_MAVEN_URL $ICEBERG_VERSION \"${ICEBERG_PACKAGES[@]}\"\ninstall_dependencies $LIB_PATH $AWS_MAVEN_URL $AWS_SDK_VERSION \"${AWS_PACKAGES[@]}\"\n</code></pre></p>"},{"location":"aws/#aws-glue","title":"AWS Glue","text":"<p>AWS Glue provides a serverless data integration service that could be used to perform read, write and update tasks against Iceberg tables. More details could be found here.</p>"},{"location":"aws/#aws-eks","title":"AWS EKS","text":"<p>AWS Elastic Kubernetes Service (EKS) can be used to start any Spark, Flink, Hive, Presto or Trino clusters to work with Iceberg. Search the Iceberg blogs page for tutorials around running Iceberg with Docker and Kubernetes.</p>"},{"location":"aws/#amazon-kinesis","title":"Amazon Kinesis","text":"<p>Amazon Kinesis Data Analytics provides a platform  to run fully managed Apache Flink applications. You can include Iceberg in your application Jar and run it in the platform.</p>"},{"location":"branching/","title":"Branching and Tagging","text":""},{"location":"branching/#branching-and-tagging","title":"Branching and Tagging","text":""},{"location":"branching/#overview","title":"Overview","text":"<p>Iceberg table metadata maintains a log of snapshots which represent the changes applied to a table. Snapshots are fundamental in Iceberg as they are the basis for reader isolation and time travel queries. For controlling metadata size and storage costs, Iceberg provides snapshot lifecycle management procedures such as <code>expire_snapshots</code> for removing unused snapshots and no longer neccessary data files based on table snapshot retention properties.</p> <p>For more sophisticated snapshot lifecycle management, Iceberg supports branches and tags which are named references to snapshots with their own independent lifecycles. This lifecycle is controlled by branch and tag level retention policies.  Branches are independent lineages of snapshots and point to the head of the lineage.  Branches and tags have a maximum reference age property which control when the reference to the snapshot itself should be expired. Branches have retention properties which define the minimum number of snapshots to retain on a branch as well as the maximum age of individual snapshots to retain on the branch.  These properties are used when the expireSnapshots procedure is run.  For details on the algorithm for expireSnapshots, refer to the spec.</p>"},{"location":"branching/#use-cases","title":"Use Cases","text":"<p>Branching and tagging can be used for handling GDPR requirements and retaining important historical snapshots for auditing. Branches can also be used as part of data engineering workflows, for enabling experimental branches for testing and validating new jobs. See below for some examples of how branching and tagging can facilitate these use cases.</p>"},{"location":"branching/#historical-tags","title":"Historical Tags","text":"<p>Tags can be used for retaining important historical snapshots for auditing purposes.</p> <p></p> <p>The above diagram demonstrates retaininig important historical snapshot with the following retention policy, defined  via Spark SQL.</p> <ol> <li> <p>Retain 1 snapshot per week for 1 month. This can be achieved by tagging the weekly snapshot and setting the tag retention to be a month. snapshots will be kept, and the branch reference itself will be retained for 1 week.  <pre><code>-- Create a tag for the first end of week snapshot. Retain the snapshot for a week\nALTER TABLE prod.db.table CREATE TAG 'EOW-01' AS OF VERSION 7 RETAIN 7 DAYS\n</code></pre></p> </li> <li> <p>Retain 1 snapshot per month for 6 months. This can be achieved by tagging the monthly snapshot and setting the tag retention to be 6 months. <pre><code>-- Create a tag for the first end of month snapshot. Retain the snapshot for 6 months\nALTER TABLE prod.db.table CREATE TAG 'EOM-01' AS OF VERSION 30 RETAIN 180 DAYS\n</code></pre></p> </li> <li> <p>Retain 1 snapshot per year forever. This can be achieved by tagging the annual snapshot. The default retention for branches and tags is forever. <pre><code>-- Create a tag for the end of the year and retain it forever.\nALTER TABLE prod.db.table CREATE TAG 'EOY-2023' AS OF VERSION 365\n</code></pre></p> </li> <li> <p>Create a temporary \"test-branch\" which is retained for 7 days and the latest 2 snapshots on the branch are retained. <pre><code>-- Create a branch \"test-branch\" which will be retained for 7 days along with the  latest 2 snapshots\nALTER TABLE prod.db.table CREATE BRANCH test-branch RETAIN 7 DAYS WITH RETENTION 2 SNAPSHOTS\n</code></pre></p> </li> </ol>"},{"location":"branching/#audit-branch","title":"Audit Branch","text":"<p>The above diagram shows an example of using an audit branch for validating a write workflow. </p> <ol> <li>First ensure <code>write.wap.enabled</code> is set. <pre><code>ALTER TABLE db.table SET TBLPROPERTIES (\n'write.wap.enabled''true'\n)\n</code></pre></li> <li>Create <code>audit-branch</code> starting from snapshot 3, which will be written to and retained for 1 week. <pre><code>ALTER TABLE db.table CREATE BRANCH `audit-branch` AS OF VERSION 3 RETAIN 7 DAYS\n</code></pre></li> <li>Writes are performed on a separate <code>audit-branch</code> independent from the main table history. <pre><code>-- WAP Branch write\nSET spark.wap.branch = 'audit-branch'\nINSERT INTO prod.db.table VALUES (3, 'c')\n</code></pre></li> <li>A validation workflow can validate (e.g. data quality) the state of <code>audit-branch</code>.</li> <li>After validation, the main branch can be <code>fastForward</code> to the head of <code>audit-branch</code> to update the main table state. <pre><code>table.manageSnapshots().fastForward(\"main\", \"audit-branch\").commit()\n</code></pre></li> <li>The branch reference will be removed when <code>expireSnapshots</code> is run 1 week later.</li> </ol>"},{"location":"branching/#usage","title":"Usage","text":"<p>Creating, querying and writing to branches and tags are supported in the Iceberg Java library, and in Spark and Flink engine integrations.</p> <ul> <li>Iceberg Java Library</li> <li>Spark DDLs</li> <li>Spark Reads</li> <li>Spark Branch Writes</li> <li>Flink Reads</li> <li>Flink Branch Writes</li> </ul>"},{"location":"configuration/","title":"Configuration","text":""},{"location":"configuration/#configuration","title":"Configuration","text":""},{"location":"configuration/#table-properties","title":"Table properties","text":"<p>Iceberg tables support table properties to configure table behavior, like the default split size for readers.</p>"},{"location":"configuration/#read-properties","title":"Read properties","text":"Property Default Description read.split.target-size 134217728 (128 MB) Target size when combining data input splits read.split.metadata-target-size 33554432 (32 MB) Target size when combining metadata input splits read.split.planning-lookback 10 Number of bins to consider when combining input splits read.split.open-file-cost 4194304 (4 MB) The estimated cost to open a file, used as a minimum weight when combining splits. read.parquet.vectorization.enabled true Controls whether Parquet vectorized reads are used read.parquet.vectorization.batch-size 5000 The batch size for parquet vectorized reads read.orc.vectorization.enabled false Controls whether orc vectorized reads are used read.orc.vectorization.batch-size 5000 The batch size for orc vectorized reads"},{"location":"configuration/#write-properties","title":"Write properties","text":"Property Default Description write.format.default parquet Default file format for the table; parquet, avro, or orc write.delete.format.default data file format Default delete file format for the table; parquet, avro, or orc write.parquet.row-group-size-bytes 134217728 (128 MB) Parquet row group size write.parquet.page-size-bytes 1048576 (1 MB) Parquet page size write.parquet.page-row-limit 20000 Parquet page row limit write.parquet.dict-size-bytes 2097152 (2 MB) Parquet dictionary page size write.parquet.compression-codec gzip Parquet compression codec: zstd, brotli, lz4, gzip, snappy, uncompressed write.parquet.compression-level null Parquet compression level write.parquet.bloom-filter-enabled.column.col1 (not set) Enables writing a bloom filter for the column: col1 write.parquet.bloom-filter-max-bytes 1048576 (1 MB) The maximum number of bytes for a bloom filter bitset write.avro.compression-codec gzip Avro compression codec: gzip(deflate with 9 level), zstd, snappy, uncompressed write.avro.compression-level null Avro compression level write.orc.stripe-size-bytes 67108864 (64 MB) Define the default ORC stripe size, in bytes write.orc.block-size-bytes 268435456 (256 MB) Define the default file system block size for ORC files write.orc.compression-codec zlib ORC compression codec: zstd, lz4, lzo, zlib, snappy, none write.orc.compression-strategy speed ORC compression strategy: speed, compression write.orc.bloom.filter.columns (not set) Comma separated list of column names for which a Bloom filter must be created write.orc.bloom.filter.fpp 0.05 False positive probability for Bloom filter (must &gt; 0.0 and &lt; 1.0) write.location-provider.impl null Optional custom implementation for LocationProvider write.metadata.compression-codec none Metadata compression codec; none or gzip write.metadata.metrics.max-inferred-column-defaults 100 Defines the maximum number of columns for which metrics are collected write.metadata.metrics.default truncate(16) Default metrics mode for all columns in the table; none, counts, truncate(length), or full write.metadata.metrics.column.col1 (not set) Metrics mode for column 'col1' to allow per-column tuning; none, counts, truncate(length), or full write.target-file-size-bytes 536870912 (512 MB) Controls the size of files generated to target about this many bytes write.delete.target-file-size-bytes 67108864 (64 MB) Controls the size of delete files generated to target about this many bytes write.distribution-mode none Defines distribution of write data: none: don't shuffle rows; hash: hash distribute by partition key ; range: range distribute by partition key or sort key if table has an SortOrder write.delete.distribution-mode hash Defines distribution of write delete data write.update.distribution-mode hash Defines distribution of write update data write.merge.distribution-mode none Defines distribution of write merge data write.wap.enabled false Enables write-audit-publish writes write.summary.partition-limit 0 Includes partition-level summary stats in snapshot summaries if the changed partition count is less than this limit write.metadata.delete-after-commit.enabled false Controls whether to delete the oldest tracked version metadata files after commit write.metadata.previous-versions-max 100 The max number of previous version metadata files to keep before deleting after commit write.spark.fanout.enabled false Enables the fanout writer in Spark that does not require data to be clustered; uses more memory write.object-storage.enabled false Enables the object storage location provider that adds a hash component to file paths write.data.path table location + /data Base location for data files write.metadata.path table location + /metadata Base location for metadata files write.delete.mode copy-on-write Mode used for delete commands: copy-on-write or merge-on-read (v2 only) write.delete.isolation-level serializable Isolation level for delete commands: serializable or snapshot write.update.mode copy-on-write Mode used for update commands: copy-on-write or merge-on-read (v2 only) write.update.isolation-level serializable Isolation level for update commands: serializable or snapshot write.merge.mode copy-on-write Mode used for merge commands: copy-on-write or merge-on-read (v2 only) write.merge.isolation-level serializable Isolation level for merge commands: serializable or snapshot"},{"location":"configuration/#table-behavior-properties","title":"Table behavior properties","text":"Property Default Description commit.retry.num-retries 4 Number of times to retry a commit before failing commit.retry.min-wait-ms 100 Minimum time in milliseconds to wait before retrying a commit commit.retry.max-wait-ms 60000 (1 min) Maximum time in milliseconds to wait before retrying a commit commit.retry.total-timeout-ms 1800000 (30 min) Total retry timeout period in milliseconds for a commit commit.status-check.num-retries 3 Number of times to check whether a commit succeeded after a connection is lost before failing due to an unknown commit state commit.status-check.min-wait-ms 1000 (1s) Minimum time in milliseconds to wait before retrying a status-check commit.status-check.max-wait-ms 60000 (1 min) Maximum time in milliseconds to wait before retrying a status-check commit.status-check.total-timeout-ms 1800000 (30 min) Total timeout period in which the commit status-check must succeed, in milliseconds commit.manifest.target-size-bytes 8388608 (8 MB) Target size when merging manifest files commit.manifest.min-count-to-merge 100 Minimum number of manifests to accumulate before merging commit.manifest-merge.enabled true Controls whether to automatically merge manifests on writes history.expire.max-snapshot-age-ms 432000000 (5 days) Default max age of snapshots to keep on the table and all of its branches while expiring snapshots history.expire.min-snapshots-to-keep 1 Default min number of snapshots to keep on the table and all of its branches while expiring snapshots history.expire.max-ref-age-ms <code>Long.MAX_VALUE</code> (forever) For snapshot references except the <code>main</code> branch, default max age of snapshot references to keep while expiring snapshots. The <code>main</code> branch never expires."},{"location":"configuration/#reserved-table-properties","title":"Reserved table properties","text":"<p>Reserved table properties are only used to control behaviors when creating or updating a table. The value of these properties are not persisted as a part of the table metadata.</p> Property Default Description format-version 1 Table's format version (can be 1 or 2) as defined in the Spec."},{"location":"configuration/#compatibility-flags","title":"Compatibility flags","text":"Property Default Description compatibility.snapshot-id-inheritance.enabled false Enables committing snapshots without explicit snapshot IDs"},{"location":"configuration/#catalog-properties","title":"Catalog properties","text":"<p>Iceberg catalogs support using catalog properties to configure catalog behaviors. Here is a list of commonly used catalog properties:</p> Property Default Description catalog-impl null a custom <code>Catalog</code> implementation to use by an engine io-impl null a custom <code>FileIO</code> implementation to use in a catalog warehouse null the root path of the data warehouse uri null a URI string, such as Hive metastore URI clients 2 client pool size cache-enabled true Whether to cache catalog entries cache.expiration-interval-ms 30000 How long catalog entries are locally cached, in milliseconds; 0 disables caching, negative values disable expiration <p><code>HadoopCatalog</code> and <code>HiveCatalog</code> can access the properties in their constructors. Any other custom catalog can access the properties by implementing <code>Catalog.initialize(catalogName, catalogProperties)</code>. The properties can be manually constructed or passed in from a compute engine like Spark or Flink. Spark uses its session properties as catalog properties, see more details in the Spark configuration section. Flink passes in catalog properties through <code>CREATE CATALOG</code> statement, see more details in the Flink section.</p>"},{"location":"configuration/#lock-catalog-properties","title":"Lock catalog properties","text":"<p>Here are the catalog properties related to locking. They are used by some catalog implementations to control the locking behavior during commits.</p> Property Default Description lock-impl null a custom implementation of the lock manager, the actual interface depends on the catalog used lock.table null an auxiliary table for locking, such as in AWS DynamoDB lock manager lock.acquire-interval-ms 5000 (5 s) the interval to wait between each attempt to acquire a lock lock.acquire-timeout-ms 180000 (3 min) the maximum time to try acquiring a lock lock.heartbeat-interval-ms 3000 (3 s) the interval to wait between each heartbeat after acquiring a lock lock.heartbeat-timeout-ms 15000 (15 s) the maximum time without a heartbeat to consider a lock expired"},{"location":"configuration/#hadoop-configuration","title":"Hadoop configuration","text":"<p>The following properties from the Hadoop configuration are used by the Hive Metastore connector. The HMS table locking is a 2-step process: 1. Lock Creation: Create lock in HMS and queue for acquisition 2. Lock Check: Check if lock successfully acquired</p> Property Default Description iceberg.hive.client-pool-size 5 The size of the Hive client pool when tracking tables in HMS iceberg.hive.lock-creation-timeout-ms 180000 (3 min) Maximum time in milliseconds to create a lock in the HMS iceberg.hive.lock-creation-min-wait-ms 50 Minimum time in milliseconds between retries of creating the lock in the HMS iceberg.hive.lock-creation-max-wait-ms 5000 Maximum time in milliseconds between retries of creating the lock in the HMS iceberg.hive.lock-timeout-ms 180000 (3 min) Maximum time in milliseconds to acquire a lock iceberg.hive.lock-check-min-wait-ms 50 Minimum time in milliseconds between checking the acquisition of the lock iceberg.hive.lock-check-max-wait-ms 5000 Maximum time in milliseconds between checking the acquisition of the lock iceberg.hive.lock-heartbeat-interval-ms 240000 (4 min) The heartbeat interval for the HMS locks. iceberg.hive.metadata-refresh-max-retries 2 Maximum number of retries when the metadata file is missing iceberg.hive.table-level-lock-evict-ms 600000 (10 min) The timeout for the JVM table lock is iceberg.engine.hive.lock-enabled true Use HMS locks to ensure atomicity of commits <p>Note: <code>iceberg.hive.lock-check-max-wait-ms</code> and <code>iceberg.hive.lock-heartbeat-interval-ms</code> should be less than the transaction timeout  of the Hive Metastore (<code>hive.txn.timeout</code> or <code>metastore.txn.timeout</code> in the newer versions). Otherwise, the heartbeats on the lock (which happens during the lock checks) would end up expiring in the  Hive Metastore before the lock is retried from Iceberg.</p> <p>Warn: Setting <code>iceberg.engine.hive.lock-enabled</code>=<code>false</code> will cause HiveCatalog to commit to tables without using Hive locks. This should only be set to <code>false</code> if all following conditions are met:  - HIVE-26882 is available on the Hive Metastore server  - All other HiveCatalogs committing to tables that this HiveCatalog commits to are also on Iceberg 1.3 or later  - All other HiveCatalogs committing to tables that this HiveCatalog commits to have also disabled Hive locks on commit.</p> <p>Failing to ensure these conditions risks corrupting the table.</p> <p>Even with <code>iceberg.engine.hive.lock-enabled</code> set to <code>false</code>, a HiveCatalog can still use locks for individual tables by setting the table property <code>engine.hive.lock-enabled</code>=<code>true</code>. This is useful in the case where other HiveCatalogs cannot be upgraded and set to commit without using Hive locks.</p>"},{"location":"custom-catalog/","title":"Java Custom Catalog","text":""},{"location":"custom-catalog/#custom-catalog","title":"Custom Catalog","text":"<p>It's possible to read an iceberg table either from an hdfs path or from a hive table. It's also possible to use a custom metastore in place of hive. The steps to do that are as follows.</p> <ul> <li>Custom TableOperations</li> <li>Custom Catalog</li> <li>Custom FileIO</li> <li>Custom LocationProvider</li> <li>Custom IcebergSource</li> </ul>"},{"location":"custom-catalog/#custom-table-operations-implementation","title":"Custom table operations implementation","text":"<p>Extend <code>BaseMetastoreTableOperations</code> to provide implementation on how to read and write metadata</p> <p>Example: <pre><code>class CustomTableOperations extends BaseMetastoreTableOperations {\nprivate String dbName;\nprivate String tableName;\nprivate Configuration conf;\nprivate FileIO fileIO;\nprotected CustomTableOperations(Configuration conf, String dbName, String tableName) {\nthis.conf = conf;\nthis.dbName = dbName;\nthis.tableName = tableName;\n}\n// The doRefresh method should provide implementation on how to get the metadata location\n@Override\npublic void doRefresh() {\n// Example custom service which returns the metadata location given a dbName and tableName\nString metadataLocation = CustomService.getMetadataForTable(conf, dbName, tableName);\n// When updating from a metadata file location, call the helper method\nrefreshFromMetadataLocation(metadataLocation);\n}\n// The doCommit method should provide implementation on how to update with metadata location atomically\n@Override\npublic void doCommit(TableMetadata base, TableMetadata metadata) {\nString oldMetadataLocation = base.location();\n// Write new metadata using helper method\nString newMetadataLocation = writeNewMetadata(metadata, currentVersion() + 1);\n// Example custom service which updates the metadata location for the given db and table atomically\nCustomService.updateMetadataLocation(dbName, tableName, oldMetadataLocation, newMetadataLocation);\n}\n// The io method provides a FileIO which is used to read and write the table metadata files\n@Override\npublic FileIO io() {\nif (fileIO == null) {\nfileIO = new HadoopFileIO(conf);\n}\nreturn fileIO;\n}\n}\n</code></pre></p> <p>A <code>TableOperations</code> instance is usually obtained by calling <code>Catalog.newTableOps(TableIdentifier)</code>. See the next section about implementing and loading a custom catalog.</p>"},{"location":"custom-catalog/#custom-catalog-implementation","title":"Custom catalog implementation","text":"<p>Extend <code>BaseMetastoreCatalog</code> to provide default warehouse locations and instantiate <code>CustomTableOperations</code></p> <p>Example: <pre><code>public class CustomCatalog extends BaseMetastoreCatalog {\nprivate Configuration configuration;\n// must have a no-arg constructor to be dynamically loaded\n// initialize(String name, Map&lt;String, String&gt; properties) will be called to complete initialization\npublic CustomCatalog() {\n}\npublic CustomCatalog(Configuration configuration) {\nthis.configuration = configuration;\n}\n@Override\nprotected TableOperations newTableOps(TableIdentifier tableIdentifier) {\nString dbName = tableIdentifier.namespace().level(0);\nString tableName = tableIdentifier.name();\n// instantiate the CustomTableOperations\nreturn new CustomTableOperations(configuration, dbName, tableName);\n}\n@Override\nprotected String defaultWarehouseLocation(TableIdentifier tableIdentifier) {\n// Can choose to use any other configuration name\nString tableLocation = configuration.get(\"custom.iceberg.warehouse.location\");\n// Can be an s3 or hdfs path\nif (tableLocation == null) {\nthrow new RuntimeException(\"custom.iceberg.warehouse.location configuration not set!\");\n}\nreturn String.format(\n\"%s/%s.db/%s\", tableLocation,\ntableIdentifier.namespace().levels()[0],\ntableIdentifier.name());\n}\n@Override\npublic boolean dropTable(TableIdentifier identifier, boolean purge) {\n// Example service to delete table\nCustomService.deleteTable(identifier.namepsace().level(0), identifier.name());\n}\n@Override\npublic void renameTable(TableIdentifier from, TableIdentifier to) {\nPreconditions.checkArgument(from.namespace().level(0).equals(to.namespace().level(0)),\n\"Cannot move table between databases\");\n// Example service to rename table\nCustomService.renameTable(from.namepsace().level(0), from.name(), to.name());\n}\n// implement this method to read catalog name and properties during initialization\npublic void initialize(String name, Map&lt;String, String&gt; properties) {\n}\n}\n</code></pre></p> <p>Catalog implementations can be dynamically loaded in most compute engines. For Spark and Flink, you can specify the <code>catalog-impl</code> catalog property to load it. Read the Configuration section for more details. For MapReduce, implement <code>org.apache.iceberg.mr.CatalogLoader</code> and set Hadoop property <code>iceberg.mr.catalog.loader.class</code> to load it. If your catalog must read Hadoop configuration to access certain environment properties, make your catalog implement <code>org.apache.hadoop.conf.Configurable</code>.</p>"},{"location":"custom-catalog/#custom-file-io-implementation","title":"Custom file IO implementation","text":"<p>Extend <code>FileIO</code> and provide implementation to read and write data files</p> <p>Example: <pre><code>public class CustomFileIO implements FileIO {\n// must have a no-arg constructor to be dynamically loaded\n// initialize(Map&lt;String, String&gt; properties) will be called to complete initialization\npublic CustomFileIO() {\n}\n@Override\npublic InputFile newInputFile(String s) {\n// you also need to implement the InputFile interface for a custom input file\nreturn new CustomInputFile(s);\n}\n@Override\npublic OutputFile newOutputFile(String s) {\n// you also need to implement the OutputFile interface for a custom output file\nreturn new CustomOutputFile(s);\n}\n@Override\npublic void deleteFile(String path) {\nPath toDelete = new Path(path);\nFileSystem fs = Util.getFs(toDelete);\ntry {\nfs.delete(toDelete, false /* not recursive */);\n} catch (IOException e) {\nthrow new RuntimeIOException(e, \"Failed to delete file: %s\", path);\n}\n}\n// implement this method to read catalog properties during initialization\npublic void initialize(Map&lt;String, String&gt; properties) {\n}\n}\n</code></pre></p> <p>If you are already implementing your own catalog, you can implement <code>TableOperations.io()</code> to use your custom <code>FileIO</code>. In addition, custom <code>FileIO</code> implementations can also be dynamically loaded in <code>HadoopCatalog</code> and <code>HiveCatalog</code> by specifying the <code>io-impl</code> catalog property. Read the Configuration section for more details. If your <code>FileIO</code> must read Hadoop configuration to access certain environment properties, make your <code>FileIO</code> implement <code>org.apache.hadoop.conf.Configurable</code>.</p>"},{"location":"custom-catalog/#custom-location-provider-implementation","title":"Custom location provider implementation","text":"<p>Extend <code>LocationProvider</code> and provide implementation to determine the file path to write data</p> <p>Example: <pre><code>public class CustomLocationProvider implements LocationProvider {\nprivate String tableLocation;\n// must have a 2-arg constructor like this, or a no-arg constructor\npublic CustomLocationProvider(String tableLocation, Map&lt;String, String&gt; properties) {\nthis.tableLocation = tableLocation;\n}\n@Override\npublic String newDataLocation(String filename) {\n// can use any custom method to generate a file path given a file name\nreturn String.format(\"%s/%s/%s\", tableLocation, UUID.randomUUID().toString(), filename);\n}\n@Override\npublic String newDataLocation(PartitionSpec spec, StructLike partitionData, String filename) {\n// can use any custom method to generate a file path given a partition info and file name\nreturn newDataLocation(filename);\n}\n}\n</code></pre></p> <p>If you are already implementing your own catalog, you can override <code>TableOperations.locationProvider()</code> to use your custom default <code>LocationProvider</code>. To use a different custom location provider for a specific table, specify the implementation when creating the table using table property <code>write.location-provider.impl</code></p> <p>Example: <pre><code>CREATE TABLE hive.default.my_table (\nid bigint,\ndata string,\ncategory string)\nUSING iceberg\nOPTIONS (\n'write.location-provider.impl'='com.my.CustomLocationProvider'\n)\nPARTITIONED BY (category);\n</code></pre></p>"},{"location":"custom-catalog/#custom-icebergsource","title":"Custom IcebergSource","text":"<p>Extend <code>IcebergSource</code> and provide implementation to read from <code>CustomCatalog</code></p> <p>Example: <pre><code>public class CustomIcebergSource extends IcebergSource {\n@Override\nprotected Table findTable(DataSourceOptions options, Configuration conf) {\nOptional&lt;String&gt; path = options.get(\"path\");\nPreconditions.checkArgument(path.isPresent(), \"Cannot open table: path is not set\");\n// Read table from CustomCatalog\nCustomCatalog catalog = new CustomCatalog(conf);\nTableIdentifier tableIdentifier = TableIdentifier.parse(path.get());\nreturn catalog.loadTable(tableIdentifier);\n}\n}\n</code></pre></p> <p>Register the <code>CustomIcebergSource</code> by updating  <code>META-INF/services/org.apache.spark.sql.sources.DataSourceRegister</code> with its fully qualified name</p>"},{"location":"dell/","title":"Dell","text":""},{"location":"dell/#iceberg-dell-integration","title":"Iceberg Dell Integration","text":""},{"location":"dell/#dell-ecs-integration","title":"Dell ECS Integration","text":"<p>Iceberg can be used with Dell's Enterprise Object Storage (ECS) by using the ECS catalog since 0.15.0.</p> <p>See Dell ECS for more information on Dell ECS.</p>"},{"location":"dell/#parameters","title":"Parameters","text":"<p>When using Dell ECS with Iceberg, these configuration parameters are required:</p> Name Description ecs.s3.endpoint ECS S3 service endpoint ecs.s3.access-key-id ECS Username ecs.s3.secret-access-key S3 Secret Key warehouse The location of data and metadata <p>The warehouse should use the following formats:</p> Example Description ecs://bucket-a Use the whole bucket as the data ecs://bucket-a/ Use the whole bucket as the data. The last <code>/</code> is ignored. ecs://bucket-a/namespace-a Use a prefix to access the data only in this specific namespace <p>The Iceberg <code>runtime</code> jar supports different versions of Spark and Flink. You should pick the correct version.</p> <p>Even though the Dell ECS client jar is backward compatible, Dell EMC still recommends using the latest version of the client.</p>"},{"location":"dell/#spark","title":"Spark","text":"<p>To use the Dell ECS catalog with Spark 3.2.1, you should create a Spark session like:</p> <pre><code>ICEBERG_VERSION=0.15.0\nSPARK_VERSION=3.2_2.12\nECS_CLIENT_VERSION=3.3.2\n\nDEPENDENCIES=\"org.apache.iceberg:iceberg-spark-runtime-${SPARK_VERSION}:${ICEBERG_VERSION},\\\norg.apache.iceberg:iceberg-dell:${ICEBERG_VERSION},\\\ncom.emc.ecs:object-client-bundle:${ECS_CLIENT_VERSION}\"\nspark-sql --packages ${DEPENDENCIES} \\\n--conf spark.sql.extensions=org.apache.iceberg.spark.extensions.IcebergSparkSessionExtensions \\\n--conf spark.sql.catalog.my_catalog=org.apache.iceberg.spark.SparkCatalog \\\n--conf spark.sql.catalog.my_catalog.warehouse=ecs://bucket-a/namespace-a \\\n--conf spark.sql.catalog.my_catalog.catalog-impl=org.apache.iceberg.dell.ecs.EcsCatalog \\\n--conf spark.sql.catalog.my_catalog.ecs.s3.endpoint=http://10.x.x.x:9020 \\\n--conf spark.sql.catalog.my_catalog.ecs.s3.access-key-id=&lt;Your-ecs-s3-access-key&gt; \\\n--conf spark.sql.catalog.my_catalog.ecs.s3.secret-access-key=&lt;Your-ecs-s3-secret-access-key&gt;\n</code></pre> <p>Then, use <code>my_catalog</code> to access the data in ECS. You can use <code>SHOW NAMESPACES IN my_catalog</code> and <code>SHOW TABLES IN my_catalog</code> to fetch the namespaces and tables of the catalog.</p> <p>The related problems of catalog usage:</p> <ol> <li>The <code>SparkSession.catalog</code> won't access the 3rd-party catalog of Spark in both Python and Scala, so please use DDL SQL to list all tables and namespaces.</li> </ol>"},{"location":"dell/#flink","title":"Flink","text":"<p>Use the Dell ECS catalog with Flink, you first must create a Flink environment.</p> <pre><code># HADOOP_HOME is your hadoop root directory after unpack the binary package.\nexport HADOOP_CLASSPATH=`$HADOOP_HOME/bin/hadoop classpath`\n# download Iceberg dependency\nMAVEN_URL=https://repo1.maven.org/maven2\nICEBERG_VERSION=0.15.0\nFLINK_VERSION=1.14\nwget ${MAVEN_URL}/org/apache/iceberg/iceberg-flink-runtime-${FLINK_VERSION}/${ICEBERG_VERSION}/iceberg-flink-runtime-${FLINK_VERSION}-${ICEBERG_VERSION}.jar\nwget ${MAVEN_URL}/org/apache/iceberg/iceberg-dell/${ICEBERG_VERSION}/iceberg-dell-${ICEBERG_VERSION}.jar\n\n# download ECS object client\nECS_CLIENT_VERSION=3.3.2\nwget ${MAVEN_URL}/com/emc/ecs/object-client-bundle/${ECS_CLIENT_VERSION}/object-client-bundle-${ECS_CLIENT_VERSION}.jar\n\n# open the SQL client.\n/path/to/bin/sql-client.sh embedded \\\n-j iceberg-flink-runtime-${FLINK_VERSION}-${ICEBERG_VERSION}.jar \\\n-j iceberg-dell-${ICEBERG_VERSION}.jar \\\n-j object-client-bundle-${ECS_CLIENT_VERSION}.jar \\\nshell\n</code></pre> <p>Then, use Flink SQL to create a catalog named <code>my_catalog</code>:</p> <pre><code>CREATE CATALOG my_catalog WITH (\n'type'='iceberg',\n'warehouse' = 'ecs://bucket-a/namespace-a',\n'catalog-impl'='org.apache.iceberg.dell.ecs.EcsCatalog',\n'ecs.s3.endpoint' = 'http://10.x.x.x:9020',\n'ecs.s3.access-key-id' = '&lt;Your-ecs-s3-access-key&gt;',\n'ecs.s3.secret-access-key' = '&lt;Your-ecs-s3-secret-access-key&gt;')\n</code></pre> <p>Then, you can run <code>USE CATALOG my_catalog</code>, <code>SHOW DATABASES</code>, and <code>SHOW TABLES</code> to fetch the namespaces and tables of the catalog.</p>"},{"location":"dell/#limitations","title":"Limitations","text":"<p>When you use the catalog with Dell ECS only, you should care about these limitations:</p> <ol> <li><code>RENAME</code> statements are supported without other protections. When you try to rename a table, you need to guarantee all commits are finished in the original table.</li> <li><code>RENAME</code> statements only rename the table without moving any data files. This can lead to a table's data being stored in a path outside of the configured warehouse path.</li> <li>The CAS operations used by table commits are based on the checksum of the object. There is a very small probability of a checksum conflict.</li> </ol>"},{"location":"delta-lake-migration/","title":"Delta Lake Migration","text":""},{"location":"delta-lake-migration/#delta-lake-table-migration","title":"Delta Lake Table Migration","text":"<p>Delta Lake is a table format that supports Parquet file format and provides time travel and versioning features. When migrating data from Delta Lake to Iceberg, it is common to migrate all snapshots to maintain the history of the data.</p> <p>Currently, Iceberg supports the Snapshot Table action for migrating from Delta Lake to Iceberg tables. Since Delta Lake tables maintain transactions, all available transactions will be committed to the new Iceberg table as transactions in order. For Delta Lake tables, any additional data files added after the initial migration will be included in their corresponding transactions and subsequently added to the new Iceberg table using the Add Transaction action. The Add Transaction action, a variant of the Add File action, is still under development.</p>"},{"location":"delta-lake-migration/#enabling-migration-from-delta-lake-to-iceberg","title":"Enabling Migration from Delta Lake to Iceberg","text":"<p>The <code>iceberg-delta-lake</code> module is not bundled with Spark and Flink engine runtimes. To enable migration from delta lake features, the minimum required dependencies are:</p> <ul> <li>iceberg-delta-lake</li> <li>delta-standalone-0.6.0</li> <li>delta-storage-2.2.0</li> </ul>"},{"location":"delta-lake-migration/#compatibilities","title":"Compatibilities","text":"<p>The module is built and tested with <code>Delta Standalone:0.6.0</code> and supports Delta Lake tables with the following protocol version: * <code>minReaderVersion</code>: 1 * <code>minWriterVersion</code>: 2</p> <p>Please refer to Delta Lake Table Protocol Versioning for more details about Delta Lake protocol versions.</p>"},{"location":"delta-lake-migration/#api","title":"API","text":"<p>The <code>iceberg-delta-lake</code> module provides an interface named <code>DeltaLakeToIcebergMigrationActionsProvider</code>, which contains actions that helps converting from Delta Lake to Iceberg. The supported actions are: * <code>snapshotDeltaLakeTable</code>: snapshot an existing Delta Lake table to an Iceberg table</p>"},{"location":"delta-lake-migration/#default-implementation","title":"Default Implementation","text":"<p>The <code>iceberg-delta-lake</code> module also provides a default implementation of the interface which can be accessed by <pre><code>DeltaLakeToIcebergMigrationActionsProvider defaultActions = DeltaLakeToIcebergMigrationActionsProvider.defaultActions()\n</code></pre></p>"},{"location":"delta-lake-migration/#snapshot-delta-lake-table-to-iceberg","title":"Snapshot Delta Lake Table to Iceberg","text":"<p>The action <code>snapshotDeltaLakeTable</code> reads the Delta Lake table's transactions and converts them to a new Iceberg table with the same schema and partitioning in one iceberg transaction. The original Delta Lake table remains unchanged.</p> <p>The newly created table can be changed or written to without affecting the source table, but the snapshot uses the original table's data files. Existing data files are added to the Iceberg table's metadata and can be read using a name-to-id mapping created from the original table schema.</p> <p>When inserts or overwrites run on the snapshot, new files are placed in the snapshot table's location. The location is default to be the same as that of the source Delta Lake Table. Users can also specify a different location for the snapshot table.</p> <p>Info</p> <p>Because tables created by <code>snapshotDeltaLakeTable</code> are not the sole owners of their data files, they are prohibited from actions like <code>expire_snapshots</code> which would physically delete data files. Iceberg deletes, which only effect metadata, are still allowed. In addition, any operations which affect the original data files will disrupt the Snapshot's integrity. DELETE statements executed against the original Delta Lake table will remove original data files and the <code>snapshotDeltaLakeTable</code> table will no longer be able to access them.</p>"},{"location":"delta-lake-migration/#usage","title":"Usage","text":"Required Input Configured By Description Source Table Location Argument <code>sourceTableLocation</code> The location of the source Delta Lake table New Iceberg Table Identifier Configuration API <code>as</code> The identifier specifies the namespace and table name for the new iceberg table Iceberg Catalog Configuration API <code>icebergCatalog</code> The catalog used to create the new iceberg table Hadoop Configuration Configuration API <code>deltaLakeConfiguration</code> The Hadoop Configuration used to read the source Delta Lake table. <p>For detailed usage and other optional configurations, please refer to the SnapshotDeltaLakeTable API</p>"},{"location":"delta-lake-migration/#output","title":"Output","text":"Output Name Type Description <code>imported_files_count</code> long Number of files added to the new table"},{"location":"delta-lake-migration/#added-table-properties","title":"Added Table Properties","text":"<p>The following table properties are added to the Iceberg table to be created by default:</p> Property Name Value Description <code>snapshot_source</code> <code>delta</code> Indicates that the table is snapshot from a delta lake table <code>original_location</code> location of the delta lake table The absolute path to the location of the original delta lake table <code>schema.name-mapping.default</code> JSON name mapping derived from the schema The name mapping string used to read Delta Lake table's data files"},{"location":"delta-lake-migration/#examples","title":"Examples","text":"<pre><code>import org.apache.iceberg.catalog.TableIdentifier;\nimport org.apache.iceberg.catalog.Catalog;\nimport org.apache.hadoop.conf.Configuration;\nimport org.apache.iceberg.delta.DeltaLakeToIcebergMigrationActionsProvider;\nString sourceDeltaLakeTableLocation = \"s3://my-bucket/delta-table\";\nString destTableLocation = \"s3://my-bucket/iceberg-table\";\nTableIdentifier destTableIdentifier = TableIdentifier.of(\"my_db\", \"my_table\");\nCatalog icebergCatalog = ...; // Iceberg Catalog fetched from engines like Spark or created via CatalogUtil.loadCatalog\nConfiguration hadoopConf = ...; // Hadoop Configuration fetched from engines like Spark and have proper file system configuration to access the Delta Lake table.\nDeltaLakeToIcebergMigrationActionsProvider.defaultActions()\n.snapshotDeltaLakeTable(sourceDeltaLakeTableLocation)\n.as(destTableIdentifier)\n.icebergCatalog(icebergCatalog)\n.tableLocation(destTableLocation)\n.deltaLakeConfiguration(hadoopConf)\n.tableProperty(\"my_property\", \"my_value\")\n.execute();\n</code></pre>"},{"location":"evolution/","title":"Evolution","text":""},{"location":"evolution/#evolution","title":"Evolution","text":"<p>Iceberg supports in-place table evolution. You can evolve a table schema just like SQL -- even in nested structures -- or change partition layout when data volume changes. Iceberg does not require costly distractions, like rewriting table data or migrating to a new table.</p> <p>For example, Hive table partitioning cannot change so moving from a daily partition layout to an hourly partition layout requires a new table. And because queries are dependent on partitions, queries must be rewritten for the new table. In some cases, even changes as simple as renaming a column are either not supported, or can cause data correctness problems.</p>"},{"location":"evolution/#schema-evolution","title":"Schema evolution","text":"<p>Iceberg supports the following schema evolution changes:</p> <ul> <li>Add -- add a new column to the table or to a nested struct</li> <li>Drop -- remove an existing column from the table or a nested struct</li> <li>Rename -- rename an existing column or field in a nested struct</li> <li>Update -- widen the type of a column, struct field, map key, map value, or list element</li> <li>Reorder -- change the order of columns or fields in a nested struct</li> </ul> <p>Iceberg schema updates are metadata changes, so no data files need to be rewritten to perform the update.</p> <p>Note that map keys do not support adding or dropping struct fields that would change equality.</p>"},{"location":"evolution/#correctness","title":"Correctness","text":"<p>Iceberg guarantees that schema evolution changes are independent and free of side-effects, without rewriting files:</p> <ol> <li>Added columns never read existing values from another column.</li> <li>Dropping a column or field does not change the values in any other column.</li> <li>Updating a column or field does not change values in any other column.</li> <li>Changing the order of columns or fields in a struct does not change the values associated with a column or field name.</li> </ol> <p>Iceberg uses unique IDs to track each column in a table. When you add a column, it is assigned a new ID so existing data is never used by mistake.</p> <ul> <li>Formats that track columns by name can inadvertently un-delete a column if a name is reused, which violates #1.</li> <li>Formats that track columns by position cannot delete columns without changing the names that are used for each column, which violates #2.</li> </ul>"},{"location":"evolution/#partition-evolution","title":"Partition evolution","text":"<p>Iceberg table partitioning can be updated in an existing table because queries do not reference partition values directly.</p> <p>When you evolve a partition spec, the old data written with an earlier spec remains unchanged. New data is written using the new spec in a new layout. Metadata for each of the partition versions is kept separately. Because of this, when you start writing queries, you get split planning. This is where each partition layout plans files separately using the filter it derives for that specific partition layout. Here's a visual representation of a contrived example: </p> <p> The data for 2008 is partitioned by month. Starting from 2009 the table is updated so that the data is instead partitioned by day. Both partitioning layouts are able to coexist in the same table.</p> <p>Iceberg uses hidden partitioning, so you don't need to write queries for a specific partition layout to be fast. Instead, you can write queries that select the data you need, and Iceberg automatically prunes out files that don't contain matching data.</p> <p>Partition evolution is a metadata operation and does not eagerly rewrite files.</p> <p>Iceberg's Java table API provides <code>updateSpec</code> API to update partition spec.  For example, the following code could be used to update the partition spec to add a new partition field that places <code>id</code> column values into 8 buckets and remove an existing partition field <code>category</code>:</p> <pre><code>Table sampleTable = ...;\nsampleTable.updateSpec()\n.addField(bucket(\"id\", 8))\n.removeField(\"category\")\n.commit();\n</code></pre> <p>Spark supports updating partition spec through its <code>ALTER TABLE</code> SQL statement, see more details in Spark SQL.</p>"},{"location":"evolution/#sort-order-evolution","title":"Sort order evolution","text":"<p>Similar to partition spec, Iceberg sort order can also be updated in an existing table. When you evolve a sort order, the old data written with an earlier order remains unchanged. Engines can always choose to write data in the latest sort order or unsorted when sorting is prohibitively expensive.</p> <p>Iceberg's Java table API provides <code>replaceSortOrder</code> API to update sort order.  For example, the following code could be used to create a new sort order  with <code>id</code> column sorted in ascending order with nulls last, and <code>category</code> column sorted in descending order with nulls first:</p> <pre><code>Table sampleTable = ...;\nsampleTable.replaceSortOrder()\n.asc(\"id\", NullOrder.NULLS_LAST)\n.dec(\"category\", NullOrder.NULL_FIRST)\n.commit();\n</code></pre> <p>Spark supports updating sort order through its <code>ALTER TABLE</code> SQL statement, see more details in Spark SQL.</p>"},{"location":"flink-actions/","title":"Flink Actions","text":""},{"location":"flink-actions/#rewrite-files-action","title":"Rewrite files action.","text":"<p>Iceberg provides API to rewrite small files into large files by submitting Flink batch jobs. The behavior of this Flink action is the same as Spark's rewriteDataFiles.</p> <pre><code>import org.apache.iceberg.flink.actions.Actions;\nTableLoader tableLoader = TableLoader.fromHadoopTable(\"hdfs://nn:8020/warehouse/path\");\nTable table = tableLoader.loadTable();\nRewriteDataFilesActionResult result = Actions.forTable(table)\n.rewriteDataFiles()\n.execute();\n</code></pre> <p>For more details of the rewrite files action, please refer to RewriteDataFilesAction</p>"},{"location":"flink-configuration/","title":"Flink Configuration","text":""},{"location":"flink-configuration/#flink-configuration","title":"Flink Configuration","text":""},{"location":"flink-configuration/#catalog-configuration","title":"Catalog Configuration","text":"<p>A catalog is created and named by executing the following query (replace <code>&lt;catalog_name&gt;</code> with your catalog name and <code>&lt;config_key&gt;</code>=<code>&lt;config_value&gt;</code> with catalog implementation config):</p> <pre><code>CREATE CATALOG &lt;catalog_name&gt; WITH (\n'type'='iceberg',\n`&lt;config_key&gt;`=`&lt;config_value&gt;`\n); </code></pre> <p>The following properties can be set globally and are not limited to a specific catalog implementation:</p> Property Required Values Description type \u2714\ufe0f iceberg Must be <code>iceberg</code>. catalog-type <code>hive</code>, <code>hadoop</code> or <code>rest</code> <code>hive</code>, <code>hadoop</code> or <code>rest</code> for built-in catalogs, or left unset for custom catalog implementations using catalog-impl. catalog-impl The fully-qualified class name of a custom catalog implementation. Must be set if <code>catalog-type</code> is unset. property-version Version number to describe the property version. This property can be used for backwards compatibility in case the property format changes. The current property version is <code>1</code>. cache-enabled <code>true</code> or <code>false</code> Whether to enable catalog cache, default value is <code>true</code>. cache.expiration-interval-ms How long catalog entries are locally cached, in milliseconds; negative values like <code>-1</code> will disable expiration, value 0 is not allowed to set. default value is <code>-1</code>. <p>The following properties can be set if using the Hive catalog:</p> Property Required Values Description uri \u2714\ufe0f The Hive metastore's thrift URI. clients The Hive metastore client pool size, default value is 2. warehouse The Hive warehouse location, users should specify this path if neither set the <code>hive-conf-dir</code> to specify a location containing a <code>hive-site.xml</code> configuration file nor add a correct <code>hive-site.xml</code> to classpath. hive-conf-dir Path to a directory containing a <code>hive-site.xml</code> configuration file which will be used to provide custom Hive configuration values. The value of <code>hive.metastore.warehouse.dir</code> from <code>&lt;hive-conf-dir&gt;/hive-site.xml</code> (or hive configure file from classpath) will be overwritten with the <code>warehouse</code> value if setting both <code>hive-conf-dir</code> and <code>warehouse</code> when creating iceberg catalog. hadoop-conf-dir Path to a directory containing <code>core-site.xml</code> and <code>hdfs-site.xml</code> configuration files which will be used to provide custom Hadoop configuration values. <p>The following properties can be set if using the Hadoop catalog:</p> Property Required Values Description warehouse \u2714\ufe0f The HDFS directory to store metadata files and data files. <p>The following properties can be set if using the REST catalog:</p> Property Required Values Description uri \u2714\ufe0f The URL to the REST Catalog. credential A credential to exchange for a token in the OAuth2 client credentials flow. token A token which will be used to interact with the server."},{"location":"flink-configuration/#runtime-configuration","title":"Runtime configuration","text":""},{"location":"flink-configuration/#read-options","title":"Read options","text":"<p>Flink read options are passed when configuring the Flink IcebergSource:</p> <pre><code>IcebergSource.forRowData()\n    .tableLoader(TableLoader.fromCatalog(...))\n    .assignerFactory(new SimpleSplitAssignerFactory())\n    .streaming(true)\n    .streamingStartingStrategy(StreamingStartingStrategy.INCREMENTAL_FROM_LATEST_SNAPSHOT)\n    .startSnapshotId(3821550127947089987L)\n    .monitorInterval(Duration.ofMillis(10L)) // or .set(\"monitor-interval\", \"10s\") \\ set(FlinkReadOptions.MONITOR_INTERVAL, \"10s\")\n    .build()\n</code></pre> <p>For Flink SQL, read options can be passed in via SQL hints like this:</p> <pre><code>SELECT * FROM tableName /*+ OPTIONS('monitor-interval'='10s') */\n...\n</code></pre> <p>Options can be passed in via Flink configuration, which will be applied to current session. Note that not all options support this mode.</p> <pre><code>env.getConfig()\n    .getConfiguration()\n    .set(FlinkReadOptions.SPLIT_FILE_OPEN_COST_OPTION, 1000L);\n...\n</code></pre> <p><code>Read option</code> has the highest priority, followed by <code>Flink configuration</code> and then <code>Table property</code>.</p> Read option Flink configuration Table property Default Description snapshot-id N/A N/A null For time travel in batch mode. Read data from the specified snapshot-id. case-sensitive connector.iceberg.case-sensitive N/A false If true, match column name in a case sensitive way. as-of-timestamp N/A N/A null For time travel in batch mode. Read data from the most recent snapshot as of the given time in milliseconds. starting-strategy connector.iceberg.starting-strategy N/A INCREMENTAL_FROM_LATEST_SNAPSHOT Starting strategy for streaming execution. TABLE_SCAN_THEN_INCREMENTAL: Do a regular table scan then switch to the incremental mode. The incremental mode starts from the current snapshot exclusive. INCREMENTAL_FROM_LATEST_SNAPSHOT: Start incremental mode from the latest snapshot inclusive. If it is an empty map, all future append snapshots should be discovered. INCREMENTAL_FROM_EARLIEST_SNAPSHOT: Start incremental mode from the earliest snapshot inclusive. If it is an empty map, all future append snapshots should be discovered. INCREMENTAL_FROM_SNAPSHOT_ID: Start incremental mode from a snapshot with a specific id inclusive. INCREMENTAL_FROM_SNAPSHOT_TIMESTAMP: Start incremental mode from a snapshot with a specific timestamp inclusive. If the timestamp is between two snapshots, it should start from the snapshot after the timestamp. Just for FIP27 Source. start-snapshot-timestamp N/A N/A null Start to read data from the most recent snapshot as of the given time in milliseconds. start-snapshot-id N/A N/A null Start to read data from the specified snapshot-id. end-snapshot-id N/A N/A The latest snapshot id Specifies the end snapshot. branch N/A N/A main Specifies the branch to read from in batch mode tag N/A N/A null Specifies the tag to read from in batch mode start-tag N/A N/A null Specifies the starting tag to read from for incremental reads end-tag N/A N/A null Specifies the ending tag to to read from for incremental reads split-size connector.iceberg.split-size read.split.target-size 128 MB Target size when combining input splits. split-lookback connector.iceberg.split-file-open-cost read.split.planning-lookback 10 Number of bins to consider when combining input splits. split-file-open-cost connector.iceberg.split-file-open-cost read.split.open-file-cost 4MB The estimated cost to open a file, used as a minimum weight when combining splits. streaming connector.iceberg.streaming N/A false Sets whether the current task runs in streaming or batch mode. monitor-interval connector.iceberg.monitor-interval N/A 60s Monitor interval to discover splits from new snapshots. Applicable only for streaming read. include-column-stats connector.iceberg.include-column-stats N/A false Create a new scan from this that loads the column stats with each data file. Column stats include: value count, null value count, lower bounds, and upper bounds. max-planning-snapshot-count connector.iceberg.max-planning-snapshot-count N/A Integer.MAX_VALUE Max number of snapshots limited per split enumeration. Applicable only to streaming read. limit connector.iceberg.limit N/A -1 Limited output number of rows."},{"location":"flink-configuration/#write-options","title":"Write options","text":"<p>Flink write options are passed when configuring the FlinkSink, like this:</p> <pre><code>FlinkSink.Builder builder = FlinkSink.forRow(dataStream, SimpleDataUtil.FLINK_SCHEMA)\n    .table(table)\n    .tableLoader(tableLoader)\n    .set(\"write-format\", \"orc\")\n    .set(FlinkWriteOptions.OVERWRITE_MODE, \"true\");\n</code></pre> <p>For Flink SQL, write options can be passed in via SQL hints like this:</p> <pre><code>INSERT INTO tableName /*+ OPTIONS('upsert-enabled'='true') */\n...\n</code></pre> Flink option Default Description write-format Table write.format.default File format to use for this write operation; parquet, avro, or orc target-file-size-bytes As per table property Overrides this table's write.target-file-size-bytes upsert-enabled Table write.upsert.enabled Overrides this table's write.upsert.enabled overwrite-enabled false Overwrite the table's data, overwrite mode shouldn't be enable when configuring to use UPSERT data stream. distribution-mode Table write.distribution-mode Overrides this table's write.distribution-mode compression-codec Table write.(fileformat).compression-codec Overrides this table's compression codec for this write compression-level Table write.(fileformat).compression-level Overrides this table's compression level for Parquet and Avro tables for this write compression-strategy Table write.orc.compression-strategy Overrides this table's compression strategy for ORC tables for this write write-parallelism Upstream operator parallelism Overrides the writer parallelism"},{"location":"flink-connector/","title":"Flink Connector","text":""},{"location":"flink-connector/#flink-connector","title":"Flink Connector","text":"<p>Apache Flink supports creating Iceberg table directly without creating the explicit Flink catalog in Flink SQL. That means we can just create an iceberg table by specifying <code>'connector'='iceberg'</code> table option in Flink SQL which is similar to usage in the Flink official document.</p> <p>In Flink, the SQL <code>CREATE TABLE test (..) WITH ('connector'='iceberg', ...)</code> will create a Flink table in current Flink catalog (use GenericInMemoryCatalog by default), which is just mapping to the underlying iceberg table instead of maintaining iceberg table directly in current Flink catalog.</p> <p>To create the table in Flink SQL by using SQL syntax <code>CREATE TABLE test (..) WITH ('connector'='iceberg', ...)</code>,  Flink iceberg connector provides the following table properties:</p> <ul> <li><code>connector</code>: Use the constant <code>iceberg</code>.</li> <li><code>catalog-name</code>: User-specified catalog name. It's required because the connector don't have any default value.</li> <li><code>catalog-type</code>: <code>hive</code> or <code>hadoop</code> for built-in catalogs (defaults to <code>hive</code>), or left unset for custom catalog implementations using <code>catalog-impl</code>.</li> <li><code>catalog-impl</code>: The fully-qualified class name of a custom catalog implementation. Must be set if <code>catalog-type</code> is unset. See also custom catalog for more details.</li> <li><code>catalog-database</code>: The iceberg database name in the backend catalog, use the current flink database name by default.</li> <li><code>catalog-table</code>: The iceberg table name in the backend catalog. Default to use the table name in the flink <code>CREATE TABLE</code> sentence.</li> </ul>"},{"location":"flink-connector/#table-managed-in-hive-catalog","title":"Table managed in Hive catalog.","text":"<p>Before executing the following SQL, please make sure you've configured the Flink SQL client correctly according to the quick start documentation.</p> <p>The following SQL will create a Flink table in the current Flink catalog, which maps to the iceberg table <code>default_database.flink_table</code> managed in iceberg catalog.</p> <pre><code>CREATE TABLE flink_table (\nid   BIGINT,\ndata STRING\n) WITH (\n'connector'='iceberg',\n'catalog-name'='hive_prod',\n'uri'='thrift://localhost:9083',\n'warehouse'='hdfs://nn:8020/path/to/warehouse'\n);\n</code></pre> <p>If you want to create a Flink table mapping to a different iceberg table managed in Hive catalog (such as <code>hive_db.hive_iceberg_table</code> in Hive), then you can create Flink table as following:</p> <pre><code>CREATE TABLE flink_table (\nid   BIGINT,\ndata STRING\n) WITH (\n'connector'='iceberg',\n'catalog-name'='hive_prod',\n'catalog-database'='hive_db',\n'catalog-table'='hive_iceberg_table',\n'uri'='thrift://localhost:9083',\n'warehouse'='hdfs://nn:8020/path/to/warehouse'\n);\n</code></pre> <p>Info</p> <p>The underlying catalog database (<code>hive_db</code> in the above example) will be created automatically if it does not exist when writing records into the Flink table.</p>"},{"location":"flink-connector/#table-managed-in-hadoop-catalog","title":"Table managed in hadoop catalog","text":"<p>The following SQL will create a Flink table in current Flink catalog, which maps to the iceberg table <code>default_database.flink_table</code> managed in hadoop catalog.</p> <pre><code>CREATE TABLE flink_table (\nid   BIGINT,\ndata STRING\n) WITH (\n'connector'='iceberg',\n'catalog-name'='hadoop_prod',\n'catalog-type'='hadoop',\n'warehouse'='hdfs://nn:8020/path/to/warehouse'\n);\n</code></pre>"},{"location":"flink-connector/#table-managed-in-custom-catalog","title":"Table managed in custom catalog","text":"<p>The following SQL will create a Flink table in current Flink catalog, which maps to the iceberg table <code>default_database.flink_table</code> managed in a custom catalog of type <code>com.my.custom.CatalogImpl</code>.</p> <pre><code>CREATE TABLE flink_table (\nid   BIGINT,\ndata STRING\n) WITH (\n'connector'='iceberg',\n'catalog-name'='custom_prod',\n'catalog-impl'='com.my.custom.CatalogImpl',\n-- More table properties for the customized catalog\n'my-additional-catalog-config'='my-value',\n...\n);\n</code></pre> <p>Please check sections under the Integrations tab for all custom catalogs.</p>"},{"location":"flink-connector/#a-complete-example","title":"A complete example.","text":"<p>Take the Hive catalog as an example:</p> <pre><code>CREATE TABLE flink_table (\nid   BIGINT,\ndata STRING\n) WITH (\n'connector'='iceberg',\n'catalog-name'='hive_prod',\n'uri'='thrift://localhost:9083',\n'warehouse'='file:///path/to/warehouse'\n);\nINSERT INTO flink_table VALUES (1, 'AAA'), (2, 'BBB'), (3, 'CCC');\nSET execution.result-mode=tableau;\nSELECT * FROM flink_table;\n+----+------+\n| id | data |\n+----+------+\n|  1 |  AAA |\n|  2 |  BBB |\n|  3 |  CCC |\n+----+------+\n3 rows in set\n</code></pre> <p>For more details, please refer to the Iceberg Flink documentation.</p>"},{"location":"flink-ddl/","title":"Flink DDL","text":""},{"location":"flink-ddl/#ddl-commands","title":"DDL commands","text":""},{"location":"flink-ddl/#create-catalog","title":"<code>CREATE Catalog</code>","text":""},{"location":"flink-ddl/#hive-catalog","title":"Hive catalog","text":"<p>This creates an Iceberg catalog named <code>hive_catalog</code> that can be configured using <code>'catalog-type'='hive'</code>, which loads tables from Hive metastore:</p> <pre><code>CREATE CATALOG hive_catalog WITH (\n'type'='iceberg',\n'catalog-type'='hive',\n'uri'='thrift://localhost:9083',\n'clients'='5',\n'property-version'='1',\n'warehouse'='hdfs://nn:8020/warehouse/path'\n);\n</code></pre> <p>The following properties can be set if using the Hive catalog:</p> <ul> <li><code>uri</code>: The Hive metastore's thrift URI. (Required)</li> <li><code>clients</code>: The Hive metastore client pool size, default value is 2. (Optional)</li> <li><code>warehouse</code>: The Hive warehouse location, users should specify this path if neither set the <code>hive-conf-dir</code> to specify a location containing a <code>hive-site.xml</code> configuration file nor add a correct <code>hive-site.xml</code> to classpath.</li> <li><code>hive-conf-dir</code>: Path to a directory containing a <code>hive-site.xml</code> configuration file which will be used to provide custom Hive configuration values. The value of <code>hive.metastore.warehouse.dir</code> from <code>&lt;hive-conf-dir&gt;/hive-site.xml</code> (or hive configure file from classpath) will be overwritten with the <code>warehouse</code> value if setting both <code>hive-conf-dir</code> and <code>warehouse</code> when creating iceberg catalog.</li> <li><code>hadoop-conf-dir</code>: Path to a directory containing <code>core-site.xml</code> and <code>hdfs-site.xml</code> configuration files which will be used to provide custom Hadoop configuration values.</li> </ul>"},{"location":"flink-ddl/#hadoop-catalog","title":"Hadoop catalog","text":"<p>Iceberg also supports a directory-based catalog in HDFS that can be configured using <code>'catalog-type'='hadoop'</code>:</p> <pre><code>CREATE CATALOG hadoop_catalog WITH (\n'type'='iceberg',\n'catalog-type'='hadoop',\n'warehouse'='hdfs://nn:8020/warehouse/path',\n'property-version'='1'\n);\n</code></pre> <p>The following properties can be set if using the Hadoop catalog:</p> <ul> <li><code>warehouse</code>: The HDFS directory to store metadata files and data files. (Required)</li> </ul> <p>Execute the sql command <code>USE CATALOG hadoop_catalog</code> to set the current catalog.</p>"},{"location":"flink-ddl/#rest-catalog","title":"REST catalog","text":"<p>This creates an iceberg catalog named <code>rest_catalog</code> that can be configured using <code>'catalog-type'='rest'</code>, which loads tables from a REST catalog:</p> <pre><code>CREATE CATALOG rest_catalog WITH (\n'type'='iceberg',\n'catalog-type'='rest',\n'uri'='https://localhost/'\n);\n</code></pre> <p>The following properties can be set if using the REST catalog:</p> <ul> <li><code>uri</code>: The URL to the REST Catalog (Required)</li> <li><code>credential</code>: A credential to exchange for a token in the OAuth2 client credentials flow (Optional)</li> <li><code>token</code>: A token which will be used to interact with the server (Optional)</li> </ul>"},{"location":"flink-ddl/#custom-catalog","title":"Custom catalog","text":"<p>Flink also supports loading a custom Iceberg <code>Catalog</code> implementation by specifying the <code>catalog-impl</code> property:</p> <pre><code>CREATE CATALOG my_catalog WITH (\n'type'='iceberg',\n'catalog-impl'='com.my.custom.CatalogImpl',\n'my-additional-catalog-config'='my-value'\n);\n</code></pre>"},{"location":"flink-ddl/#create-through-yaml-config","title":"Create through YAML config","text":"<p>Catalogs can be registered in <code>sql-client-defaults.yaml</code> before starting the SQL client.</p> <pre><code>catalogs: - name: my_catalog\ntype: iceberg\ncatalog-type: hadoop\nwarehouse: hdfs://nn:8020/warehouse/path\n</code></pre>"},{"location":"flink-ddl/#create-through-sql-files","title":"Create through SQL Files","text":"<p>The Flink SQL Client supports the <code>-i</code> startup option to execute an initialization SQL file to set up environment when starting up the SQL Client.</p> <pre><code>-- define available catalogs\nCREATE CATALOG hive_catalog WITH (\n'type'='iceberg',\n'catalog-type'='hive',\n'uri'='thrift://localhost:9083',\n'warehouse'='hdfs://nn:8020/warehouse/path'\n);\nUSE CATALOG hive_catalog;\n</code></pre> <p>Using <code>-i &lt;init.sql&gt;</code> option to initialize SQL Client session:</p> <pre><code>/path/to/bin/sql-client.sh -i /path/to/init.sql\n</code></pre>"},{"location":"flink-ddl/#create-database","title":"<code>CREATE DATABASE</code>","text":"<p>By default, Iceberg will use the <code>default</code> database in Flink. Using the following example to create a separate database in order to avoid creating tables under the <code>default</code> database:</p> <pre><code>CREATE DATABASE iceberg_db;\nUSE iceberg_db;\n</code></pre>"},{"location":"flink-ddl/#create-table","title":"<code>CREATE TABLE</code>","text":"<pre><code>CREATE TABLE `hive_catalog`.`default`.`sample` (\nid BIGINT COMMENT 'unique id',\ndata STRING\n);\n</code></pre> <p>Table create commands support the commonly used Flink create clauses including:</p> <ul> <li><code>PARTITION BY (column1, column2, ...)</code> to configure partitioning, Flink does not yet support hidden partitioning.</li> <li><code>COMMENT 'table document'</code> to set a table description.</li> <li><code>WITH ('key'='value', ...)</code> to set table configuration which will be stored in Iceberg table properties.</li> </ul> <p>Currently, it does not support computed column, primary key and watermark definition etc.</p>"},{"location":"flink-ddl/#partitioned-by","title":"<code>PARTITIONED BY</code>","text":"<p>To create a partition table, use <code>PARTITIONED BY</code>:</p> <pre><code>CREATE TABLE `hive_catalog`.`default`.`sample` (\nid BIGINT COMMENT 'unique id',\ndata STRING\n) PARTITIONED BY (data);\n</code></pre> <p>Iceberg support hidden partition but Flink don't support partitioning by a function on columns, so there is no way to support hidden partition in Flink DDL.</p>"},{"location":"flink-ddl/#create-table-like","title":"<code>CREATE TABLE LIKE</code>","text":"<p>To create a table with the same schema, partitioning, and table properties as another table, use <code>CREATE TABLE LIKE</code>.</p> <pre><code>CREATE TABLE `hive_catalog`.`default`.`sample` (\nid BIGINT COMMENT 'unique id',\ndata STRING\n);\nCREATE TABLE  `hive_catalog`.`default`.`sample_like` LIKE `hive_catalog`.`default`.`sample`;\n</code></pre> <p>For more details, refer to the Flink <code>CREATE TABLE</code> documentation.</p>"},{"location":"flink-ddl/#alter-table","title":"<code>ALTER TABLE</code>","text":"<p>Iceberg only support altering table properties:</p> <pre><code>ALTER TABLE `hive_catalog`.`default`.`sample` SET ('write.format.default'='avro')\n</code></pre>"},{"location":"flink-ddl/#alter-table-rename-to","title":"<code>ALTER TABLE .. RENAME TO</code>","text":"<pre><code>ALTER TABLE `hive_catalog`.`default`.`sample` RENAME TO `hive_catalog`.`default`.`new_sample`;\n</code></pre>"},{"location":"flink-ddl/#drop-table","title":"<code>DROP TABLE</code>","text":"<p>To delete a table, run:</p> <pre><code>DROP TABLE `hive_catalog`.`default`.`sample`;\n</code></pre>"},{"location":"flink-queries/","title":"Flink Queries","text":""},{"location":"flink-queries/#flink-queries","title":"Flink Queries","text":"<p>Iceberg support streaming and batch read With Apache Flink's DataStream API and Table API.</p>"},{"location":"flink-queries/#reading-with-sql","title":"Reading with SQL","text":"<p>Iceberg support both streaming and batch read in Flink. Execute the following sql command to switch execution mode from <code>streaming</code> to <code>batch</code>, and vice versa:</p> <pre><code>-- Execute the flink job in streaming mode for current session context\nSET execution.runtime-mode = streaming;\n-- Execute the flink job in batch mode for current session context\nSET execution.runtime-mode = batch;\n</code></pre>"},{"location":"flink-queries/#flink-batch-read","title":"Flink batch read","text":"<p>Submit a Flink batch job using the following sentences:</p> <pre><code>-- Execute the flink job in batch mode for current session context\nSET execution.runtime-mode = batch;\nSELECT * FROM sample;\n</code></pre>"},{"location":"flink-queries/#flink-streaming-read","title":"Flink streaming read","text":"<p>Iceberg supports processing incremental data in Flink streaming jobs which starts from a historical snapshot-id:</p> <pre><code>-- Submit the flink job in streaming mode for current session.\nSET execution.runtime-mode = streaming;\n-- Enable this switch because streaming read SQL will provide few job options in flink SQL hint options.\nSET table.dynamic-table-options.enabled=true;\n-- Read all the records from the iceberg current snapshot, and then read incremental data starting from that snapshot.\nSELECT * FROM sample /*+ OPTIONS('streaming'='true', 'monitor-interval'='1s')*/ ;\n-- Read all incremental data starting from the snapshot-id '3821550127947089987' (records from this snapshot will be excluded).\nSELECT * FROM sample /*+ OPTIONS('streaming'='true', 'monitor-interval'='1s', 'start-snapshot-id'='3821550127947089987')*/ ;\n</code></pre> <p>There are some options that could be set in Flink SQL hint options for streaming job, see read options for details.</p>"},{"location":"flink-queries/#flip-27-source-for-sql","title":"FLIP-27 source for SQL","text":"<p>Here are the SQL settings for the FLIP-27 source. All other SQL settings and options documented above are applicable to the FLIP-27 source.</p> <pre><code>-- Opt in the FLIP-27 source. Default is false.\nSET table.exec.iceberg.use-flip27-source = true;\n</code></pre>"},{"location":"flink-queries/#reading-branches-and-tags-with-sql","title":"Reading branches and tags with SQL","text":"<p>Branch and tags can be read via SQL by specifying options. For more details refer to Flink Configuration</p> <pre><code>--- Read from branch b1\nSELECT * FROM table /*+ OPTIONS('branch'='b1') */ ;\n--- Read from tag t1\nSELECT * FROM table /*+ OPTIONS('tag'='t1') */;\n--- Incremental scan from tag t1 to tag t2\nSELECT * FROM table /*+ OPTIONS('streaming'='true', 'monitor-interval'='1s', 'start-tag'='t1', 'end-tag'='t2') */;\n</code></pre>"},{"location":"flink-queries/#reading-with-datastream","title":"Reading with DataStream","text":"<p>Iceberg support streaming or batch read in Java API now.</p>"},{"location":"flink-queries/#batch-read","title":"Batch Read","text":"<p>This example will read all records from iceberg table and then print to the stdout console in flink batch job:</p> <pre><code>StreamExecutionEnvironment env = StreamExecutionEnvironment.createLocalEnvironment();\nTableLoader tableLoader = TableLoader.fromHadoopTable(\"hdfs://nn:8020/warehouse/path\");\nDataStream&lt;RowData&gt; batch = FlinkSource.forRowData()\n.env(env)\n.tableLoader(tableLoader)\n.streaming(false)\n.build();\n// Print all records to stdout.\nbatch.print();\n// Submit and execute this batch read job.\nenv.execute(\"Test Iceberg Batch Read\");\n</code></pre>"},{"location":"flink-queries/#streaming-read","title":"Streaming read","text":"<p>This example will read incremental records which start from snapshot-id '3821550127947089987' and print to stdout console in flink streaming job:</p> <pre><code>StreamExecutionEnvironment env = StreamExecutionEnvironment.createLocalEnvironment();\nTableLoader tableLoader = TableLoader.fromHadoopTable(\"hdfs://nn:8020/warehouse/path\");\nDataStream&lt;RowData&gt; stream = FlinkSource.forRowData()\n.env(env)\n.tableLoader(tableLoader)\n.streaming(true)\n.startSnapshotId(3821550127947089987L)\n.build();\n// Print all records to stdout.\nstream.print();\n// Submit and execute this streaming read job.\nenv.execute(\"Test Iceberg Streaming Read\");\n</code></pre> <p>There are other options that can be set, please see the FlinkSource#Builder.</p>"},{"location":"flink-queries/#reading-with-datastream-flip-27-source","title":"Reading with DataStream (FLIP-27 source)","text":"<p>FLIP-27 source interface was introduced in Flink 1.12. It aims to solve several shortcomings of the old <code>SourceFunction</code> streaming source interface. It also unifies the source interfaces for both batch and streaming executions. Most source connectors (like Kafka, file) in Flink repo have  migrated to the FLIP-27 interface. Flink is planning to deprecate the old <code>SourceFunction</code> interface in the near future.</p> <p>A FLIP-27 based Flink <code>IcebergSource</code> is added in <code>iceberg-flink</code> module. The FLIP-27 <code>IcebergSource</code> is currently an experimental feature.</p>"},{"location":"flink-queries/#batch-read_1","title":"Batch Read","text":"<p>This example will read all records from iceberg table and then print to the stdout console in flink batch job:</p> <pre><code>StreamExecutionEnvironment env = StreamExecutionEnvironment.createLocalEnvironment();\nTableLoader tableLoader = TableLoader.fromHadoopTable(\"hdfs://nn:8020/warehouse/path\");\nIcebergSource&lt;RowData&gt; source = IcebergSource.forRowData()\n.tableLoader(tableLoader)\n.assignerFactory(new SimpleSplitAssignerFactory())\n.build();\nDataStream&lt;RowData&gt; batch = env.fromSource(\nsource,\nWatermarkStrategy.noWatermarks(),\n\"My Iceberg Source\",\nTypeInformation.of(RowData.class));\n// Print all records to stdout.\nbatch.print();\n// Submit and execute this batch read job.\nenv.execute(\"Test Iceberg Batch Read\");\n</code></pre>"},{"location":"flink-queries/#streaming-read_1","title":"Streaming read","text":"<p>This example will start the streaming read from the latest table snapshot (inclusive). Every 60s, it polls Iceberg table to discover new append-only snapshots. CDC read is not supported yet.</p> <pre><code>StreamExecutionEnvironment env = StreamExecutionEnvironment.createLocalEnvironment();\nTableLoader tableLoader = TableLoader.fromHadoopTable(\"hdfs://nn:8020/warehouse/path\");\nIcebergSource source = IcebergSource.forRowData()\n.tableLoader(tableLoader)\n.assignerFactory(new SimpleSplitAssignerFactory())\n.streaming(true)\n.streamingStartingStrategy(StreamingStartingStrategy.INCREMENTAL_FROM_LATEST_SNAPSHOT)\n.monitorInterval(Duration.ofSeconds(60))\n.build()\nDataStream&lt;RowData&gt; stream = env.fromSource(\nsource,\nWatermarkStrategy.noWatermarks(),\n\"My Iceberg Source\",\nTypeInformation.of(RowData.class));\n// Print all records to stdout.\nstream.print();\n// Submit and execute this streaming read job.\nenv.execute(\"Test Iceberg Streaming Read\");\n</code></pre> <p>There are other options that could be set by Java API, please see the IcebergSource#Builder.</p>"},{"location":"flink-queries/#reading-branches-and-tags-with-datastream","title":"Reading branches and tags with DataStream","text":"<p>Branches and tags can also be read via the DataStream API</p> <pre><code>StreamExecutionEnvironment env = StreamExecutionEnvironment.createLocalEnvironment();\nTableLoader tableLoader = TableLoader.fromHadoopTable(\"hdfs://nn:8020/warehouse/path\");\n// Read from branch\nDataStream&lt;RowData&gt; batch = FlinkSource.forRowData()\n.env(env)\n.tableLoader(tableLoader)\n.branch(\"test-branch\")\n.streaming(false)\n.build();\n// Read from tag\nDataStream&lt;RowData&gt; batch = FlinkSource.forRowData()\n.env(env)\n.tableLoader(tableLoader)\n.tag(\"test-tag\")\n.streaming(false)\n.build();\n// Streaming read from start-tag\nDataStream&lt;RowData&gt; batch = FlinkSource.forRowData()\n.env(env)\n.tableLoader(tableLoader)\n.streaming(true)\n.startTag(\"test-tag\")\n.build();\n</code></pre>"},{"location":"flink-queries/#read-as-avro-genericrecord","title":"Read as Avro GenericRecord","text":"<p>FLIP-27 Iceberg source provides <code>AvroGenericRecordReaderFunction</code> that converts Flink <code>RowData</code> Avro <code>GenericRecord</code>. You can use the convert to read from Iceberg table as Avro GenericRecord DataStream.</p> <p>Please make sure <code>flink-avro</code> jar is included in the classpath. Also <code>iceberg-flink-runtime</code> shaded bundle jar can't be used because the runtime jar shades the avro package. Please use non-shaded <code>iceberg-flink</code> jar instead.</p> <pre><code>TableLoader tableLoader = ...;\nTable table;\ntry (TableLoader loader = tableLoader) {\nloader.open();\ntable = loader.loadTable();\n}\nAvroGenericRecordReaderFunction readerFunction = AvroGenericRecordReaderFunction.fromTable(table);\nIcebergSource&lt;GenericRecord&gt; source =\nIcebergSource.&lt;GenericRecord&gt;builder()\n.tableLoader(tableLoader)\n.readerFunction(readerFunction)\n.assignerFactory(new SimpleSplitAssignerFactory())\n...\n.build();\nDataStream&lt;Row&gt; stream = env.fromSource(source, WatermarkStrategy.noWatermarks(),\n\"Iceberg Source as Avro GenericRecord\", new GenericRecordAvroTypeInfo(avroSchema));\n</code></pre>"},{"location":"flink-queries/#options","title":"Options","text":""},{"location":"flink-queries/#read-options","title":"Read options","text":"<p>Flink read options are passed when configuring the Flink IcebergSource:</p> <pre><code>IcebergSource.forRowData()\n    .tableLoader(TableLoader.fromCatalog(...))\n    .assignerFactory(new SimpleSplitAssignerFactory())\n    .streaming(true)\n    .streamingStartingStrategy(StreamingStartingStrategy.INCREMENTAL_FROM_LATEST_SNAPSHOT)\n    .startSnapshotId(3821550127947089987L)\n    .monitorInterval(Duration.ofMillis(10L)) // or .set(\"monitor-interval\", \"10s\") \\ set(FlinkReadOptions.MONITOR_INTERVAL, \"10s\")\n    .build()\n</code></pre> <p>For Flink SQL, read options can be passed in via SQL hints like this:</p> <pre><code>SELECT * FROM tableName /*+ OPTIONS('monitor-interval'='10s') */\n...\n</code></pre> <p>Options can be passed in via Flink configuration, which will be applied to current session. Note that not all options support this mode.</p> <pre><code>env.getConfig()\n    .getConfiguration()\n    .set(FlinkReadOptions.SPLIT_FILE_OPEN_COST_OPTION, 1000L);\n...\n</code></pre> <p>Check out all the options here: read-options </p>"},{"location":"flink-queries/#inspecting-tables","title":"Inspecting tables","text":"<p>To inspect a table's history, snapshots, and other metadata, Iceberg supports metadata tables.</p> <p>Metadata tables are identified by adding the metadata table name after the original table name. For example, history for <code>db.table</code> is read using <code>db.table$history</code>.</p>"},{"location":"flink-queries/#history","title":"History","text":"<p>To show table history:</p> <pre><code>SELECT * FROM prod.db.table$history;\n</code></pre> made_current_at snapshot_id parent_id is_current_ancestor 2019-02-08 03:29:51.215 5781947118336215154 NULL true 2019-02-08 03:47:55.948 5179299526185056830 5781947118336215154 true 2019-02-09 16:24:30.13 296410040247533544 5179299526185056830 false 2019-02-09 16:32:47.336 2999875608062437330 5179299526185056830 true 2019-02-09 19:42:03.919 8924558786060583479 2999875608062437330 true 2019-02-09 19:49:16.343 6536733823181975045 8924558786060583479 true <p>Info</p> <p>This shows a commit that was rolled back. In this example, snapshot 296410040247533544 and 2999875608062437330 have the same parent snapshot 5179299526185056830. Snapshot 296410040247533544 was rolled back and is not an ancestor of the current table state.</p>"},{"location":"flink-queries/#metadata-log-entries","title":"Metadata Log Entries","text":"<p>To show table metadata log entries:</p> <pre><code>SELECT * from prod.db.table$metadata_log_entries;\n</code></pre> timestamp file latest_snapshot_id latest_schema_id latest_sequence_number 2022-07-28 10:43:52.93 s3://.../table/metadata/00000-9441e604-b3c2-498a-a45a-6320e8ab9006.metadata.json null null null 2022-07-28 10:43:57.487 s3://.../table/metadata/00001-f30823df-b745-4a0a-b293-7532e0c99986.metadata.json 170260833677645300 0 1 2022-07-28 10:43:58.25 s3://.../table/metadata/00002-2cc2837a-02dc-4687-acc1-b4d86ea486f4.metadata.json 958906493976709774 0 2"},{"location":"flink-queries/#snapshots","title":"Snapshots","text":"<p>To show the valid snapshots for a table:</p> <pre><code>SELECT * FROM prod.db.table$snapshots;\n</code></pre> committed_at snapshot_id parent_id operation manifest_list summary 2019-02-08 03:29:51.215 57897183625154 null append s3://.../table/metadata/snap-57897183625154-1.avro { added-records -&gt; 2478404, total-records -&gt; 2478404, added-data-files -&gt; 438, total-data-files -&gt; 438, flink.job-id -&gt; 2e274eecb503d85369fb390e8956c813 } <p>You can also join snapshots to table history. For example, this query will show table history, with the application ID that wrote each snapshot:</p> <pre><code>select\nh.made_current_at,\ns.operation,\nh.snapshot_id,\nh.is_current_ancestor,\ns.summary['flink.job-id']\nfrom prod.db.table$history h\njoin prod.db.table$snapshots s\non h.snapshot_id = s.snapshot_id\norder by made_current_at\n</code></pre> made_current_at operation snapshot_id is_current_ancestor summary[flink.job-id] 2019-02-08 03:29:51.215 append 57897183625154 true 2e274eecb503d85369fb390e8956c813"},{"location":"flink-queries/#files","title":"Files","text":"<p>To show a table's current data files:</p> <pre><code>SELECT * FROM prod.db.table$files;\n</code></pre> content file_path file_format spec_id partition record_count file_size_in_bytes column_sizes value_counts null_value_counts nan_value_counts lower_bounds upper_bounds key_metadata split_offsets equality_ids sort_order_id 0 s3:/.../table/data/00000-3-8d6d60e8-d427-4809-bcf0-f5d45a4aad96.parquet PARQUET 0 {1999-01-01, 01} 1 597 [1 -&gt; 90, 2 -&gt; 62] [1 -&gt; 1, 2 -&gt; 1] [1 -&gt; 0, 2 -&gt; 0] [] [1 -&gt; , 2 -&gt; c] [1 -&gt; , 2 -&gt; c] null [4] null null 0 s3:/.../table/data/00001-4-8d6d60e8-d427-4809-bcf0-f5d45a4aad96.parquet PARQUET 0 {1999-01-01, 02} 1 597 [1 -&gt; 90, 2 -&gt; 62] [1 -&gt; 1, 2 -&gt; 1] [1 -&gt; 0, 2 -&gt; 0] [] [1 -&gt; , 2 -&gt; b] [1 -&gt; , 2 -&gt; b] null [4] null null 0 s3:/.../table/data/00002-5-8d6d60e8-d427-4809-bcf0-f5d45a4aad96.parquet PARQUET 0 {1999-01-01, 03} 1 597 [1 -&gt; 90, 2 -&gt; 62] [1 -&gt; 1, 2 -&gt; 1] [1 -&gt; 0, 2 -&gt; 0] [] [1 -&gt; , 2 -&gt; a] [1 -&gt; , 2 -&gt; a] null [4] null null"},{"location":"flink-queries/#manifests","title":"Manifests","text":"<p>To show a table's current file manifests:</p> <pre><code>SELECT * FROM prod.db.table$manifests;\n</code></pre> path length partition_spec_id added_snapshot_id added_data_files_count existing_data_files_count deleted_data_files_count partition_summaries s3://.../table/metadata/45b5290b-ee61-4788-b324-b1e2735c0e10-m0.avro 4479 0 6668963634911763636 8 0 0 [[false,null,2019-05-13,2019-05-15]] <p>Note:</p> <ol> <li>Fields within <code>partition_summaries</code> column of the manifests table correspond to <code>field_summary</code> structs within manifest list, with the following order:<ul> <li><code>contains_null</code></li> <li><code>contains_nan</code></li> <li><code>lower_bound</code></li> <li><code>upper_bound</code></li> </ul> </li> <li><code>contains_nan</code> could return null, which indicates that this information is not available from the file's metadata.    This usually occurs when reading from V1 table, where <code>contains_nan</code> is not populated.</li> </ol>"},{"location":"flink-queries/#partitions","title":"Partitions","text":"<p>To show a table's current partitions:</p> <pre><code>SELECT * FROM prod.db.table$partitions;\n</code></pre> partition record_count file_count spec_id {20211001, 11} 1 1 0 {20211002, 11} 1 1 0 {20211001, 10} 1 1 0 {20211002, 10} 1 1 0 <p>Note: For unpartitioned tables, the partitions table will contain only the record_count and file_count columns.</p>"},{"location":"flink-queries/#all-metadata-tables","title":"All Metadata Tables","text":"<p>These tables are unions of the metadata tables specific to the current snapshot, and return metadata across all snapshots.</p> <p>Danger</p> <p>The \"all\" metadata tables may produce more than one row per data file or manifest file because metadata files may be part of more than one table snapshot.</p>"},{"location":"flink-queries/#all-data-files","title":"All Data Files","text":"<p>To show all of the table's data files and each file's metadata:</p> <pre><code>SELECT * FROM prod.db.table$all_data_files;\n</code></pre> content file_path file_format partition record_count file_size_in_bytes column_sizes value_counts null_value_counts nan_value_counts lower_bounds upper_bounds key_metadata split_offsets equality_ids sort_order_id 0 s3://.../dt=20210102/00000-0-756e2512-49ae-45bb-aae3-c0ca475e7879-00001.parquet PARQUET {20210102} 14 2444 {1 -&gt; 94, 2 -&gt; 17} {1 -&gt; 14, 2 -&gt; 14} {1 -&gt; 0, 2 -&gt; 0} {} {1 -&gt; 1, 2 -&gt; 20210102} {1 -&gt; 2, 2 -&gt; 20210102} null [4] null 0 0 s3://.../dt=20210103/00000-0-26222098-032f-472b-8ea5-651a55b21210-00001.parquet PARQUET {20210103} 14 2444 {1 -&gt; 94, 2 -&gt; 17} {1 -&gt; 14, 2 -&gt; 14} {1 -&gt; 0, 2 -&gt; 0} {} {1 -&gt; 1, 2 -&gt; 20210103} {1 -&gt; 3, 2 -&gt; 20210103} null [4] null 0 0 s3://.../dt=20210104/00000-0-a3bb1927-88eb-4f1c-bc6e-19076b0d952e-00001.parquet PARQUET {20210104} 14 2444 {1 -&gt; 94, 2 -&gt; 17} {1 -&gt; 14, 2 -&gt; 14} {1 -&gt; 0, 2 -&gt; 0} {} {1 -&gt; 1, 2 -&gt; 20210104} {1 -&gt; 3, 2 -&gt; 20210104} null [4] null 0"},{"location":"flink-queries/#all-manifests","title":"All Manifests","text":"<p>To show all of the table's manifest files:</p> <pre><code>SELECT * FROM prod.db.table$all_manifests;\n</code></pre> path length partition_spec_id added_snapshot_id added_data_files_count existing_data_files_count deleted_data_files_count partition_summaries s3://.../metadata/a85f78c5-3222-4b37-b7e4-faf944425d48-m0.avro 6376 0 6272782676904868561 2 0 0 [{false, false, 20210101, 20210101}] <p>Note:</p> <ol> <li>Fields within <code>partition_summaries</code> column of the manifests table correspond to <code>field_summary</code> structs within manifest list, with the following order:<ul> <li><code>contains_null</code></li> <li><code>contains_nan</code></li> <li><code>lower_bound</code></li> <li><code>upper_bound</code></li> </ul> </li> <li><code>contains_nan</code> could return null, which indicates that this information is not available from the file's metadata.    This usually occurs when reading from V1 table, where <code>contains_nan</code> is not populated.</li> </ol>"},{"location":"flink-queries/#references","title":"References","text":"<p>To show a table's known snapshot references:</p> <pre><code>SELECT * FROM prod.db.table$refs;\n</code></pre> name type snapshot_id max_reference_age_in_ms min_snapshots_to_keep max_snapshot_age_in_ms main BRANCH 4686954189838128572 10 20 30 testTag TAG 4686954189838128572 10 null null"},{"location":"flink-writes/","title":"Flink Writes","text":""},{"location":"flink-writes/#flink-writes","title":"Flink Writes","text":"<p>Iceberg support batch and streaming writes With Apache Flink's DataStream API and Table API.</p>"},{"location":"flink-writes/#writing-with-sql","title":"Writing with SQL","text":"<p>Iceberg support both <code>INSERT INTO</code> and <code>INSERT OVERWRITE</code>.</p>"},{"location":"flink-writes/#insert-into","title":"<code>INSERT INTO</code>","text":"<p>To append new data to a table with a Flink streaming job, use <code>INSERT INTO</code>:</p> <pre><code>INSERT INTO `hive_catalog`.`default`.`sample` VALUES (1, 'a');\nINSERT INTO `hive_catalog`.`default`.`sample` SELECT id, data from other_kafka_table;\n</code></pre>"},{"location":"flink-writes/#insert-overwrite","title":"<code>INSERT OVERWRITE</code>","text":"<p>To replace data in the table with the result of a query, use <code>INSERT OVERWRITE</code> in batch job (flink streaming job does not support <code>INSERT OVERWRITE</code>). Overwrites are atomic operations for Iceberg tables.</p> <p>Partitions that have rows produced by the SELECT query will be replaced, for example:</p> <pre><code>INSERT OVERWRITE sample VALUES (1, 'a');\n</code></pre> <p>Iceberg also support overwriting given partitions by the <code>select</code> values:</p> <pre><code>INSERT OVERWRITE `hive_catalog`.`default`.`sample` PARTITION(data='a') SELECT 6;\n</code></pre> <p>For a partitioned iceberg table, when all the partition columns are set a value in <code>PARTITION</code> clause, it is inserting into a static partition, otherwise if partial partition columns (prefix part of all partition columns) are set a value in <code>PARTITION</code> clause, it is writing the query result into a dynamic partition. For an unpartitioned iceberg table, its data will be completely overwritten by <code>INSERT OVERWRITE</code>.</p>"},{"location":"flink-writes/#upsert","title":"<code>UPSERT</code>","text":"<p>Iceberg supports <code>UPSERT</code> based on the primary key when writing data into v2 table format. There are two ways to enable upsert.</p> <ol> <li>Enable the <code>UPSERT</code> mode as table-level property <code>write.upsert.enabled</code>. Here is an example SQL statement to set the table property when creating a table. It would be applied for all write paths to this table (batch or streaming) unless overwritten by write options as described later.</li> </ol> <pre><code>CREATE TABLE `hive_catalog`.`default`.`sample` (\n`id`  INT UNIQUE COMMENT 'unique id',\n`data` STRING NOT NULL,\nPRIMARY KEY(`id`) NOT ENFORCED\n) with ('format-version'='2', 'write.upsert.enabled'='true');\n</code></pre> <ol> <li>Enabling <code>UPSERT</code> mode using <code>upsert-enabled</code> in the write options provides more flexibility than a table level config. Note that you still need to use v2 table format and specify the primary key when creating the table.</li> </ol> <pre><code>INSERT INTO tableName /*+ OPTIONS('upsert-enabled'='true') */\n...\n</code></pre> <p>Info</p> <p>OVERWRITE and UPSERT can't be set together. In UPSERT mode, if the table is partitioned, the partition fields should be included in equality fields.</p>"},{"location":"flink-writes/#writing-with-datastream","title":"Writing with DataStream","text":"<p>Iceberg support writing to iceberg table from different DataStream input.</p>"},{"location":"flink-writes/#appending-data","title":"Appending data.","text":"<p>Flink supports writing <code>DataStream&lt;RowData&gt;</code> and <code>DataStream&lt;Row&gt;</code> to the sink iceberg table natively.</p> <pre><code>StreamExecutionEnvironment env = ...;\nDataStream&lt;RowData&gt; input = ... ;\nConfiguration hadoopConf = new Configuration();\nTableLoader tableLoader = TableLoader.fromHadoopTable(\"hdfs://nn:8020/warehouse/path\", hadoopConf);\nFlinkSink.forRowData(input)\n.tableLoader(tableLoader)\n.append();\nenv.execute(\"Test Iceberg DataStream\");\n</code></pre> <p>The iceberg API also allows users to write generic <code>DataStream&lt;T&gt;</code> to iceberg table, more example could be found in this unit test.</p>"},{"location":"flink-writes/#overwrite-data","title":"Overwrite data","text":"<p>Set the <code>overwrite</code> flag in FlinkSink builder to overwrite the data in existing iceberg tables:</p> <pre><code>StreamExecutionEnvironment env = ...;\nDataStream&lt;RowData&gt; input = ... ;\nConfiguration hadoopConf = new Configuration();\nTableLoader tableLoader = TableLoader.fromHadoopTable(\"hdfs://nn:8020/warehouse/path\", hadoopConf);\nFlinkSink.forRowData(input)\n.tableLoader(tableLoader)\n.overwrite(true)\n.append();\nenv.execute(\"Test Iceberg DataStream\");\n</code></pre>"},{"location":"flink-writes/#upsert-data","title":"Upsert data","text":"<p>Set the <code>upsert</code> flag in FlinkSink builder to upsert the data in existing iceberg table. The table must use v2 table format and have a primary key.</p> <pre><code>StreamExecutionEnvironment env = ...;\nDataStream&lt;RowData&gt; input = ... ;\nConfiguration hadoopConf = new Configuration();\nTableLoader tableLoader = TableLoader.fromHadoopTable(\"hdfs://nn:8020/warehouse/path\", hadoopConf);\nFlinkSink.forRowData(input)\n.tableLoader(tableLoader)\n.upsert(true)\n.append();\nenv.execute(\"Test Iceberg DataStream\");\n</code></pre> <p>Info</p> <p>OVERWRITE and UPSERT can't be set together. In UPSERT mode, if the table is partitioned, the partition fields should be included in equality fields.</p>"},{"location":"flink-writes/#write-with-avro-genericrecord","title":"Write with Avro GenericRecord","text":"<p>Flink Iceberg sink provides <code>AvroGenericRecordToRowDataMapper</code> that converts Avro <code>GenericRecord</code> to Flink <code>RowData</code>. You can use the mapper to write Avro GenericRecord DataStream to Iceberg.</p> <p>Please make sure <code>flink-avro</code> jar is included in the classpath. Also <code>iceberg-flink-runtime</code> shaded bundle jar can't be used because the runtime jar shades the avro package. Please use non-shaded <code>iceberg-flink</code> jar instead.</p> <pre><code>DataStream&lt;org.apache.avro.generic.GenericRecord&gt; dataStream = ...;\nSchema icebergSchema = table.schema();\n// The Avro schema converted from Iceberg schema can't be used\n// due to precision difference between how Iceberg schema (micro)\n// and Flink AvroToRowDataConverters (milli) deal with time type.\n// Instead, use the Avro schema defined directly.\n// See AvroGenericRecordToRowDataMapper Javadoc for more details.\norg.apache.avro.Schema avroSchema = AvroSchemaUtil.convert(icebergSchema, table.name());\nGenericRecordAvroTypeInfo avroTypeInfo = new GenericRecordAvroTypeInfo(avroSchema);\nRowType rowType = FlinkSchemaUtil.convert(icebergSchema);\nFlinkSink.builderFor(\ndataStream,\nAvroGenericRecordToRowDataMapper.forAvroSchema(avroSchema),\nFlinkCompatibilityUtil.toTypeInfo(rowType))\n.table(table)\n.tableLoader(tableLoader)\n.append();\n</code></pre>"},{"location":"flink-writes/#branch-writes","title":"Branch Writes","text":"<p>Writing to branches in Iceberg tables is also supported via the <code>toBranch</code> API in <code>FlinkSink</code> For more information on branches please refer to branches. <pre><code>FlinkSink.forRowData(input)\n.tableLoader(tableLoader)\n.toBranch(\"audit-branch\")\n.append();\n</code></pre></p>"},{"location":"flink-writes/#metrics","title":"Metrics","text":"<p>The following Flink metrics are provided by the Flink Iceberg sink.</p> <p>Parallel writer metrics are added under the sub group of <code>IcebergStreamWriter</code>. They should have the following key-value tags.</p> <ul> <li>table: full table name (like iceberg.my_db.my_table)</li> <li>subtask_index: writer subtask index starting from 0</li> </ul> Metric name Metric type Description lastFlushDurationMs Gague The duration (in milli) that writer subtasks take to flush and upload the files during checkpoint. flushedDataFiles Counter Number of data files flushed and uploaded. flushedDeleteFiles Counter Number of delete files flushed and uploaded. flushedReferencedDataFiles Counter Number of data files referenced by the flushed delete files. dataFilesSizeHistogram Histogram Histogram distribution of data file sizes (in bytes). deleteFilesSizeHistogram Histogram Histogram distribution of delete file sizes (in bytes). <p>Committer metrics are added under the sub group of <code>IcebergFilesCommitter</code>. They should have the following key-value tags.</p> <ul> <li>table: full table name (like iceberg.my_db.my_table)</li> </ul> Metric name Metric type Description lastCheckpointDurationMs Gague The duration (in milli) that the committer operator checkpoints its state. lastCommitDurationMs Gague The duration (in milli) that the Iceberg table commit takes. committedDataFilesCount Counter Number of data files committed. committedDataFilesRecordCount Counter Number of records contained in the committed data files. committedDataFilesByteCount Counter Number of bytes contained in the committed data files. committedDeleteFilesCount Counter Number of delete files committed. committedDeleteFilesRecordCount Counter Number of records contained in the committed delete files. committedDeleteFilesByteCount Counter Number of bytes contained in the committed delete files. elapsedSecondsSinceLastSuccessfulCommit Gague Elapsed time (in seconds) since last successful Iceberg commit. <p><code>elapsedSecondsSinceLastSuccessfulCommit</code> is an ideal alerting metric to detect failed or missing Iceberg commits.</p> <ul> <li>Iceberg commit happened after successful Flink checkpoint in the <code>notifyCheckpointComplete</code> callback.   It could happen that Iceberg commits failed (for whatever reason), while Flink checkpoints succeeding.</li> <li>It could also happen that <code>notifyCheckpointComplete</code> wasn't triggered (for whatever bug).   As a result, there won't be any Iceberg commits attempted.</li> </ul> <p>If the checkpoint interval (and expected Iceberg commit interval) is 5 minutes, set up alert with rule like <code>elapsedSecondsSinceLastSuccessfulCommit &gt; 60 minutes</code> to detect failed or missing Iceberg commits in the past hour.</p>"},{"location":"flink-writes/#options","title":"Options","text":""},{"location":"flink-writes/#write-options","title":"Write options","text":"<p>Flink write options are passed when configuring the FlinkSink, like this:</p> <pre><code>FlinkSink.Builder builder = FlinkSink.forRow(dataStream, SimpleDataUtil.FLINK_SCHEMA)\n.table(table)\n.tableLoader(tableLoader)\n.set(\"write-format\", \"orc\")\n.set(FlinkWriteOptions.OVERWRITE_MODE, \"true\");\n</code></pre> <p>For Flink SQL, write options can be passed in via SQL hints like this:</p> <pre><code>INSERT INTO tableName /*+ OPTIONS('upsert-enabled'='true') */\n...\n</code></pre> <p>Check out all the options here: write-options </p>"},{"location":"flink/","title":"Flink Getting Started","text":""},{"location":"flink/#flink","title":"Flink","text":"<p>Apache Iceberg supports both Apache Flink's DataStream API and Table API. See the Multi-Engine Support#apache-flink page for the integration of Apache Flink.</p> Feature support Flink Notes SQL create catalog \u2714\ufe0f SQL create database \u2714\ufe0f SQL create table \u2714\ufe0f SQL create table like \u2714\ufe0f SQL alter table \u2714\ufe0f Only support altering table properties, column and partition changes are not supported SQL drop_table \u2714\ufe0f SQL select \u2714\ufe0f Support both streaming and batch mode SQL insert into \u2714\ufe0f \ufe0f Support both streaming and batch mode SQL insert overwrite \u2714\ufe0f \ufe0f DataStream read \u2714\ufe0f \ufe0f DataStream append \u2714\ufe0f \ufe0f DataStream overwrite \u2714\ufe0f \ufe0f Metadata tables \u2714\ufe0f Rewrite files action \u2714\ufe0f \ufe0f"},{"location":"flink/#preparation-when-using-flink-sql-client","title":"Preparation when using Flink SQL Client","text":"<p>To create Iceberg table in Flink, it is recommended to use Flink SQL Client as it's easier for users to understand the concepts.</p> <p>Download Flink from the Apache download page. Iceberg uses Scala 2.12 when compiling the Apache <code>iceberg-flink-runtime</code> jar, so it's recommended to use Flink 1.16 bundled with Scala 2.12.</p> <pre><code>FLINK_VERSION=1.16.1\nSCALA_VERSION=2.12\nAPACHE_FLINK_URL=https://archive.apache.org/dist/flink/\nwget ${APACHE_FLINK_URL}/flink-${FLINK_VERSION}/flink-${FLINK_VERSION}-bin-scala_${SCALA_VERSION}.tgz\ntar xzvf flink-${FLINK_VERSION}-bin-scala_${SCALA_VERSION}.tgz\n</code></pre> <p>Start a standalone Flink cluster within Hadoop environment:</p> <pre><code># HADOOP_HOME is your hadoop root directory after unpack the binary package.\nAPACHE_HADOOP_URL=https://archive.apache.org/dist/hadoop/\nHADOOP_VERSION=2.8.5\nwget ${APACHE_HADOOP_URL}/common/hadoop-${HADOOP_VERSION}/hadoop-${HADOOP_VERSION}.tar.gz\ntar xzvf hadoop-${HADOOP_VERSION}.tar.gz\nHADOOP_HOME=`pwd`/hadoop-${HADOOP_VERSION}\nexport HADOOP_CLASSPATH=`$HADOOP_HOME/bin/hadoop classpath`\n# Start the flink standalone cluster\n./bin/start-cluster.sh\n</code></pre> <p>Start the Flink SQL client. There is a separate <code>flink-runtime</code> module in the Iceberg project to generate a bundled jar, which could be loaded by Flink SQL client directly. To build the <code>flink-runtime</code> bundled jar manually, build the <code>iceberg</code> project, and it will generate the jar under <code>&lt;iceberg-root-dir&gt;/flink-runtime/build/libs</code>. Or download the <code>flink-runtime</code> jar from the Apache repository.</p> <pre><code># HADOOP_HOME is your hadoop root directory after unpack the binary package.\nexport HADOOP_CLASSPATH=`$HADOOP_HOME/bin/hadoop classpath`   ./bin/sql-client.sh embedded -j &lt;flink-runtime-directory&gt;/iceberg-flink-runtime-1.16-{{ icebergVersion }}.jar shell\n</code></pre> <p>By default, Iceberg ships with Hadoop jars for Hadoop catalog. To use Hive catalog, load the Hive jars when opening the Flink SQL client. Fortunately, Flink has provided a bundled hive jar for the SQL client. An example on how to download the dependencies and get started:</p> <pre><code># HADOOP_HOME is your hadoop root directory after unpack the binary package.\nexport HADOOP_CLASSPATH=`$HADOOP_HOME/bin/hadoop classpath`\nICEBERG_VERSION={{ icebergVersion }}\nMAVEN_URL=https://repo1.maven.org/maven2\nICEBERG_MAVEN_URL=${MAVEN_URL}/org/apache/iceberg\nICEBERG_PACKAGE=iceberg-flink-runtime\nwget ${ICEBERG_MAVEN_URL}/${ICEBERG_PACKAGE}-${FLINK_VERSION_MAJOR}/${ICEBERG_VERSION}/${ICEBERG_PACKAGE}-${FLINK_VERSION_MAJOR}-${ICEBERG_VERSION}.jar -P lib/\n\nHIVE_VERSION=2.3.9\nSCALA_VERSION=2.12\nFLINK_VERSION=1.16.1\nFLINK_CONNECTOR_URL=${MAVEN_URL}/org/apache/flink\nFLINK_CONNECTOR_PACKAGE=flink-sql-connector-hive\nwget ${FLINK_CONNECTOR_URL}/${FLINK_CONNECTOR_PACKAGE}-${HIVE_VERSION}_${SCALA_VERSION}/${FLINK_VERSION}/${FLINK_CONNECTOR_PACKAGE}-${HIVE_VERSION}_${SCALA_VERSION}-${FLINK_VERSION}.jar\n\n./bin/sql-client.sh embedded shell\n</code></pre>"},{"location":"flink/#flinks-python-api","title":"Flink's Python API","text":"<p>Info</p> <p>PyFlink 1.6.1 does not work on OSX with a M1 cpu</p> <p>Install the Apache Flink dependency using <code>pip</code>:</p> <pre><code>pip install apache-flink==1.16.1\n</code></pre> <p>Provide a <code>file://</code> path to the <code>iceberg-flink-runtime</code> jar, which can be obtained by building the project and looking at <code>&lt;iceberg-root-dir&gt;/flink-runtime/build/libs</code>, or downloading it from the Apache official repository. Third-party jars can be added to <code>pyflink</code> via:</p> <ul> <li><code>env.add_jars(\"file:///my/jar/path/connector.jar\")</code></li> <li><code>table_env.get_config().get_configuration().set_string(\"pipeline.jars\", \"file:///my/jar/path/connector.jar\")</code></li> </ul> <p>This is also mentioned in the official docs. The example below uses <code>env.add_jars(..)</code>:</p> <pre><code>import os\nfrom pyflink.datastream import StreamExecutionEnvironment\nenv = StreamExecutionEnvironment.get_execution_environment()\niceberg_flink_runtime_jar = os.path.join(os.getcwd(), \"iceberg-flink-runtime-1.16-{{ icebergVersion }}.jar\")\nenv.add_jars(\"file://{}\".format(iceberg_flink_runtime_jar))\n</code></pre> <p>Next, create a <code>StreamTableEnvironment</code> and execute Flink SQL statements. The below example shows how to create a custom catalog via the Python Table API:</p> <pre><code>from pyflink.table import StreamTableEnvironment\ntable_env = StreamTableEnvironment.create(env)\ntable_env.execute_sql(\"\"\"\nCREATE CATALOG my_catalog WITH (\n    'type'='iceberg', \n    'catalog-impl'='com.my.custom.CatalogImpl',\n    'my-additional-catalog-config'='my-value'\n)\n\"\"\")\n</code></pre> <p>Run a query:</p> <pre><code>(table_env\n.sql_query(\"SELECT PULocationID, DOLocationID, passenger_count FROM my_catalog.nyc.taxis LIMIT 5\")\n.execute()\n.print()) \n</code></pre> <pre><code>+----+----------------------+----------------------+--------------------------------+\n| op |         PULocationID |         DOLocationID |                passenger_count |\n+----+----------------------+----------------------+--------------------------------+\n| +I |                  249 |                   48 |                            1.0 |\n| +I |                  132 |                  233 |                            1.0 |\n| +I |                  164 |                  107 |                            1.0 |\n| +I |                   90 |                  229 |                            1.0 |\n| +I |                  137 |                  249 |                            1.0 |\n+----+----------------------+----------------------+--------------------------------+\n5 rows in set\n</code></pre> <p>For more details, please refer to the Python Table API.</p>"},{"location":"flink/#adding-catalogs","title":"Adding catalogs.","text":"<p>Flink support to create catalogs by using Flink SQL.</p>"},{"location":"flink/#catalog-configuration","title":"Catalog Configuration","text":"<p>A catalog is created and named by executing the following query (replace <code>&lt;catalog_name&gt;</code> with your catalog name and <code>&lt;config_key&gt;</code>=<code>&lt;config_value&gt;</code> with catalog implementation config):</p> <pre><code>CREATE CATALOG &lt;catalog_name&gt; WITH (\n'type'='iceberg',\n`&lt;config_key&gt;`=`&lt;config_value&gt;`\n); </code></pre> <p>The following properties can be set globally and are not limited to a specific catalog implementation:</p> <ul> <li><code>type</code>: Must be <code>iceberg</code>. (required)</li> <li><code>catalog-type</code>: <code>hive</code>, <code>hadoop</code> or <code>rest</code> for built-in catalogs, or left unset for custom catalog implementations using catalog-impl. (Optional)</li> <li><code>catalog-impl</code>: The fully-qualified class name of a custom catalog implementation. Must be set if <code>catalog-type</code> is unset. (Optional)</li> <li><code>property-version</code>: Version number to describe the property version. This property can be used for backwards compatibility in case the property format changes. The current property version is <code>1</code>. (Optional)</li> <li><code>cache-enabled</code>: Whether to enable catalog cache, default value is <code>true</code>. (Optional)</li> <li><code>cache.expiration-interval-ms</code>: How long catalog entries are locally cached, in milliseconds; negative values like <code>-1</code> will disable expiration, value 0 is not allowed to set. default value is <code>-1</code>. (Optional)</li> </ul>"},{"location":"flink/#hive-catalog","title":"Hive catalog","text":"<p>This creates an Iceberg catalog named <code>hive_catalog</code> that can be configured using <code>'catalog-type'='hive'</code>, which loads tables from Hive metastore:</p> <pre><code>CREATE CATALOG hive_catalog WITH (\n'type'='iceberg',\n'catalog-type'='hive',\n'uri'='thrift://localhost:9083',\n'clients'='5',\n'property-version'='1',\n'warehouse'='hdfs://nn:8020/warehouse/path'\n);\n</code></pre> <p>The following properties can be set if using the Hive catalog:</p> <ul> <li><code>uri</code>: The Hive metastore's thrift URI. (Required)</li> <li><code>clients</code>: The Hive metastore client pool size, default value is 2. (Optional)</li> <li><code>warehouse</code>: The Hive warehouse location, users should specify this path if neither set the <code>hive-conf-dir</code> to specify a location containing a <code>hive-site.xml</code> configuration file nor add a correct <code>hive-site.xml</code> to classpath.</li> <li><code>hive-conf-dir</code>: Path to a directory containing a <code>hive-site.xml</code> configuration file which will be used to provide custom Hive configuration values. The value of <code>hive.metastore.warehouse.dir</code> from <code>&lt;hive-conf-dir&gt;/hive-site.xml</code> (or hive configure file from classpath) will be overwritten with the <code>warehouse</code> value if setting both <code>hive-conf-dir</code> and <code>warehouse</code> when creating iceberg catalog.</li> <li><code>hadoop-conf-dir</code>: Path to a directory containing <code>core-site.xml</code> and <code>hdfs-site.xml</code> configuration files which will be used to provide custom Hadoop configuration values.</li> </ul>"},{"location":"flink/#creating-a-table","title":"Creating a table","text":"<pre><code>CREATE TABLE `hive_catalog`.`default`.`sample` (\nid BIGINT COMMENT 'unique id',\ndata STRING\n);\n</code></pre>"},{"location":"flink/#writing","title":"Writing","text":"<p>To append new data to a table with a Flink streaming job, use <code>INSERT INTO</code>:</p> <pre><code>INSERT INTO `hive_catalog`.`default`.`sample` VALUES (1, 'a');\nINSERT INTO `hive_catalog`.`default`.`sample` SELECT id, data from other_kafka_table;\n</code></pre> <p>To replace data in the table with the result of a query, use <code>INSERT OVERWRITE</code> in batch job (flink streaming job does not support <code>INSERT OVERWRITE</code>). Overwrites are atomic operations for Iceberg tables.</p> <p>Partitions that have rows produced by the SELECT query will be replaced, for example:</p> <pre><code>INSERT OVERWRITE `hive_catalog`.`default`.`sample` VALUES (1, 'a');\n</code></pre> <p>Iceberg also support overwriting given partitions by the <code>select</code> values:</p> <pre><code>INSERT OVERWRITE `hive_catalog`.`default`.`sample` PARTITION(data='a') SELECT 6;\n</code></pre> <p>Flink supports writing <code>DataStream&lt;RowData&gt;</code> and <code>DataStream&lt;Row&gt;</code> to the sink iceberg table natively.</p> <pre><code>StreamExecutionEnvironment env = ...;\nDataStream&lt;RowData&gt; input = ... ;\nConfiguration hadoopConf = new Configuration();\nTableLoader tableLoader = TableLoader.fromHadoopTable(\"hdfs://nn:8020/warehouse/path\", hadoopConf);\nFlinkSink.forRowData(input)\n.tableLoader(tableLoader)\n.append();\nenv.execute(\"Test Iceberg DataStream\");\n</code></pre>"},{"location":"flink/#branch-writes","title":"Branch Writes","text":"<p>Writing to branches in Iceberg tables is also supported via the <code>toBranch</code> API in <code>FlinkSink</code> For more information on branches please refer to branches. <pre><code>FlinkSink.forRowData(input)\n.tableLoader(tableLoader)\n.toBranch(\"audit-branch\")\n.append();\n</code></pre></p>"},{"location":"flink/#reading","title":"Reading","text":"<p>Submit a Flink batch job using the following sentences:</p> <pre><code>-- Execute the flink job in batch mode for current session context\nSET execution.runtime-mode = batch;\nSELECT * FROM `hive_catalog`.`default`.`sample`;\n</code></pre> <p>Iceberg supports processing incremental data in flink streaming jobs which starts from a historical snapshot-id:</p> <pre><code>-- Submit the flink job in streaming mode for current session.\nSET execution.runtime-mode = streaming;\n-- Enable this switch because streaming read SQL will provide few job options in flink SQL hint options.\nSET table.dynamic-table-options.enabled=true;\n-- Read all the records from the iceberg current snapshot, and then read incremental data starting from that snapshot.\nSELECT * FROM `hive_catalog`.`default`.`sample` /*+ OPTIONS('streaming'='true', 'monitor-interval'='1s')*/ ;\n-- Read all incremental data starting from the snapshot-id '3821550127947089987' (records from this snapshot will be excluded).\nSELECT * FROM `hive_catalog`.`default`.`sample` /*+ OPTIONS('streaming'='true', 'monitor-interval'='1s', 'start-snapshot-id'='3821550127947089987')*/ ;\n</code></pre> <p>SQL is also the recommended way to inspect tables. To view all of the snapshots in a table, use the snapshots metadata table:</p> <pre><code>SELECT * FROM `hive_catalog`.`default`.`sample`.`snapshots`\n</code></pre> <p>Iceberg support streaming or batch read in Java API:</p> <pre><code>DataStream&lt;RowData&gt; batch = FlinkSource.forRowData()\n     .env(env)\n     .tableLoader(tableLoader)\n     .streaming(false)\n     .build();\n</code></pre>"},{"location":"flink/#type-conversion","title":"Type conversion","text":"<p>Iceberg's integration for Flink automatically converts between Flink and Iceberg types. When writing to a table with types that are not supported by Flink, like UUID, Iceberg will accept and convert values from the Flink type.</p>"},{"location":"flink/#flink-to-iceberg","title":"Flink to Iceberg","text":"<p>Flink types are converted to Iceberg types according to the following table:</p> Flink Iceberg Notes boolean boolean tinyint integer smallint integer integer integer bigint long float float double double char string varchar string string string binary binary varbinary fixed decimal decimal date date time time timestamp timestamp without timezone timestamp_ltz timestamp with timezone array list map map multiset map row struct raw Not supported interval Not supported structured Not supported timestamp with zone Not supported distinct Not supported null Not supported symbol Not supported logical Not supported"},{"location":"flink/#iceberg-to-flink","title":"Iceberg to Flink","text":"<p>Iceberg types are converted to Flink types according to the following table:</p> Iceberg Flink boolean boolean struct row list array map map integer integer long bigint float float double double date date time time timestamp without timezone timestamp(6) timestamp with timezone timestamp_ltz(6) string varchar(2147483647) uuid binary(16) fixed(N) binary(N) binary varbinary(2147483647) decimal(P, S) decimal(P, S)"},{"location":"flink/#future-improvements","title":"Future improvements","text":"<p>There are some features that are do not yet supported in the current Flink Iceberg integration work:</p> <ul> <li>Don't support creating iceberg table with hidden partitioning. Discussion in flink mail list.</li> <li>Don't support creating iceberg table with computed column.</li> <li>Don't support creating iceberg table with watermark.</li> <li>Don't support adding columns, removing columns, renaming columns, changing columns. FLINK-19062 is tracking this.</li> </ul>"},{"location":"hive-migration/","title":"Hive Migration","text":""},{"location":"hive-migration/#hive-table-migration","title":"Hive Table Migration","text":"<p>Apache Hive supports ORC, Parquet, and Avro file formats that could be migrated to Iceberg. When migrating data to an Iceberg table, which provides versioning and transactional updates, only the most recent data files need to be migrated.</p> <p>Iceberg supports all three migration actions: Snapshot Table, Migrate Table, and Add Files for migrating from Hive tables to Iceberg tables. Since Hive tables do not maintain snapshots, the migration process essentially involves creating a new Iceberg table with the existing schema and committing all data files across all partitions to the new Iceberg table. After the initial migration, any new data files are added to the new Iceberg table using the Add Files action.</p>"},{"location":"hive-migration/#enabling-migration-from-hive-to-iceberg","title":"Enabling Migration from Hive to Iceberg","text":"<p>The Hive table migration actions are supported by the Spark Integration module via Spark Procedures.  The procedures are bundled in the Spark runtime jar, which is available in the Iceberg Release Downloads.</p>"},{"location":"hive-migration/#snapshot-hive-table-to-iceberg","title":"Snapshot Hive Table to Iceberg","text":"<p>To snapshot a Hive table, users can run the following Spark SQL: <pre><code>CALL catalog_name.system.snapshot('db.source', 'db.dest')\n</code></pre> See Spark Procedure: snapshot for more details.</p>"},{"location":"hive-migration/#migrate-hive-table-to-iceberg","title":"Migrate Hive Table To Iceberg","text":"<p>To migrate a Hive table to Iceberg, users can run the following Spark SQL: <pre><code>CALL catalog_name.system.migrate('db.sample')\n</code></pre> See Spark Procedure: migrate for more details.</p>"},{"location":"hive-migration/#add-files-from-hive-table-to-iceberg","title":"Add Files From Hive Table to Iceberg","text":"<p>To add data files from a Hive table to a given Iceberg table, users can run the following Spark SQL: <pre><code>CALL spark_catalog.system.add_files(\ntable =&gt; 'db.tbl',\nsource_table =&gt; 'db.src_tbl'\n)\n</code></pre> See Spark Procedure: add_files for more details.</p>"},{"location":"hive/","title":"Hive","text":""},{"location":"hive/#hive","title":"Hive","text":"<p>Iceberg supports reading and writing Iceberg tables through Hive by using a StorageHandler.</p>"},{"location":"hive/#feature-support","title":"Feature support","text":"<p>Iceberg compatibility with Hive 2.x and Hive 3.1.2/3 supports the following features:</p> <ul> <li>Creating a table</li> <li>Dropping a table</li> <li>Reading a table</li> <li>Inserting into a table (INSERT INTO)</li> </ul> <p>Warning</p> <p>DML operations work only with MapReduce execution engine.</p> <p>With Hive version 4.0.0-alpha-2 and above, the Iceberg integration when using HiveCatalog supports the following additional features:</p> <ul> <li>Altering a table with expiring snapshots.</li> <li>Create a table like an existing table (CTLT table)</li> <li>Support adding parquet compression type via Table properties Compression types</li> <li>Altering a table metadata location</li> <li>Supporting table rollback</li> <li>Honors sort orders on existing tables when writing a table Sort orders specification</li> </ul> <p>With Hive version 4.0.0-alpha-1 and above, the Iceberg integration when using HiveCatalog supports the following additional features:</p> <ul> <li>Creating an Iceberg identity-partitioned table</li> <li>Creating an Iceberg table with any partition spec, including the various transforms supported by Iceberg</li> <li>Creating a table from an existing table (CTAS table)</li> <li>Altering a table while keeping Iceberg and Hive schemas in sync</li> <li>Altering the partition schema (updating columns)</li> <li>Altering the partition schema by specifying partition transforms</li> <li>Truncating a table</li> <li>Migrating tables in Avro, Parquet, or ORC (Non-ACID) format to Iceberg</li> <li>Reading the schema of a table</li> <li>Querying Iceberg metadata tables</li> <li>Time travel applications</li> <li>Inserting into a table (INSERT INTO)</li> <li>Inserting data overwriting existing data (INSERT OVERWRITE)</li> </ul> <p>Warning</p> <p>DML operations work only with Tez execution engine.</p>"},{"location":"hive/#enabling-iceberg-support-in-hive","title":"Enabling Iceberg support in Hive","text":""},{"location":"hive/#hive-400-alpha-1","title":"Hive 4.0.0-alpha-1","text":"<p>Hive 4.0.0-alpha-1 comes with the Iceberg 0.13.1 included. No additional downloads or jars are needed.</p>"},{"location":"hive/#hive-23x-hive-31x","title":"Hive 2.3.x, Hive 3.1.x","text":"<p>In order to use Hive 2.3.x or Hive 3.1.x, you must load the Iceberg-Hive runtime jar and enable Iceberg support, either globally or for an individual table using a table property.</p>"},{"location":"hive/#loading-runtime-jar","title":"Loading runtime jar","text":"<p>To enable Iceberg support in Hive, the <code>HiveIcebergStorageHandler</code> and supporting classes need to be made available on Hive's classpath. These are provided by the <code>iceberg-hive-runtime</code> jar file. For example, if using the Hive shell, this can be achieved by issuing a statement like so:</p> <pre><code>add jar /path/to/iceberg-hive-runtime.jar;\n</code></pre> <p>There are many others ways to achieve this including adding the jar file to Hive's auxiliary classpath so it is available by default. Please refer to Hive's documentation for more information.</p>"},{"location":"hive/#enabling-support","title":"Enabling support","text":"<p>If the Iceberg storage handler is not in Hive's classpath, then Hive cannot load or update the metadata for an Iceberg table when the storage handler is set. To avoid the appearance of broken tables in Hive, Iceberg will not add the storage handler to a table unless Hive support is enabled. The storage handler is kept in sync (added or removed) every time Hive engine support for the table is updated, i.e. turned on or off in the table properties. There are two ways to enable Hive support: globally in Hadoop Configuration and per-table using a table property.</p>"},{"location":"hive/#hadoop-configuration","title":"Hadoop configuration","text":"<p>To enable Hive support globally for an application, set <code>iceberg.engine.hive.enabled=true</code> in its Hadoop configuration. For example, setting this in the <code>hive-site.xml</code> loaded by Spark will enable the storage handler for all tables created by Spark.</p> <p>Danger</p> <p>Starting with Apache Iceberg 0.11.0, when using Hive with Tez you also have to disable vectorization (hive.vectorized.execution.enabled=false).</p>"},{"location":"hive/#table-property-configuration","title":"Table property configuration","text":"<p>Alternatively, the property <code>engine.hive.enabled</code> can be set to <code>true</code> and added to the table properties when creating the Iceberg table. Here is an example of doing it programmatically:</p> <pre><code>Catalog catalog=...;\nMap&lt;String, String&gt; tableProperties=Maps.newHashMap();\ntableProperties.put(TableProperties.ENGINE_HIVE_ENABLED,\"true\"); // engine.hive.enabled=true\ncatalog.createTable(tableId,schema,spec,tableProperties);\n</code></pre> <p>The table level configuration overrides the global Hadoop configuration.</p>"},{"location":"hive/#hive-on-tez-configuration","title":"Hive on Tez configuration","text":"<p>To use the Tez engine on Hive <code>3.1.2</code> or later, Tez needs to be upgraded to &gt;= <code>0.10.1</code> which contains a necessary fix TEZ-4248.</p> <p>To use the Tez engine on Hive <code>2.3.x</code>, you will need to manually build Tez from the <code>branch-0.9</code> branch due to a backwards incompatibility issue with Tez <code>0.10.1</code>.</p> <p>In both cases, you will also need to set the following property in the <code>tez-site.xml</code> configuration file: <code>tez.mrreader.config.update.properties=hive.io.file.readcolumn.names,hive.io.file.readcolumn.ids</code>.</p>"},{"location":"hive/#catalog-management","title":"Catalog Management","text":""},{"location":"hive/#global-hive-catalog","title":"Global Hive catalog","text":"<p>From the Hive engine's perspective, there is only one global data catalog that is defined in the Hadoop configuration in the runtime environment. In contrast, Iceberg supports multiple different data catalog types such as Hive, Hadoop, AWS Glue, or custom catalog implementations. Iceberg also allows loading a table directly based on its path in the file system. Those tables do not belong to any catalog. Users might want to read these cross-catalog and path-based tables through the Hive engine for use cases like join.</p> <p>To support this, a table in the Hive metastore can represent three different ways of loading an Iceberg table, depending on the table's <code>iceberg.catalog</code> property:</p> <ol> <li>The table will be loaded using a <code>HiveCatalog</code> that corresponds to the metastore configured in the Hive environment    if no <code>iceberg.catalog</code> is set</li> <li>The table will be loaded using a custom catalog if <code>iceberg.catalog</code> is set to a catalog name (see below)</li> <li>The table can be loaded directly using the table's root location if <code>iceberg.catalog</code> is set    to <code>location_based_table</code></li> </ol> <p>For cases 2 and 3 above, users can create an overlay of an Iceberg table in the Hive metastore, so that different table types can work together in the same Hive environment. See CREATE EXTERNAL TABLE and CREATE TABLE for more details.</p>"},{"location":"hive/#custom-iceberg-catalogs","title":"Custom Iceberg catalogs","text":"<p>To globally register different catalogs, set the following Hadoop configurations:</p> Config Key Description iceberg.catalog.&lt;catalog_name&gt;.type type of catalog: <code>hive</code>, <code>hadoop</code>, or left unset if using a custom catalog iceberg.catalog.&lt;catalog_name&gt;.catalog-impl catalog implementation, must not be null if type is empty iceberg.catalog.&lt;catalog_name&gt;.&lt;key&gt; any config key and value pairs for the catalog <p>Here are some examples using Hive CLI:</p> <p>Register a <code>HiveCatalog</code> called <code>another_hive</code>:</p> <pre><code>SET iceberg.catalog.another_hive.type=hive;\nSET iceberg.catalog.another_hive.uri=thrift://example.com:9083;\nSET iceberg.catalog.another_hive.clients=10;\nSET iceberg.catalog.another_hive.warehouse=hdfs://example.com:8020/warehouse;\n</code></pre> <p>Register a <code>HadoopCatalog</code> called <code>hadoop</code>:</p> <pre><code>SET iceberg.catalog.hadoop.type=hadoop;\nSET iceberg.catalog.hadoop.warehouse=hdfs://example.com:8020/warehouse;\n</code></pre> <p>Register an AWS <code>GlueCatalog</code> called <code>glue</code>:</p> <pre><code>SET iceberg.catalog.glue.catalog-impl=org.apache.iceberg.aws.glue.GlueCatalog;\nSET iceberg.catalog.glue.warehouse=s3://my-bucket/my/key/prefix;\nSET iceberg.catalog.glue.lock.table=myGlueLockTable;\n</code></pre>"},{"location":"hive/#ddl-commands","title":"DDL Commands","text":"<p>Not all the features below are supported with Hive 2.3.x and Hive 3.1.x. Please refer to the Feature support paragraph for further details.</p> <p>One generally applicable difference is that Hive 4.0.0-alpha-1 provides the possibility to use <code>STORED BY ICEBERG</code> instead of the old <code>STORED BY 'org.apache.iceberg.mr.hive.HiveIcebergStorageHandler'</code></p>"},{"location":"hive/#create-table","title":"CREATE TABLE","text":""},{"location":"hive/#non-partitioned-tables","title":"Non partitioned tables","text":"<p>The Hive <code>CREATE EXTERNAL TABLE</code> command creates an Iceberg table when you specify the storage handler as follows:</p> <pre><code>CREATE EXTERNAL TABLE x (i int) STORED BY ICEBERG;\n</code></pre> <p>If you want to create external tables using CREATE TABLE, configure the MetaStoreMetadataTransformer on the cluster, and <code>CREATE TABLE</code> commands are transformed to create external tables. For example:</p> <pre><code>CREATE TABLE x (i int) STORED BY ICEBERG;\n</code></pre> <p>You can specify the default file format (Avro, Parquet, ORC) at the time of the table creation. The default is Parquet:</p> <pre><code>CREATE TABLE x (i int) STORED BY ICEBERG STORED AS ORC;\n</code></pre>"},{"location":"hive/#partitioned-tables","title":"Partitioned tables","text":"<p>You can create Iceberg partitioned tables using a command familiar to those who create non-Iceberg tables:</p> <pre><code>CREATE TABLE x (i int) PARTITIONED BY (j int) STORED BY ICEBERG;\n</code></pre> <p>Info</p> <p>The resulting table does not create partitions in HMS, but instead, converts partition data into Iceberg identity partitions.</p> <p>Use the DESCRIBE command to get information about the Iceberg identity partitions:</p> <p><pre><code>DESCRIBE x;\n</code></pre> The result is:</p> col_name data_type comment i int j int NULL NULL # Partition Transform Information NULL NULL # col_name transform_type NULL j IDENTITY NULL <p>You can create Iceberg partitions using the following Iceberg partition specification syntax (supported only from Hive 4.0.0-alpha-1):</p> <p><pre><code>CREATE TABLE x (i int, ts timestamp) PARTITIONED BY SPEC (month(ts), bucket(2, i)) STORED AS ICEBERG;\nDESCRIBE x;\n</code></pre> The result is:</p> col_name data_type comment i int ts timestamp NULL NULL # Partition Transform Information NULL NULL # col_name transform_type NULL ts MONTH NULL i BUCKET[2] NULL <p>The supported transformations for Hive are the same as for Spark: * years(ts): partition by year * months(ts): partition by month * days(ts) or date(ts): equivalent to dateint partitioning * hours(ts) or date_hour(ts): equivalent to dateint and hour partitioning * bucket(N, col): partition by hashed value mod N buckets * truncate(L, col): partition by value truncated to L      - Strings are truncated to the given length      - Integers and longs truncate to bins: truncate(10, i) produces partitions 0, 10, 20, 30,</p> <p>Info</p> <p>The resulting table does not create partitions in HMS, but instead, converts partition data into Iceberg partitions.</p>"},{"location":"hive/#create-table-as-select","title":"CREATE TABLE AS SELECT","text":"<p><code>CREATE TABLE AS SELECT</code> operation resembles the native Hive operation with a single important difference. The Iceberg table and the corresponding Hive table are created at the beginning of the query execution. The data is inserted / committed when the query finishes. So for a transient period the table already exists but contains no data.</p> <pre><code>CREATE TABLE target PARTITIONED BY SPEC (year(year_field), identity_field) STORED BY ICEBERG AS\nSELECT * FROM source;\n</code></pre>"},{"location":"hive/#create-table-like-table","title":"CREATE TABLE LIKE TABLE","text":"<pre><code>CREATE TABLE target LIKE source STORED BY ICEBERG;\n</code></pre>"},{"location":"hive/#create-external-table-overlaying-an-existing-iceberg-table","title":"CREATE EXTERNAL TABLE overlaying an existing Iceberg table","text":"<p>The <code>CREATE EXTERNAL TABLE</code> command is used to overlay a Hive table \"on top of\" an existing Iceberg table. Iceberg tables are created using either a <code>Catalog</code>, or an implementation of the <code>Tables</code> interface, and Hive needs to be configured accordingly to operate on these different types of table.</p>"},{"location":"hive/#hive-catalog-tables","title":"Hive catalog tables","text":"<p>As described before, tables created by the <code>HiveCatalog</code> with Hive engine feature enabled are directly visible by the Hive engine, so there is no need to create an overlay.</p>"},{"location":"hive/#custom-catalog-tables","title":"Custom catalog tables","text":"<p>For a table in a registered catalog, specify the catalog name in the statement using table property <code>iceberg.catalog</code>. For example, the SQL below creates an overlay for a table in a <code>hadoop</code> type catalog named <code>hadoop_cat</code>:</p> <pre><code>SET\niceberg.catalog.hadoop_cat.type=hadoop;\nSET\niceberg.catalog.hadoop_cat.warehouse=hdfs://example.com:8020/hadoop_cat;\nCREATE\nEXTERNAL TABLE database_a.table_a\nSTORED BY 'org.apache.iceberg.mr.hive.HiveIcebergStorageHandler'\nTBLPROPERTIES ('iceberg.catalog'='hadoop_cat');\n</code></pre> <p>When <code>iceberg.catalog</code> is missing from both table properties and the global Hadoop configuration, <code>HiveCatalog</code> will be used as default.</p>"},{"location":"hive/#path-based-hadoop-tables","title":"Path-based Hadoop tables","text":"<p>Iceberg tables created using <code>HadoopTables</code> are stored entirely in a directory in a filesystem like HDFS. These tables are considered to have no catalog. To indicate that, set <code>iceberg.catalog</code> property to <code>location_based_table</code>. For example:</p> <pre><code>CREATE\nEXTERNAL TABLE table_a STORED BY 'org.apache.iceberg.mr.hive.HiveIcebergStorageHandler' LOCATION 'hdfs://some_bucket/some_path/table_a'\nTBLPROPERTIES ('iceberg.catalog'='location_based_table');\n</code></pre>"},{"location":"hive/#create-table-overlaying-an-existing-iceberg-table","title":"CREATE TABLE overlaying an existing Iceberg table","text":"<p>You can also create a new table that is managed by a custom catalog. For example, the following code creates a table in a custom Hadoop catalog:</p> <pre><code>SET\niceberg.catalog.hadoop_cat.type=hadoop;\nSET\niceberg.catalog.hadoop_cat.warehouse=hdfs://example.com:8020/hadoop_cat;\nCREATE TABLE database_a.table_a\n(\nid   bigint,\nname string\n) PARTITIONED BY (\ndept string\n) STORED BY 'org.apache.iceberg.mr.hive.HiveIcebergStorageHandler'\nTBLPROPERTIES ('iceberg.catalog'='hadoop_cat');\n</code></pre> <p>Danger</p> <p>table. This means technically you can omit the <code>EXTERNAL</code> keyword when creating an overlay table. However, this is not recommended because creating managed overlay tables could pose a risk to the shared data files in case of accidental drop table commands from the Hive side, which would unintentionally remove all the data in the table.</p>"},{"location":"hive/#alter-table","title":"ALTER TABLE","text":""},{"location":"hive/#table-properties","title":"Table properties","text":"<p>For HiveCatalog tables the Iceberg table properties and the Hive table properties stored in HMS are kept in sync.</p> <p>Info</p> <p>IMPORTANT: This feature is not available for other Catalog implementations.</p> <pre><code>ALTER TABLE t SET TBLPROPERTIES('...'='...');\n</code></pre>"},{"location":"hive/#schema-evolution","title":"Schema evolution","text":"<p>The Hive table schema is kept in sync with the Iceberg table. If an outside source (Impala/Spark/Java API/etc) changes the schema, the Hive table immediately reflects the changes. You alter the table schema using Hive commands:</p> <ul> <li>Add a column <pre><code>ALTER TABLE orders ADD COLUMNS (nickname string);\n</code></pre></li> <li>Rename a column <pre><code>ALTER TABLE orders CHANGE COLUMN item fruit string;\n</code></pre></li> <li>Reorder columns <pre><code>ALTER TABLE orders CHANGE COLUMN quantity quantity int AFTER price;\n</code></pre></li> <li>Change a column type - only if the Iceberg defined the column type change as safe <pre><code>ALTER TABLE orders CHANGE COLUMN price price long;\n</code></pre></li> <li>Drop column by using REPLACE COLUMN to remove the old column <pre><code>ALTER TABLE orders REPLACE COLUMNS (remaining string);\n</code></pre></li> </ul> <p>Info</p> <p>Note, that dropping columns is only thing REPLACE COLUMNS can be used for i.e. if columns are specified out-of-order an error will be thrown signalling this limitation.</p>"},{"location":"hive/#partition-evolution","title":"Partition evolution","text":"<p>You change the partitioning schema using the following commands: * Change the partitioning schema to new identity partitions: <pre><code>ALTER TABLE default.customers SET PARTITION SPEC (last_name);\n</code></pre> * Alternatively, provide a partition specification: <pre><code>ALTER TABLE order SET PARTITION SPEC (month(ts));\n</code></pre></p>"},{"location":"hive/#table-migration","title":"Table migration","text":"<p>You can migrate Avro / Parquet / ORC external tables to Iceberg tables using the following command: <pre><code>ALTER TABLE t SET TBLPROPERTIES ('storage_handler'='org.apache.iceberg.mr.hive.HiveIcebergStorageHandler');\n</code></pre> During the migration the data files are not changed, only the appropriate Iceberg metadata files are created. After the migration, handle the table as a normal Iceberg table.</p>"},{"location":"hive/#truncate-table","title":"TRUNCATE TABLE","text":"<p>The following command truncates the Iceberg table: <pre><code>TRUNCATE TABLE t;\n</code></pre> Using a partition specification is not allowed.</p>"},{"location":"hive/#drop-table","title":"DROP TABLE","text":"<p>Tables can be dropped using the <code>DROP TABLE</code> command:</p> <pre><code>DROP TABLE [IF EXISTS] table_name [PURGE];\n</code></pre>"},{"location":"hive/#metadata-location","title":"METADATA LOCATION","text":"<p>The metadata location (snapshot location) only can be changed if the new path contains the exact same metadata json.  It can be done only after migrating the table to Iceberg, the two operation cannot be done in one step. </p> <pre><code>ALTER TABLE t set TBLPROPERTIES ('metadata_location'='&lt;path&gt;/hivemetadata/00003-a1ada2b8-fc86-4b5b-8c91-400b6b46d0f2.metadata.json');\n</code></pre>"},{"location":"hive/#dml-commands","title":"DML Commands","text":""},{"location":"hive/#select","title":"SELECT","text":"<p>Select statements work the same on Iceberg tables in Hive. You will see the Iceberg benefits over Hive in compilation and execution: * No file system listings - especially important on blob stores, like S3 * No partition listing from the Metastore * Advanced partition filtering - the partition keys are not needed in the queries when they could be calculated * Could handle higher number of partitions than normal Hive tables</p> <p>Here are the features highlights for Iceberg Hive read support: 1. Predicate pushdown: Pushdown of the Hive SQL <code>WHERE</code> clause has been implemented so that these filters are used at the Iceberg <code>TableScan</code> level as well as by the Parquet and ORC Readers. 2. Column projection: Columns from the Hive SQL <code>SELECT</code> clause are projected down to the Iceberg readers to reduce the number of columns read. 3. Hive query engines:    - With Hive 2.3.x, 3.1.x both the MapReduce and Tez query execution engines are supported.    - With Hive 4.0.0-alpha-1 Tez query execution engine is supported.</p> <p>Some of the advanced / little used optimizations are not yet implemented for Iceberg tables, so you should check your individual queries. Also currently the statistics stored in the MetaStore are used for query planning. This is something we are planning to improve in the future.</p>"},{"location":"hive/#insert-into","title":"INSERT INTO","text":"<p>Hive supports the standard single-table INSERT INTO operation:</p> <pre><code>INSERT INTO table_a\nVALUES ('a', 1);\nINSERT INTO table_a\nSELECT...;\n</code></pre> <p>Multi-table insert is also supported, but it will not be atomic. Commits occur one table at a time. Partial changes will be visible during the commit process and failures can leave partial changes committed. Changes within a single table will remain atomic.</p> <p>Here is an example of inserting into multiple tables at once in Hive SQL:</p> <pre><code>FROM customers\nINSERT INTO target1 SELECT customer_id, first_name\nINSERT INTO target2 SELECT last_name, customer_id;\n</code></pre>"},{"location":"hive/#insert-overwrite","title":"INSERT OVERWRITE","text":"<p>INSERT OVERWRITE can replace data in the table with the result of a query. Overwrites are atomic operations for Iceberg tables. For nonpartitioned tables the content of the table is always removed. For partitioned tables the partitions that have rows produced by the SELECT query will be replaced. <pre><code>INSERT OVERWRITE TABLE target SELECT * FROM source;\n</code></pre></p>"},{"location":"hive/#querying-metadata-tables","title":"QUERYING METADATA TABLES","text":"<p>Hive supports querying of the Iceberg Metadata tables. The tables could be used as normal Hive tables, so it is possible to use projections / joins / filters / etc. To reference a metadata table the full name of the table should be used, like: ... <p>Currently the following metadata tables are available in Hive: * files * entries * snapshots * manifests * partitions</p> <pre><code>SELECT * FROM default.table_a.files;\n</code></pre>"},{"location":"hive/#timetravel","title":"TIMETRAVEL","text":"<p>Hive supports snapshot id based and time base timetravel queries. For these views it is possible to use projections / joins / filters / etc. The function is available with the following syntax: <pre><code>SELECT * FROM table_a FOR SYSTEM_TIME AS OF '2021-08-09 10:35:57';\nSELECT * FROM table_a FOR SYSTEM_VERSION AS OF 1234567;\n</code></pre></p> <p>You can expire snapshots of an Iceberg table using an ALTER TABLE query from Hive. You should periodically expire snapshots to delete data files that is no longer needed, and reduce the size of table metadata.</p> <p>Each write to an Iceberg table from Hive creates a new snapshot, or version, of a table. Snapshots can be used for time-travel queries, or the table can be rolled back to any valid snapshot. Snapshots accumulate until they are expired by the expire_snapshots operation. Enter a query to expire snapshots having the following timestamp: <code>2021-12-09 05:39:18.689000000</code> <pre><code>ALTER TABLE test_table EXECUTE expire_snapshots('2021-12-09 05:39:18.689000000');\n</code></pre></p>"},{"location":"hive/#type-compatibility","title":"Type compatibility","text":"<p>Hive and Iceberg support different set of types. Iceberg can perform type conversion automatically, but not for all combinations, so you may want to understand the type conversion in Iceberg in prior to design the types of columns in your tables. You can enable auto-conversion through Hadoop configuration (not enabled by default):</p> Config key Default Description iceberg.mr.schema.auto.conversion false if Hive should perform type auto-conversion"},{"location":"hive/#hive-type-to-iceberg-type","title":"Hive type to Iceberg type","text":"<p>This type conversion table describes how Hive types are converted to the Iceberg types. The conversion applies on both creating Iceberg table and writing to Iceberg table via Hive.</p> Hive Iceberg Notes boolean boolean short integer auto-conversion byte integer auto-conversion integer integer long long float float double double date date timestamp timestamp without timezone timestamplocaltz timestamp with timezone Hive 3 only interval_year_month not supported interval_day_time not supported char string auto-conversion varchar string auto-conversion string string binary binary decimal decimal struct struct list list map map union not supported"},{"location":"hive/#table-rollback","title":"Table rollback","text":"<p>Rolling back iceberg table's data to the state at an older table snapshot.</p> <p>Rollback to the last snapshot before a specific timestamp</p> <pre><code>ALTER TABLE ice_t EXECUTE ROLLBACK('2022-05-12 00:00:00')\n</code></pre> <p>Rollback to a specific snapshot ID <pre><code>ALTER TABLE ice_t EXECUTE ROLLBACK(1111);\n</code></pre></p>"},{"location":"java-api-quickstart/","title":"Java Quickstart","text":""},{"location":"java-api-quickstart/#java-api-quickstart","title":"Java API Quickstart","text":""},{"location":"java-api-quickstart/#create-a-table","title":"Create a table","text":"<p>Tables are created using either a <code>Catalog</code> or an implementation of the <code>Tables</code> interface.</p>"},{"location":"java-api-quickstart/#using-a-hive-catalog","title":"Using a Hive catalog","text":"<p>The Hive catalog connects to a Hive metastore to keep track of Iceberg tables. You can initialize a Hive catalog with a name and some properties. (see: Catalog properties)</p> <p>Note: Currently, <code>setConf</code> is always required for hive catalogs, but this will change in the future.</p> <pre><code>import org.apache.iceberg.hive.HiveCatalog;\nHiveCatalog catalog = new HiveCatalog();\ncatalog.setConf(spark.sparkContext().hadoopConfiguration());  // Configure using Spark's Hadoop configuration\nMap &lt;String, String&gt; properties = new HashMap&lt;String, String&gt;();\nproperties.put(\"warehouse\", \"...\");\nproperties.put(\"uri\", \"...\");\ncatalog.initialize(\"hive\", properties);\n</code></pre> <p>The <code>Catalog</code> interface defines methods for working with tables, like <code>createTable</code>, <code>loadTable</code>, <code>renameTable</code>, and <code>dropTable</code>. <code>HiveCatalog</code> implements the <code>Catalog</code> interface.</p> <p>To create a table, pass an <code>Identifier</code> and a <code>Schema</code> along with other initial metadata:</p> <pre><code>import org.apache.iceberg.Table;\nimport org.apache.iceberg.catalog.TableIdentifier;\nTableIdentifier name = TableIdentifier.of(\"logging\", \"logs\");\nTable table = catalog.createTable(name, schema, spec);\n// or to load an existing table, use the following line\n// Table table = catalog.loadTable(name);\n</code></pre> <p>The logs schema and partition spec are created below.</p>"},{"location":"java-api-quickstart/#using-a-hadoop-catalog","title":"Using a Hadoop catalog","text":"<p>A Hadoop catalog doesn't need to connect to a Hive MetaStore, but can only be used with HDFS or similar file systems that support atomic rename. Concurrent writes with a Hadoop catalog are not safe with a local FS or S3. To create a Hadoop catalog:</p> <pre><code>import org.apache.hadoop.conf.Configuration;\nimport org.apache.iceberg.hadoop.HadoopCatalog;\nConfiguration conf = new Configuration();\nString warehousePath = \"hdfs://host:8020/warehouse_path\";\nHadoopCatalog catalog = new HadoopCatalog(conf, warehousePath);\n</code></pre> <p>Like the Hive catalog, <code>HadoopCatalog</code> implements <code>Catalog</code>, so it also has methods for working with tables, like <code>createTable</code>, <code>loadTable</code>, and <code>dropTable</code>.</p> <p>This example creates a table with Hadoop catalog:</p> <pre><code>import org.apache.iceberg.Table;\nimport org.apache.iceberg.catalog.TableIdentifier;\nTableIdentifier name = TableIdentifier.of(\"logging\", \"logs\");\nTable table = catalog.createTable(name, schema, spec);\n// or to load an existing table, use the following line\n// Table table = catalog.loadTable(name);\n</code></pre> <p>The logs schema and partition spec are created below.</p>"},{"location":"java-api-quickstart/#using-hadoop-tables","title":"Using Hadoop tables","text":"<p>Iceberg also supports tables that are stored in a directory in HDFS. Concurrent writes with a Hadoop tables are not safe when stored in the local FS or S3. Directory tables don't support all catalog operations, like rename, so they use the <code>Tables</code> interface instead of <code>Catalog</code>.</p> <p>To create a table in HDFS, use <code>HadoopTables</code>:</p> <pre><code>import org.apache.hadoop.conf.Configuration;\nimport org.apache.iceberg.hadoop.HadoopTables;\nimport org.apache.iceberg.Table;\nConfiguration conf = new Configuration();\nHadoopTables tables = new HadoopTables(conf);\nTable table = tables.create(schema, spec, table_location);\n// or to load an existing table, use the following line\n// Table table = tables.load(table_location);\n</code></pre> <p>Danger</p> <p>Hadoop tables shouldn't be used with file systems that do not support atomic rename. Iceberg relies on rename to synchronize concurrent commits for directory tables.</p>"},{"location":"java-api-quickstart/#tables-in-spark","title":"Tables in Spark","text":"<p>Spark uses both <code>HiveCatalog</code> and <code>HadoopTables</code> to load tables. Hive is used when the identifier passed to <code>load</code> or <code>save</code> is not a path, otherwise Spark assumes it is a path-based table.</p> <p>To read and write to tables from Spark see:</p> <ul> <li>SQL queries in Spark</li> <li><code>INSERT INTO</code> in Spark</li> <li><code>MERGE INTO</code> in Spark</li> </ul>"},{"location":"java-api-quickstart/#schemas","title":"Schemas","text":""},{"location":"java-api-quickstart/#create-a-schema","title":"Create a schema","text":"<p>This example creates a schema for a <code>logs</code> table:</p> <pre><code>import org.apache.iceberg.Schema;\nimport org.apache.iceberg.types.Types;\nSchema schema = new Schema(\nTypes.NestedField.required(1, \"level\", Types.StringType.get()),\nTypes.NestedField.required(2, \"event_time\", Types.TimestampType.withZone()),\nTypes.NestedField.required(3, \"message\", Types.StringType.get()),\nTypes.NestedField.optional(4, \"call_stack\", Types.ListType.ofRequired(5, Types.StringType.get()))\n);\n</code></pre> <p>When using the Iceberg API directly, type IDs are required. Conversions from other schema formats, like Spark, Avro, and Parquet will automatically assign new IDs.</p> <p>When a table is created, all IDs in the schema are re-assigned to ensure uniqueness.</p>"},{"location":"java-api-quickstart/#convert-a-schema-from-avro","title":"Convert a schema from Avro","text":"<p>To create an Iceberg schema from an existing Avro schema, use converters in <code>AvroSchemaUtil</code>:</p> <pre><code>import org.apache.avro.Schema;\nimport org.apache.avro.Schema.Parser;\nimport org.apache.iceberg.avro.AvroSchemaUtil;\nSchema avroSchema = new Parser().parse(\"{\\\"type\\\": \\\"record\\\" , ... }\");\nSchema icebergSchema = AvroSchemaUtil.toIceberg(avroSchema);\n</code></pre>"},{"location":"java-api-quickstart/#convert-a-schema-from-spark","title":"Convert a schema from Spark","text":"<p>To create an Iceberg schema from an existing table, use converters in <code>SparkSchemaUtil</code>:</p> <pre><code>import org.apache.iceberg.spark.SparkSchemaUtil;\nSchema schema = SparkSchemaUtil.schemaForTable(sparkSession, table_name);\n</code></pre>"},{"location":"java-api-quickstart/#partitioning","title":"Partitioning","text":""},{"location":"java-api-quickstart/#create-a-partition-spec","title":"Create a partition spec","text":"<p>Partition specs describe how Iceberg should group records into data files. Partition specs are created for a table's schema using a builder.</p> <p>This example creates a partition spec for the <code>logs</code> table that partitions records by the hour of the log event's timestamp and by log level:</p> <pre><code>import org.apache.iceberg.PartitionSpec;\nPartitionSpec spec = PartitionSpec.builderFor(schema)\n.hour(\"event_time\")\n.identity(\"level\")\n.build();\n</code></pre> <p>For more information on the different partition transforms that Iceberg offers, visit this page.</p>"},{"location":"java-api-quickstart/#branching-and-tagging","title":"Branching and Tagging","text":""},{"location":"java-api-quickstart/#creating-branches-and-tags","title":"Creating branches and tags","text":"<p>New branches and tags can be created via the Java library's ManageSnapshots API. </p> <pre><code>/* Create a branch test-branch which is retained for 1 week, and the latest 2 snapshots on test-branch will always be retained. \nSnapshots on test-branch which are created within the last hour will also be retained. */\nString branch = \"test-branch\";\ntable.manageSnapshots()\n.createBranch(branch, 3)\n.setMinSnapshotsToKeep(branch, 2)\n.setMaxSnapshotAgeMs(branch, 3600000)\n.setMaxRefAgeMs(branch, 604800000)\n.commit();\n// Create a tag historical-tag at snapshot 10 which is retained for a day\nString tag = \"historical-tag\"\ntable.manageSnapshots()\n.createTag(tag, 10)\n.setMaxRefAgeMs(tag, 86400000)\n.commit();\n</code></pre>"},{"location":"java-api-quickstart/#committing-to-branches","title":"Committing to branches","text":"<p>Writing to a branch can be performed by specifying <code>toBranch</code> in the operation. For the full list refer to UpdateOperations.  <pre><code>// Append FILE_A to branch test-branch \nString branch = \"test-branch\";\ntable.newAppend()\n.appendFile(FILE_A)\n.toBranch(branch)\n.commit();\n// Perform row level updates on \"test-branch\"\ntable.newRowDelta()\n.addRows(DATA_FILE)\n.addDeletes(DELETES)\n.toBranch(branch)\n.commit();\n// Perform a rewrite operation replacing small_file_1 and small_file_2 on \"test-branch\" with compacted_file.\ntable.newRewrite()\n.rewriteFiles(ImmutableSet.of(small_file_1,small_file_2), ImmutableSet.of(compacted_file))\n.toBranch(branch)\n.commit();\n</code></pre></p>"},{"location":"java-api-quickstart/#reading-from-branches-and-tags","title":"Reading from branches and tags","text":"<p>Reading from a branch or tag can be done as usual via the Table Scan API, by passing in a branch or tag in the <code>useRef</code> API. When a branch is passed in, the snapshot that's used is the head of the branch. Note that currently reading from a branch and specifying an <code>asOfSnapshotId</code> in the scan is not supported. </p> <pre><code>// Read from the head snapshot of test-branch\nTableScan branchRead = table.newScan().useRef(\"test-branch\");\n// Read from the snapshot referenced by audit-tag\nTable tagRead = table.newScan().useRef(\"audit-tag\");\n</code></pre>"},{"location":"java-api-quickstart/#replacing-and-fast-forwarding-branches-and-tags","title":"Replacing and fast forwarding branches and tags","text":"<p>The snapshots which existing branches and tags point to can be updated via the <code>replace</code> APIs. The fast forward operation is similar to git fast-forwarding. Fast forward can be used to advance a target branch to the head of a source branch or a tag when the target branch is an ancestor of the source. For both fast forward and replace, retention properties of the target branch are maintained by default.</p> <pre><code>// Update \"test-branch\" to point to snapshot 4\ntable.manageSnapshots()\n.replaceBranch(branch, 4)\n.commit()\nString tag = \"audit-tag\";\n// Replace \"audit-tag\" to point to snapshot 3 and update its retention\ntable.manageSnapshots()\n.replaceBranch(tag, 4)\n.setMaxRefAgeMs(1000)\n.commit()\n</code></pre>"},{"location":"java-api-quickstart/#updating-retention-properties","title":"Updating retention properties","text":"<p>Retention properties for branches and tags can be updated as well. Use the setMaxRefAgeMs for updating the retention property of the branch or tag itself. Branch snapshot retention properties can be updated via the <code>setMinSnapshotsToKeep</code> and <code>setMaxSnapshotAgeMs</code> APIs. </p> <pre><code>String branch = \"test-branch\";\n// Update retention properties for test-branch\ntable.manageSnapshots()\n.setMinSnapshotsToKeep(branch, 10)\n.setMaxSnapshotAgeMs(branch, 7200000)\n.setMaxRefAgeMs(branch, 604800000)\n.commit();\n// Update retention properties for test-tag\ntable.manageSnapshots()\n.setMaxRefAgeMs(\"test-tag\", 604800000)\n.commit();\n</code></pre>"},{"location":"java-api-quickstart/#removing-branches-and-tags","title":"Removing branches and tags","text":"<p>Branches and tags can be removed via the <code>removeBranch</code> and <code>removeTag</code> APIs respectively</p> <pre><code>// Remove test-branch\ntable.manageSnapshots()\n.removeBranch(\"test-branch\")\n.commit()\n// Remove test-tag\ntable.manageSnapshots()\n.removeTag(\"test-tag\")\n.commit()\n</code></pre>"},{"location":"jdbc/","title":"JDBC","text":""},{"location":"jdbc/#iceberg-jdbc-integration","title":"Iceberg JDBC Integration","text":""},{"location":"jdbc/#jdbc-catalog","title":"JDBC Catalog","text":"<p>Iceberg supports using a table in a relational database to manage Iceberg tables through JDBC. The database that JDBC connects to must support atomic transaction to allow the JDBC catalog implementation to  properly support atomic Iceberg table commits and read serializable isolation.</p>"},{"location":"jdbc/#configurations","title":"Configurations","text":"<p>Because each database and database service provider might require different configurations, the JDBC catalog allows arbitrary configurations through:</p> Property Default Description uri the JDBC connection string jdbc.&lt;property_key&gt; any key value pairs to configure the JDBC connection"},{"location":"jdbc/#examples","title":"Examples","text":""},{"location":"jdbc/#spark","title":"Spark","text":"<p>You can start a Spark session with a MySQL JDBC connection using the following configurations:</p> <pre><code>spark-sql --packages org.apache.iceberg:iceberg-spark-runtime-3.2_2.12:{{ icebergVersion }} \\\n--conf spark.sql.catalog.my_catalog=org.apache.iceberg.spark.SparkCatalog \\\n--conf spark.sql.catalog.my_catalog.warehouse=s3://my-bucket/my/key/prefix \\\n--conf spark.sql.catalog.my_catalog.catalog-impl=org.apache.iceberg.jdbc.JdbcCatalog \\\n--conf spark.sql.catalog.my_catalog.uri=jdbc:mysql://test.1234567890.us-west-2.rds.amazonaws.com:3306/default \\\n--conf spark.sql.catalog.my_catalog.jdbc.verifyServerCertificate=true \\\n--conf spark.sql.catalog.my_catalog.jdbc.useSSL=true \\\n--conf spark.sql.catalog.my_catalog.jdbc.user=admin \\\n--conf spark.sql.catalog.my_catalog.jdbc.password=pass\n</code></pre>"},{"location":"jdbc/#java-api","title":"Java API","text":"<pre><code>Class.forName(\"com.mysql.cj.jdbc.Driver\"); // ensure JDBC driver is at runtime classpath\nMap&lt;String, String&gt; properties = new HashMap&lt;&gt;();\nproperties.put(CatalogProperties.CATALOG_IMPL, JdbcCatalog.class.getName());\nproperties.put(CatalogProperties.URI, \"jdbc:mysql://localhost:3306/test\");\nproperties.put(JdbcCatalog.PROPERTY_PREFIX + \"user\", \"admin\");\nproperties.put(JdbcCatalog.PROPERTY_PREFIX + \"password\", \"pass\");\nproperties.put(CatalogProperties.WAREHOUSE_LOCATION, \"s3://warehouse/path\");\nConfiguration hadoopConf = new Configuration(); // configs if you use HadoopFileIO\nJdbcCatalog catalog = CatalogUtil.buildIcebergCatalog(\"test_jdbc_catalog\", properties, hadoopConf);\n</code></pre>"},{"location":"maintenance/","title":"Maintenance","text":""},{"location":"maintenance/#maintenance","title":"Maintenance","text":"<p>Info</p> <p>Maintenance operations require the <code>Table</code> instance. Please refer Java API quickstart page to refer how to load an existing table.</p>"},{"location":"maintenance/#recommended-maintenance","title":"Recommended Maintenance","text":""},{"location":"maintenance/#expire-snapshots","title":"Expire Snapshots","text":"<p>Each write to an Iceberg table creates a new snapshot, or version, of a table. Snapshots can be used for time-travel queries, or the table can be rolled back to any valid snapshot.</p> <p>Snapshots accumulate until they are expired by the <code>expireSnapshots</code> operation. Regularly expiring snapshots is recommended to delete data files that are no longer needed, and to keep the size of table metadata small.</p> <p>This example expires snapshots that are older than 1 day:</p> <pre><code>Table table = ...\nlong tsToExpire = System.currentTimeMillis() - (1000 * 60 * 60 * 24); // 1 day\ntable.expireSnapshots()\n.expireOlderThan(tsToExpire)\n.commit();\n</code></pre> <p>See the <code>ExpireSnapshots</code> Javadoc to see more configuration options.</p> <p>There is also a Spark action that can run table expiration in parallel for large tables:</p> <pre><code>Table table = ...\nSparkActions\n.get()\n.expireSnapshots(table)\n.expireOlderThan(tsToExpire)\n.execute();\n</code></pre> <p>Expiring old snapshots removes them from metadata, so they are no longer available for time travel queries.</p> <p>Info</p> <p>Data files are not deleted until they are no longer referenced by a snapshot that may be used for time travel or rollback. Regularly expiring snapshots deletes unused data files.</p>"},{"location":"maintenance/#remove-old-metadata-files","title":"Remove old metadata files","text":"<p>Iceberg keeps track of table metadata using JSON files. Each change to a table produces a new metadata file to provide atomicity.</p> <p>Old metadata files are kept for history by default. Tables with frequent commits, like those written by streaming jobs, may need to regularly clean metadata files.</p> <p>To automatically clean metadata files, set <code>write.metadata.delete-after-commit.enabled=true</code> in table properties. This will keep some metadata files (up to <code>write.metadata.previous-versions-max</code>) and will delete the oldest metadata file after each new one is created.</p> Property Description <code>write.metadata.delete-after-commit.enabled</code> Whether to delete old tracked metadata files after each table commit <code>write.metadata.previous-versions-max</code> The number of old metadata files to keep <p>Note that this will only delete metadata files that are tracked in the metadata log and will not delete orphaned metadata files. Example: With <code>write.metadata.delete-after-commit.enabled=false</code> and <code>write.metadata.previous-versions-max=10</code>, one will have 10 tracked metadata files and 90 orphaned metadata files after 100 commits. Configuring <code>write.metadata.delete-after-commit.enabled=true</code> and <code>write.metadata.previous-versions-max=20</code> will not automatically delete metadata files. Tracked metadata files would be deleted again when reaching <code>write.metadata.previous-versions-max=20</code>.</p> <p>See table write properties for more details.</p>"},{"location":"maintenance/#delete-orphan-files","title":"Delete orphan files","text":"<p>In Spark and other distributed processing engines, task or job failures can leave files that are not referenced by table metadata, and in some cases normal snapshot expiration may not be able to determine a file is no longer needed and delete it.</p> <p>To clean up these \"orphan\" files under a table location, use the <code>deleteOrphanFiles</code> action.</p> <pre><code>Table table = ...\nSparkActions\n.get()\n.deleteOrphanFiles(table)\n.execute();\n</code></pre> <p>See the DeleteOrphanFiles Javadoc to see more configuration options.</p> <p>This action may take a long time to finish if you have lots of files in data and metadata directories. It is recommended to execute this periodically, but you may not need to execute this often.</p> <p>Info</p> <p>It is dangerous to remove orphan files with a retention interval shorter than the time expected for any write to complete because it might corrupt the table if in-progress files are considered orphaned and are deleted. The default interval is 3 days.</p> <p>Info</p> <p>Iceberg uses the string representations of paths when determining which files need to be removed. On some file systems, the path can change over time, but it still represents the same file. For example, if you change authorities for an HDFS cluster,  none of the old path urls used during creation will match those that appear in a current listing. This will lead to data loss when  RemoveOrphanFiles is run. Please be sure the entries in your MetadataTables match those listed by the Hadoop FileSystem API to avoid unintentional deletion. </p>"},{"location":"maintenance/#optional-maintenance","title":"Optional Maintenance","text":"<p>Some tables require additional maintenance. For example, streaming queries may produce small data files that should be compacted into larger files. And some tables can benefit from rewriting manifest files to make locating data for queries much faster.</p>"},{"location":"maintenance/#compact-data-files","title":"Compact data files","text":"<p>Iceberg tracks each data file in a table. More data files leads to more metadata stored in manifest files, and small data files causes an unnecessary amount of metadata and less efficient queries from file open costs.</p> <p>Iceberg can compact data files in parallel using Spark with the <code>rewriteDataFiles</code> action. This will combine small files into larger files to reduce metadata overhead and runtime file open cost.</p> <pre><code>Table table = ...\nSparkActions\n.get()\n.rewriteDataFiles(table)\n.filter(Expressions.equal(\"date\", \"2020-08-18\"))\n.option(\"target-file-size-bytes\", Long.toString(500 * 1024 * 1024)) // 500 MB\n.execute();\n</code></pre> <p>The <code>files</code> metadata table is useful for inspecting data file sizes and determining when to compact partitions.</p> <p>See the <code>RewriteDataFiles</code> Javadoc to see more configuration options.</p>"},{"location":"maintenance/#rewrite-manifests","title":"Rewrite manifests","text":"<p>Iceberg uses metadata in its manifest list and manifest files speed up query planning and to prune unnecessary data files. The metadata tree functions as an index over a table's data.</p> <p>Manifests in the metadata tree are automatically compacted in the order they are added, which makes queries faster when the write pattern aligns with read filters. For example, writing hourly-partitioned data as it arrives is aligned with time range query filters.</p> <p>When a table's write pattern doesn't align with the query pattern, metadata can be rewritten to re-group data files into manifests using <code>rewriteManifests</code> or the <code>rewriteManifests</code> action (for parallel rewrites using Spark).</p> <p>This example rewrites small manifests and groups data files by the first partition field.</p> <pre><code>Table table = ...\nSparkActions\n.get()\n.rewriteManifests(table)\n.rewriteIf(file -&gt; file.length() &lt; 10 * 1024 * 1024) // 10 MB\n.execute();\n</code></pre> <p>See the <code>RewriteManifests</code> Javadoc to see more configuration options.</p>"},{"location":"nessie/","title":"Nessie","text":""},{"location":"nessie/#iceberg-nessie-integration","title":"Iceberg Nessie Integration","text":"<p>Iceberg provides integration with Nessie through the <code>iceberg-nessie</code> module. This section describes how to use Iceberg with Nessie. Nessie provides several key features on top of Iceberg:</p> <ul> <li>multi-table transactions</li> <li>git-like operations (eg branches, tags, commits)</li> <li>hive-like metastore capabilities</li> </ul> <p>See Project Nessie for more information on Nessie. Nessie requires a server to run, see Getting Started to start a Nessie server.</p>"},{"location":"nessie/#enabling-nessie-catalog","title":"Enabling Nessie Catalog","text":"<p>The <code>iceberg-nessie</code> module is bundled with Spark and Flink runtimes for all versions from <code>0.11.0</code>. To get started with Nessie (with spark-3.3) and Iceberg simply add the Iceberg runtime to your process. Eg: <code>spark-sql --packages org.apache.iceberg:iceberg-spark-runtime-3.3_2.12:{{ icebergVersion }}</code>. </p>"},{"location":"nessie/#spark-sql-extensions","title":"Spark SQL Extensions","text":"<p>From Spark 3.1 and above, Nessie SQL extensions can be used to manage the Nessie repo as shown below. Example for Spark 3.3 with scala 2.12:</p> <p><pre><code>bin/spark-sql \n  --packages \"org.apache.iceberg:iceberg-spark-runtime-3.3_2.12:{{ icebergVersion }},org.projectnessie.nessie-integrations:nessie-spark-extensions-3.3_2.12:{{ nessieVersion }}\"\n  --conf spark.sql.extensions=\"org.apache.iceberg.spark.extensions.IcebergSparkSessionExtensions,org.projectnessie.spark.extensions.NessieSparkSessionExtensions\"\n  --conf &lt;other settings&gt;\n</code></pre> Please refer Nessie SQL extension document to learn more about it.</p>"},{"location":"nessie/#nessie-catalog","title":"Nessie Catalog","text":"<p>One major feature introduced in release <code>0.11.0</code> is the ability to easily interact with a Custom Catalog from Spark and Flink. See Spark Configuration   and Flink Configuration for instructions for adding a custom catalog to Iceberg. </p> <p>To use the Nessie Catalog the following properties are required:</p> <ul> <li><code>warehouse</code>. Like most other catalogs the warehouse property is a file path to where this catalog should store tables.</li> <li><code>uri</code>. This is the Nessie server base uri. Eg <code>http://localhost:19120/api/v1</code>.</li> <li><code>ref</code> (optional). This is the Nessie branch or tag you want to work in.</li> </ul> <p>To run directly in Java this looks like:</p> <pre><code>Map&lt;String, String&gt; options = new HashMap&lt;&gt;();\noptions.put(\"warehouse\", \"/path/to/warehouse\");\noptions.put(\"ref\", \"main\");\noptions.put(\"uri\", \"https://localhost:19120/api/v1\");\nCatalog nessieCatalog = CatalogUtil.loadCatalog(\"org.apache.iceberg.nessie.NessieCatalog\", \"nessie\", options, hadoopConfig);\n</code></pre> <p>and in Spark:</p> <p><pre><code>conf.set(\"spark.sql.catalog.nessie.warehouse\", \"/path/to/warehouse\");\nconf.set(\"spark.sql.catalog.nessie.uri\", \"http://localhost:19120/api/v1\")\nconf.set(\"spark.sql.catalog.nessie.ref\", \"main\")\nconf.set(\"spark.sql.catalog.nessie.catalog-impl\", \"org.apache.iceberg.nessie.NessieCatalog\")\nconf.set(\"spark.sql.catalog.nessie\", \"org.apache.iceberg.spark.SparkCatalog\")\nconf.set(\"spark.sql.extensions\", \"org.apache.iceberg.spark.extensions.IcebergSparkSessionExtensions,org.projectnessie.spark.extensions.NessieSparkSessionExtensions\")\n</code></pre> This is how it looks in Flink via the Python API (additional details can be found here): <pre><code>import os\nfrom pyflink.datastream import StreamExecutionEnvironment\nfrom pyflink.table import StreamTableEnvironment\nenv = StreamExecutionEnvironment.get_execution_environment()\niceberg_flink_runtime_jar = os.path.join(os.getcwd(), \"iceberg-flink-runtime-{{ icebergVersion }}.jar\")\nenv.add_jars(\"file://{}\".format(iceberg_flink_runtime_jar))\ntable_env = StreamTableEnvironment.create(env)\ntable_env.execute_sql(\"CREATE CATALOG nessie_catalog WITH (\"\n\"'type'='iceberg', \"\n\"'catalog-impl'='org.apache.iceberg.nessie.NessieCatalog', \"\n\"'uri'='http://localhost:19120/api/v1', \"\n\"'ref'='main', \"\n\"'warehouse'='/path/to/warehouse')\")\n</code></pre></p> <p>There is nothing special above about the <code>nessie</code> name. A spark catalog can have any name, the important parts are the  settings for the <code>catalog-impl</code> and the required config to start Nessie correctly. Once you have a Nessie catalog you have access to your entire Nessie repo. You can then perform create/delete/merge operations on branches and perform commits on branches. Each Iceberg table in a Nessie Catalog is identified by an arbitrary length namespace and table name (eg <code>data.base.name.table</code>). These namespaces are implicit and don't need to be created separately. Any transaction on a Nessie enabled Iceberg table is a single commit in Nessie. Nessie commits can encompass an arbitrary number of actions on an arbitrary number of tables, however in Iceberg this will be limited to the set of single table transactions currently available.</p> <p>Further operations such as merges, viewing the commit log or diffs are performed by direct interaction with the <code>NessieClient</code> in java or by using the python client or cli. See Nessie CLI for more details on the CLI and Spark Guide for a more complete description of  Nessie functionality.</p>"},{"location":"nessie/#nessie-and-iceberg","title":"Nessie and Iceberg","text":"<p>For most cases Nessie acts just like any other Catalog for Iceberg: providing a logical organization of a set of tables and providing atomicity to transactions. However, using Nessie opens up other interesting possibilities. When using Nessie with Iceberg every Iceberg transaction becomes a Nessie commit. This history can be listed, merged or cherry-picked across branches.</p>"},{"location":"nessie/#loosely-coupled-transactions","title":"Loosely coupled transactions","text":"<p>By creating a branch and performing a set of operations on that branch you can approximate a multi-table transaction. A sequence of commits can be performed on the newly created branch and then merged back into the main branch atomically. This gives the appearance of a series of connected changes being exposed to the main branch simultaneously. While downstream consumers will see multiple transactions appear at once this isn't a true multi-table transaction on the database. It is  effectively a fast-forward merge of multiple commits (in git language) and each operation from the branch is its own distinct transaction and commit. This is different from a real multi-table transaction where all changes would be in the same commit. This does allow multiple applications to take part in modifying a branch and for this distributed set of transactions to be  exposed to the downstream users simultaneously.</p>"},{"location":"nessie/#experimentation","title":"Experimentation","text":"<p>Changes to a table can be tested in a branch before merging back into main. This is particularly useful when performing large changes like schema evolution or partition evolution. A partition evolution could be performed in a branch and you would be able to test out the change (eg performance benchmarks) before merging it. This provides great flexibility in performing on-line table modifications and testing without interrupting downstream use cases. If the changes are incorrect or not performant the branch can be dropped without being merged.</p>"},{"location":"nessie/#further-use-cases","title":"Further use cases","text":"<p>Please see the Nessie Documentation for further descriptions of  Nessie features.</p> <p>Danger</p> <p>Regular table maintenance in Iceberg is complicated when using nessie. Please consult Management Services before performing any  table maintenance.</p>"},{"location":"nessie/#example","title":"Example","text":"<p>Please have a look at the Nessie Demos repo for different examples of Nessie and Iceberg in action together.</p>"},{"location":"nessie/#future-improvements","title":"Future Improvements","text":"<ul> <li>Iceberg multi-table transactions. Changes to multiple Iceberg tables in the same transaction, isolation levels etc</li> </ul>"},{"location":"partitioning/","title":"Partitioning","text":""},{"location":"partitioning/#partitioning","title":"Partitioning","text":""},{"location":"partitioning/#what-is-partitioning","title":"What is partitioning?","text":"<p>Partitioning is a way to make queries faster by grouping similar rows together when writing.</p> <p>For example, queries for log entries from a <code>logs</code> table would usually include a time range, like this query for logs between 10 and 12 AM:</p> <pre><code>SELECT level, message FROM logs\nWHERE event_time BETWEEN '2018-12-01 10:00:00' AND '2018-12-01 12:00:00'\n</code></pre> <p>Configuring the <code>logs</code> table to partition by the date of <code>event_time</code> will group log events into files with the same event date. Iceberg keeps track of that date and will use it to skip files for other dates that don't have useful data.</p> <p>Iceberg can partition timestamps by year, month, day, and hour granularity. It can also use a categorical column, like <code>level</code> in this logs example, to store rows together and speed up queries.</p>"},{"location":"partitioning/#what-does-iceberg-do-differently","title":"What does Iceberg do differently?","text":"<p>Other tables formats like Hive support partitioning, but Iceberg supports hidden partitioning.</p> <ul> <li>Iceberg handles the tedious and error-prone task of producing partition values for rows in a table.</li> <li>Iceberg avoids reading unnecessary partitions automatically. Consumers don't need to know how the table is partitioned and add extra filters to their queries.</li> <li>Iceberg partition layouts can evolve as needed.</li> </ul>"},{"location":"partitioning/#partitioning-in-hive","title":"Partitioning in Hive","text":"<p>To demonstrate the difference, consider how Hive would handle a <code>logs</code> table.</p> <p>In Hive, partitions are explicit and appear as a column, so the <code>logs</code> table would have a column called <code>event_date</code>. When writing, an insert needs to supply the data for the <code>event_date</code> column:</p> <pre><code>INSERT INTO logs PARTITION (event_date)\nSELECT level, message, event_time, format_time(event_time, 'YYYY-MM-dd')\nFROM unstructured_log_source\n</code></pre> <p>Similarly, queries that search through the <code>logs</code> table must have an <code>event_date</code> filter in addition to an <code>event_time</code> filter.</p> <pre><code>SELECT level, count(1) as count FROM logs\nWHERE event_time BETWEEN '2018-12-01 10:00:00' AND '2018-12-01 12:00:00'\nAND event_date = '2018-12-01'\n</code></pre> <p>If the <code>event_date</code> filter were missing, Hive would scan through every file in the table because it doesn't know that the <code>event_time</code> column is related to the <code>event_date</code> column.</p>"},{"location":"partitioning/#problems-with-hive-partitioning","title":"Problems with Hive partitioning","text":"<p>Hive must be given partition values. In the logs example, it doesn't know the relationship between <code>event_time</code> and <code>event_date</code>.</p> <p>This leads to several problems:</p> <ul> <li>Hive can't validate partition values -- it is up to the writer to produce the correct value<ul> <li>Using the wrong format, <code>2018-12-01</code> instead of <code>20181201</code>, produces silently incorrect results, not query failures</li> <li>Using the wrong source column, like <code>processing_time</code>, or time zone also causes incorrect results, not failures</li> </ul> </li> <li>It is up to the user to write queries correctly<ul> <li>Using the wrong format also leads to silently incorrect results</li> <li>Users that don't understand a table's physical layout get needlessly slow queries -- Hive can't translate filters automatically</li> </ul> </li> <li>Working queries are tied to the table's partitioning scheme, so partitioning configuration cannot be changed without breaking queries</li> </ul>"},{"location":"partitioning/#icebergs-hidden-partitioning","title":"Iceberg's hidden partitioning","text":"<p>Iceberg produces partition values by taking a column value and optionally transforming it. Iceberg is responsible for converting <code>event_time</code> into <code>event_date</code>, and keeps track of the relationship.</p> <p>Table partitioning is configured using these relationships. The <code>logs</code> table would be partitioned by <code>date(event_time)</code> and <code>level</code>.</p> <p>Because Iceberg doesn't require user-maintained partition columns, it can hide partitioning. Partition values are produced correctly every time and always used to speed up queries, when possible. Producers and consumers wouldn't even see <code>event_date</code>.</p> <p>Most importantly, queries no longer depend on a table's physical layout. With a separation between physical and logical, Iceberg tables can evolve partition schemes over time as data volume changes. Misconfigured tables can be fixed without an expensive migration.</p> <p>For details about all the supported hidden partition transformations, see the Partition Transforms section.</p> <p>For details about updating a table's partition spec, see the partition evolution section.</p>"},{"location":"performance/","title":"Performance","text":""},{"location":"performance/#performance","title":"Performance","text":"<ul> <li>Iceberg is designed for huge tables and is used in production where a single table can contain tens of petabytes of data.</li> <li>Even multi-petabyte tables can be read from a single node, without needing a distributed SQL engine to sift through table metadata.</li> </ul>"},{"location":"performance/#scan-planning","title":"Scan planning","text":"<p>Scan planning is the process of finding the files in a table that are needed for a query.</p> <p>Planning in an Iceberg table fits on a single node because Iceberg's metadata can be used to prune metadata files that aren't needed, in addition to filtering data files that don't contain matching data.</p> <p>Fast scan planning from a single node enables:</p> <ul> <li>Lower latency SQL queries -- by eliminating a distributed scan to plan a distributed scan</li> <li>Access from any client -- stand-alone processes can read data directly from Iceberg tables</li> </ul>"},{"location":"performance/#metadata-filtering","title":"Metadata filtering","text":"<p>Iceberg uses two levels of metadata to track the files in a snapshot.</p> <ul> <li>Manifest files store a list of data files, along each data file's partition data and column-level stats</li> <li>A manifest list stores the snapshot's list of manifests, along with the range of values for each partition field</li> </ul> <p>For fast scan planning, Iceberg first filters manifests using the partition value ranges in the manifest list. Then, it reads each manifest to get data files. With this scheme, the manifest list acts as an index over the manifest files, making it possible to plan without reading all manifests.</p> <p>In addition to partition value ranges, a manifest list also stores the number of files added or deleted in a manifest to speed up operations like snapshot expiration.</p>"},{"location":"performance/#data-filtering","title":"Data filtering","text":"<p>Manifest files include a tuple of partition data and column-level stats for each data file.</p> <p>During planning, query predicates are automatically converted to predicates on the partition data and applied first to filter data files. Next, column-level value counts, null counts, lower bounds, and upper bounds are used to eliminate files that cannot match the query predicate.</p> <p>By using upper and lower bounds to filter data files at planning time, Iceberg uses clustered data to eliminate splits without running tasks. In some cases, this is a 10x performance improvement.</p>"},{"location":"reliability/","title":"Reliability","text":""},{"location":"reliability/#reliability","title":"Reliability","text":"<p>Iceberg was designed to solve correctness problems that affect Hive tables running in S3.</p> <p>Hive tables track data files using both a central metastore for partitions and a file system for individual files. This makes atomic changes to a table's contents impossible, and eventually consistent stores like S3 may return incorrect results due to the use of listing files to reconstruct the state of a table. It also requires job planning to make many slow listing calls: O(n) with the number of partitions.</p> <p>Iceberg tracks the complete list of data files in each snapshot using a persistent tree structure. Every write or delete produces a new snapshot that reuses as much of the previous snapshot's metadata tree as possible to avoid high write volumes.</p> <p>Valid snapshots in an Iceberg table are stored in the table metadata file, along with a reference to the current snapshot. Commits replace the path of the current table metadata file using an atomic operation. This ensures that all updates to table data and metadata are atomic, and is the basis for serializable isolation.</p> <p>This results in improved reliability guarantees:</p> <ul> <li>Serializable isolation: All table changes occur in a linear history of atomic table updates</li> <li>Reliable reads: Readers always use a consistent snapshot of the table without holding a lock</li> <li>Version history and rollback: Table snapshots are kept as history and tables can roll back if a job produces bad data</li> <li>Safe file-level operations. By supporting atomic changes, Iceberg enables new use cases, like safely compacting small files and safely appending late data to tables</li> </ul> <p>This design also has performance benefits:</p> <ul> <li>O(1) RPCs to plan: Instead of listing O(n) directories in a table to plan a job, reading a snapshot requires O(1) RPC calls</li> <li>Distributed planning: File pruning and predicate push-down is distributed to jobs, removing the metastore as a bottleneck</li> <li>Finer granularity partitioning: Distributed planning and O(1) RPC calls remove the current barriers to finer-grained partitioning</li> </ul>"},{"location":"reliability/#concurrent-write-operations","title":"Concurrent write operations","text":"<p>Iceberg supports multiple concurrent writes using optimistic concurrency.</p> <p>Each writer assumes that no other writers are operating and writes out new table metadata for an operation. Then, the writer attempts to commit by atomically swapping the new table metadata file for the existing metadata file.</p> <p>If the atomic swap fails because another writer has committed, the failed writer retries by writing a new metadata tree based on the new current table state.</p>"},{"location":"reliability/#cost-of-retries","title":"Cost of retries","text":"<p>Writers avoid expensive retry operations by structuring changes so that work can be reused across retries.</p> <p>For example, appends usually create a new manifest file for the appended data files, which can be added to the table without rewriting the manifest on every attempt.</p>"},{"location":"reliability/#retry-validation","title":"Retry validation","text":"<p>Commits are structured as assumptions and actions. After a conflict, a writer checks that the assumptions are met by the current table state. If the assumptions are met, then it is safe to re-apply the actions and commit.</p> <p>For example, a compaction might rewrite <code>file_a.avro</code> and <code>file_b.avro</code> as <code>merged.parquet</code>. This is safe to commit as long as the table still contains both <code>file_a.avro</code> and <code>file_b.avro</code>. If either file was deleted by a conflicting commit, then the operation must fail. Otherwise, it is safe to remove the source files and add the merged file.</p>"},{"location":"reliability/#compatibility","title":"Compatibility","text":"<p>By avoiding file listing and rename operations, Iceberg tables are compatible with any object store. No consistent listing is required.</p>"},{"location":"schemas/","title":"Schemas","text":""},{"location":"schemas/#schemas","title":"Schemas","text":"<p>Iceberg tables support the following types:</p> Type Description Notes <code>boolean</code> True or false <code>int</code> 32-bit signed integers Can promote to <code>long</code> <code>long</code> 64-bit signed integers <code>float</code> 32-bit IEEE 754 floating point Can promote to <code>double</code> <code>double</code> 64-bit IEEE 754 floating point <code>decimal(P,S)</code> Fixed-point decimal; precision P, scale S Scale is fixed and precision must be 38 or less <code>date</code> Calendar date without timezone or time <code>time</code> Time of day without date, timezone Stored as microseconds <code>timestamp</code> Timestamp without timezone Stored as microseconds <code>timestamptz</code> Timestamp with timezone Stored as microseconds <code>string</code> Arbitrary-length character sequences Encoded with UTF-8 <code>fixed(L)</code> Fixed-length byte array of length L <code>binary</code> Arbitrary-length byte array <code>struct&lt;...&gt;</code> A record with named fields of any data type <code>list&lt;E&gt;</code> A list with elements of any data type <code>map&lt;K, V&gt;</code> A map with keys and values of any data type <p>Iceberg tracks each field in a table schema using an ID that is never reused in a table. See correctness guarantees for more information.</p>"},{"location":"spark-configuration/","title":"Configuration","text":""},{"location":"spark-configuration/#spark-configuration","title":"Spark Configuration","text":""},{"location":"spark-configuration/#catalogs","title":"Catalogs","text":"<p>Spark adds an API to plug in table catalogs that are used to load, create, and manage Iceberg tables. Spark catalogs are configured by setting Spark properties under <code>spark.sql.catalog</code>.</p> <p>This creates an Iceberg catalog named <code>hive_prod</code> that loads tables from a Hive metastore:</p> <pre><code>spark.sql.catalog.hive_prod = org.apache.iceberg.spark.SparkCatalog\nspark.sql.catalog.hive_prod.type = hive\nspark.sql.catalog.hive_prod.uri = thrift://metastore-host:port\n# omit uri to use the same URI as Spark: hive.metastore.uris in hive-site.xml\n</code></pre> <p>Below is an example for a REST catalog named <code>rest_prod</code> that loads tables from REST URL <code>http://localhost:8080</code>:</p> <pre><code>spark.sql.catalog.rest_prod = org.apache.iceberg.spark.SparkCatalog\nspark.sql.catalog.rest_prod.type = rest\nspark.sql.catalog.rest_prod.uri = http://localhost:8080\n</code></pre> <p>Iceberg also supports a directory-based catalog in HDFS that can be configured using <code>type=hadoop</code>:</p> <pre><code>spark.sql.catalog.hadoop_prod = org.apache.iceberg.spark.SparkCatalog\nspark.sql.catalog.hadoop_prod.type = hadoop\nspark.sql.catalog.hadoop_prod.warehouse = hdfs://nn:8020/warehouse/path\n</code></pre> <p>Info</p> <p>The Hive-based catalog only loads Iceberg tables. To load non-Iceberg tables in the same Hive metastore, use a session catalog.</p>"},{"location":"spark-configuration/#catalog-configuration","title":"Catalog configuration","text":"<p>A catalog is created and named by adding a property <code>spark.sql.catalog.(catalog-name)</code> with an implementation class for its value.</p> <p>Iceberg supplies two implementations:</p> <ul> <li><code>org.apache.iceberg.spark.SparkCatalog</code> supports a Hive Metastore or a Hadoop warehouse as a catalog</li> <li><code>org.apache.iceberg.spark.SparkSessionCatalog</code> adds support for Iceberg tables to Spark's built-in catalog, and delegates to the built-in catalog for non-Iceberg tables</li> </ul> <p>Both catalogs are configured using properties nested under the catalog name. Common configuration properties for Hive and Hadoop are:</p> Property Values Description spark.sql.catalog.catalog-name.type <code>hive</code>, <code>hadoop</code> or <code>rest</code> The underlying Iceberg catalog implementation, <code>HiveCatalog</code>, <code>HadoopCatalog</code>, <code>RESTCatalog</code> or left unset if using a custom catalog spark.sql.catalog.catalog-name.catalog-impl The custom Iceberg catalog implementation. If <code>type</code> is null, <code>catalog-impl</code> must not be null. spark.sql.catalog.catalog-name.io-impl The custom FileIO implementation. spark.sql.catalog.catalog-name.metrics-reporter-impl The custom MetricsReporter implementation. spark.sql.catalog.catalog-name.default-namespace default The default current namespace for the catalog spark.sql.catalog.catalog-name.uri thrift://host:port Hive metastore URL for hive typed catalog, REST URL for REST typed catalog spark.sql.catalog.catalog-name.warehouse hdfs://nn:8020/warehouse/path Base path for the warehouse directory spark.sql.catalog.catalog-name.cache-enabled <code>true</code> or <code>false</code> Whether to enable catalog cache, default value is <code>true</code> spark.sql.catalog.catalog-name.cache.expiration-interval-ms <code>30000</code> (30 seconds) Duration after which cached catalog entries are expired; Only effective if <code>cache-enabled</code> is <code>true</code>. <code>-1</code> disables cache expiration and <code>0</code> disables caching entirely, irrespective of <code>cache-enabled</code>. Default is <code>30000</code> (30 seconds) spark.sql.catalog.catalog-name.table-default.propertyKey Default Iceberg table property value for property key propertyKey, which will be set on tables created by this catalog if not overridden spark.sql.catalog.catalog-name.table-override.propertyKey Enforced Iceberg table property value for property key propertyKey, which cannot be overridden by user <p>Additional properties can be found in common catalog configuration.</p>"},{"location":"spark-configuration/#using-catalogs","title":"Using catalogs","text":"<p>Catalog names are used in SQL queries to identify a table. In the examples above, <code>hive_prod</code> and <code>hadoop_prod</code> can be used to prefix database and table names that will be loaded from those catalogs.</p> <pre><code>SELECT * FROM hive_prod.db.table -- load db.table from catalog hive_prod\n</code></pre> <p>Spark 3 keeps track of the current catalog and namespace, which can be omitted from table names.</p> <pre><code>USE hive_prod.db;\nSELECT * FROM table -- load db.table from catalog hive_prod\n</code></pre> <p>To see the current catalog and namespace, run <code>SHOW CURRENT NAMESPACE</code>.</p>"},{"location":"spark-configuration/#replacing-the-session-catalog","title":"Replacing the session catalog","text":"<p>To add Iceberg table support to Spark's built-in catalog, configure <code>spark_catalog</code> to use Iceberg's <code>SparkSessionCatalog</code>.</p> <pre><code>spark.sql.catalog.spark_catalog = org.apache.iceberg.spark.SparkSessionCatalog\nspark.sql.catalog.spark_catalog.type = hive\n</code></pre> <p>Spark's built-in catalog supports existing v1 and v2 tables tracked in a Hive Metastore. This configures Spark to use Iceberg's <code>SparkSessionCatalog</code> as a wrapper around that session catalog. When a table is not an Iceberg table, the built-in catalog will be used to load it instead.</p> <p>This configuration can use same Hive Metastore for both Iceberg and non-Iceberg tables.</p>"},{"location":"spark-configuration/#using-catalog-specific-hadoop-configuration-values","title":"Using catalog specific Hadoop configuration values","text":"<p>Similar to configuring Hadoop properties by using <code>spark.hadoop.*</code>, it's possible to set per-catalog Hadoop configuration values when using Spark by adding the property for the catalog with the prefix <code>spark.sql.catalog.(catalog-name).hadoop.*</code>. These properties will take precedence over values configured globally using <code>spark.hadoop.*</code> and will only affect Iceberg tables.</p> <pre><code>spark.sql.catalog.hadoop_prod.hadoop.fs.s3a.endpoint = http://aws-local:9000\n</code></pre>"},{"location":"spark-configuration/#loading-a-custom-catalog","title":"Loading a custom catalog","text":"<p>Spark supports loading a custom Iceberg <code>Catalog</code> implementation by specifying the <code>catalog-impl</code> property. Here is an example:</p> <pre><code>spark.sql.catalog.custom_prod = org.apache.iceberg.spark.SparkCatalog\nspark.sql.catalog.custom_prod.catalog-impl = com.my.custom.CatalogImpl\nspark.sql.catalog.custom_prod.my-additional-catalog-config = my-value\n</code></pre>"},{"location":"spark-configuration/#sql-extensions","title":"SQL Extensions","text":"<p>Iceberg 0.11.0 and later add an extension module to Spark to add new SQL commands, like <code>CALL</code> for stored procedures or <code>ALTER TABLE ... WRITE ORDERED BY</code>.</p> <p>Using those SQL commands requires adding Iceberg extensions to your Spark environment using the following Spark property:</p> Spark extensions property Iceberg extensions implementation <code>spark.sql.extensions</code> <code>org.apache.iceberg.spark.extensions.IcebergSparkSessionExtensions</code>"},{"location":"spark-configuration/#runtime-configuration","title":"Runtime configuration","text":""},{"location":"spark-configuration/#read-options","title":"Read options","text":"<p>Spark read options are passed when configuring the DataFrameReader, like this:</p> <pre><code>// time travel\nspark.read\n.option(\"snapshot-id\", 10963874102873L)\n.table(\"catalog.db.table\")\n</code></pre> Spark option Default Description snapshot-id (latest) Snapshot ID of the table snapshot to read as-of-timestamp (latest) A timestamp in milliseconds; the snapshot used will be the snapshot current at this time. split-size As per table property Overrides this table's read.split.target-size and read.split.metadata-target-size lookback As per table property Overrides this table's read.split.planning-lookback file-open-cost As per table property Overrides this table's read.split.open-file-cost vectorization-enabled As per table property Overrides this table's read.parquet.vectorization.enabled batch-size As per table property Overrides this table's read.parquet.vectorization.batch-size stream-from-timestamp (none) A timestamp in milliseconds to stream from; if before the oldest known ancestor snapshot, the oldest will be used"},{"location":"spark-configuration/#write-options","title":"Write options","text":"<p>Spark write options are passed when configuring the DataFrameWriter, like this:</p> <pre><code>// write with Avro instead of Parquet\ndf.write\n.option(\"write-format\", \"avro\")\n.option(\"snapshot-property.key\", \"value\")\n.insertInto(\"catalog.db.table\")\n</code></pre> Spark option Default Description write-format Table write.format.default File format to use for this write operation; parquet, avro, or orc target-file-size-bytes As per table property Overrides this table's write.target-file-size-bytes check-nullability true Sets the nullable check on fields snapshot-property.custom-key null Adds an entry with custom-key and corresponding value in the snapshot summary fanout-enabled false Overrides this table's write.spark.fanout.enabled check-ordering true Checks if input schema and table schema are same isolation-level null Desired isolation level for Dataframe overwrite operations.  <code>null</code> =&gt; no checks (for idempotent writes), <code>serializable</code> =&gt; check for concurrent inserts or deletes in destination partitions, <code>snapshot</code> =&gt; checks for concurrent deletes in destination partitions. validate-from-snapshot-id null If isolation level is set, id of base snapshot from which to check concurrent write conflicts into a table. Should be the snapshot before any reads from the table. Can be obtained via Table API or Snapshots table. If null, the table's oldest known snapshot is used."},{"location":"spark-ddl/","title":"DDL","text":""},{"location":"spark-ddl/#spark-ddl","title":"Spark DDL","text":"<p>To use Iceberg in Spark, first configure Spark catalogs. Iceberg uses Apache Spark's DataSourceV2 API for data source and catalog implementations.</p>"},{"location":"spark-ddl/#create-table","title":"<code>CREATE TABLE</code>","text":"<p>Spark 3 can create tables in any Iceberg catalog with the clause <code>USING iceberg</code>:</p> <pre><code>CREATE TABLE prod.db.sample (\nid bigint COMMENT 'unique id',\ndata string)\nUSING iceberg\n</code></pre> <p>Iceberg will convert the column type in Spark to corresponding Iceberg type. Please check the section of type compatibility on creating table for details.</p> <p>Table create commands, including CTAS and RTAS, support the full range of Spark create clauses, including:</p> <ul> <li><code>PARTITIONED BY (partition-expressions)</code> to configure partitioning</li> <li><code>LOCATION '(fully-qualified-uri)'</code> to set the table location</li> <li><code>COMMENT 'table documentation'</code> to set a table description</li> <li><code>TBLPROPERTIES ('key'='value', ...)</code> to set table configuration</li> </ul> <p>Create commands may also set the default format with the <code>USING</code> clause. This is only supported for <code>SparkCatalog</code> because Spark handles the <code>USING</code> clause differently for the built-in catalog.</p>"},{"location":"spark-ddl/#partitioned-by","title":"<code>PARTITIONED BY</code>","text":"<p>To create a partitioned table, use <code>PARTITIONED BY</code>:</p> <pre><code>CREATE TABLE prod.db.sample (\nid bigint,\ndata string,\ncategory string)\nUSING iceberg\nPARTITIONED BY (category)\n</code></pre> <p>The <code>PARTITIONED BY</code> clause supports transform expressions to create hidden partitions.</p> <pre><code>CREATE TABLE prod.db.sample (\nid bigint,\ndata string,\ncategory string,\nts timestamp)\nUSING iceberg\nPARTITIONED BY (bucket(16, id), days(ts), category)\n</code></pre> <p>Supported transformations are:</p> <ul> <li><code>years(ts)</code>: partition by year</li> <li><code>months(ts)</code>: partition by month</li> <li><code>days(ts)</code> or <code>date(ts)</code>: equivalent to dateint partitioning</li> <li><code>hours(ts)</code> or <code>date_hour(ts)</code>: equivalent to dateint and hour partitioning</li> <li><code>bucket(N, col)</code>: partition by hashed value mod N buckets</li> <li><code>truncate(L, col)</code>: partition by value truncated to L<ul> <li>Strings are truncated to the given length</li> <li>Integers and longs truncate to bins: <code>truncate(10, i)</code> produces partitions 0, 10, 20, 30, ...</li> </ul> </li> </ul>"},{"location":"spark-ddl/#create-table-as-select","title":"<code>CREATE TABLE ... AS SELECT</code>","text":"<p>Iceberg supports CTAS as an atomic operation when using a <code>SparkCatalog</code>. CTAS is supported, but is not atomic when using <code>SparkSessionCatalog</code>.</p> <pre><code>CREATE TABLE prod.db.sample\nUSING iceberg\nAS SELECT ...\n</code></pre> <p>The newly created table won't inherit the partition spec and table properties from the source table in SELECT, you can use PARTITIONED BY and TBLPROPERTIES in CTAS to declare partition spec and table properties for the new table.</p> <pre><code>CREATE TABLE prod.db.sample\nUSING iceberg\nPARTITIONED BY (part)\nTBLPROPERTIES ('key'='value')\nAS SELECT ...\n</code></pre>"},{"location":"spark-ddl/#replace-table-as-select","title":"<code>REPLACE TABLE ... AS SELECT</code>","text":"<p>Iceberg supports RTAS as an atomic operation when using a <code>SparkCatalog</code>. RTAS is supported, but is not atomic when using <code>SparkSessionCatalog</code>.</p> <p>Atomic table replacement creates a new snapshot with the results of the <code>SELECT</code> query, but keeps table history.</p> <p><pre><code>REPLACE TABLE prod.db.sample\nUSING iceberg\nAS SELECT ...\n</code></pre> <pre><code>REPLACE TABLE prod.db.sample\nUSING iceberg\nPARTITIONED BY (part)\nTBLPROPERTIES ('key'='value')\nAS SELECT ...\n</code></pre> <pre><code>CREATE OR REPLACE TABLE prod.db.sample\nUSING iceberg\nAS SELECT ...\n</code></pre></p> <p>The schema and partition spec will be replaced if changed. To avoid modifying the table's schema and partitioning, use <code>INSERT OVERWRITE</code> instead of <code>REPLACE TABLE</code>. The new table properties in the <code>REPLACE TABLE</code> command will be merged with any existing table properties. The existing table properties will be updated if changed else they are preserved.</p>"},{"location":"spark-ddl/#drop-table","title":"<code>DROP TABLE</code>","text":"<p>The drop table behavior changed in 0.14.</p> <p>Prior to 0.14, running <code>DROP TABLE</code> would remove the table from the catalog and delete the table contents as well.</p> <p>From 0.14 onwards, <code>DROP TABLE</code> would only remove the table from the catalog. In order to delete the table contents <code>DROP TABLE PURGE</code> should be used.</p>"},{"location":"spark-ddl/#drop-table_1","title":"<code>DROP TABLE</code>","text":"<p>To drop the table from the catalog, run:</p> <pre><code>DROP TABLE prod.db.sample\n</code></pre>"},{"location":"spark-ddl/#drop-table-purge","title":"<code>DROP TABLE PURGE</code>","text":"<p>To drop the table from the catalog and delete the table's contents, run:</p> <pre><code>DROP TABLE prod.db.sample PURGE\n</code></pre>"},{"location":"spark-ddl/#alter-table","title":"<code>ALTER TABLE</code>","text":"<p>Iceberg has full <code>ALTER TABLE</code> support in Spark 3, including:</p> <ul> <li>Renaming a table</li> <li>Setting or removing table properties</li> <li>Adding, deleting, and renaming columns</li> <li>Adding, deleting, and renaming nested fields</li> <li>Reordering top-level columns and nested struct fields</li> <li>Widening the type of <code>int</code>, <code>float</code>, and <code>decimal</code> fields</li> <li>Making required columns optional</li> </ul> <p>In addition, SQL extensions can be used to add support for partition evolution and setting a table's write order</p>"},{"location":"spark-ddl/#alter-table-rename-to","title":"<code>ALTER TABLE ... RENAME TO</code>","text":"<pre><code>ALTER TABLE prod.db.sample RENAME TO prod.db.new_name\n</code></pre>"},{"location":"spark-ddl/#alter-table-set-tblproperties","title":"<code>ALTER TABLE ... SET TBLPROPERTIES</code>","text":"<pre><code>ALTER TABLE prod.db.sample SET TBLPROPERTIES (\n'read.split.target-size'='268435456'\n)\n</code></pre> <p>Iceberg uses table properties to control table behavior. For a list of available properties, see Table configuration.</p> <p><code>UNSET</code> is used to remove properties:</p> <pre><code>ALTER TABLE prod.db.sample UNSET TBLPROPERTIES ('read.split.target-size')\n</code></pre> <p><code>SET TBLPROPERTIES</code> can also be used to set the table comment (description):</p> <pre><code>ALTER TABLE prod.db.sample SET TBLPROPERTIES (\n'comment' = 'A table comment.'\n)\n</code></pre>"},{"location":"spark-ddl/#alter-table-add-column","title":"<code>ALTER TABLE ... ADD COLUMN</code>","text":"<p>To add a column to Iceberg, use the <code>ADD COLUMNS</code> clause with <code>ALTER TABLE</code>:</p> <pre><code>ALTER TABLE prod.db.sample\nADD COLUMNS (\nnew_column string comment 'new_column docs'\n)\n</code></pre> <p>Multiple columns can be added at the same time, separated by commas.</p> <p>Nested columns should be identified using the full column name:</p> <pre><code>-- create a struct column\nALTER TABLE prod.db.sample\nADD COLUMN point struct&lt;x: double, y: double&gt;;\n-- add a field to the struct\nALTER TABLE prod.db.sample\nADD COLUMN point.z double\n</code></pre> <pre><code>-- create a nested array column of struct\nALTER TABLE prod.db.sample\nADD COLUMN points array&lt;struct&lt;x: double, y: double&gt;&gt;;\n-- add a field to the struct within an array. Using keyword 'element' to access the array's element column.\nALTER TABLE prod.db.sample\nADD COLUMN points.element.z double\n</code></pre> <pre><code>-- create a map column of struct key and struct value\nALTER TABLE prod.db.sample\nADD COLUMN points map&lt;struct&lt;x: int&gt;, struct&lt;a: int&gt;&gt;;\n-- add a field to the value struct in a map. Using keyword 'value' to access the map's value column.\nALTER TABLE prod.db.sample\nADD COLUMN points.value.b int\n</code></pre> <p>Note: Altering a map 'key' column by adding columns is not allowed. Only map values can be updated.</p> <p>Add columns in any position by adding <code>FIRST</code> or <code>AFTER</code> clauses:</p> <pre><code>ALTER TABLE prod.db.sample\nADD COLUMN new_column bigint AFTER other_column\n</code></pre> <pre><code>ALTER TABLE prod.db.sample\nADD COLUMN nested.new_column bigint FIRST\n</code></pre>"},{"location":"spark-ddl/#alter-table-rename-column","title":"<code>ALTER TABLE ... RENAME COLUMN</code>","text":"<p>Iceberg allows any field to be renamed. To rename a field, use <code>RENAME COLUMN</code>:</p> <pre><code>ALTER TABLE prod.db.sample RENAME COLUMN data TO payload\nALTER TABLE prod.db.sample RENAME COLUMN location.lat TO latitude\n</code></pre> <p>Note that nested rename commands only rename the leaf field. The above command renames <code>location.lat</code> to <code>location.latitude</code></p>"},{"location":"spark-ddl/#alter-table-alter-column","title":"<code>ALTER TABLE ... ALTER COLUMN</code>","text":"<p>Alter column is used to widen types, make a field optional, set comments, and reorder fields.</p> <p>Iceberg allows updating column types if the update is safe. Safe updates are:</p> <ul> <li><code>int</code> to <code>bigint</code></li> <li><code>float</code> to <code>double</code></li> <li><code>decimal(P,S)</code> to <code>decimal(P2,S)</code> when P2 &gt; P (scale cannot change)</li> </ul> <pre><code>ALTER TABLE prod.db.sample ALTER COLUMN measurement TYPE double\n</code></pre> <p>To add or remove columns from a struct, use <code>ADD COLUMN</code> or <code>DROP COLUMN</code> with a nested column name.</p> <p>Column comments can also be updated using <code>ALTER COLUMN</code>:</p> <pre><code>ALTER TABLE prod.db.sample ALTER COLUMN measurement TYPE double COMMENT 'unit is bytes per second'\nALTER TABLE prod.db.sample ALTER COLUMN measurement COMMENT 'unit is kilobytes per second'\n</code></pre> <p>Iceberg allows reordering top-level columns or columns in a struct using <code>FIRST</code> and <code>AFTER</code> clauses:</p> <p><pre><code>ALTER TABLE prod.db.sample ALTER COLUMN col FIRST\n</code></pre> <pre><code>ALTER TABLE prod.db.sample ALTER COLUMN nested.col AFTER other_col\n</code></pre></p> <p>Nullability can be changed using <code>SET NOT NULL</code> and <code>DROP NOT NULL</code>:</p> <pre><code>ALTER TABLE prod.db.sample ALTER COLUMN id DROP NOT NULL\n</code></pre> <p>Info</p> <p><code>ALTER COLUMN</code> is not used to update <code>struct</code> types. Use <code>ADD COLUMN</code> and <code>DROP COLUMN</code> to add or remove struct fields.</p>"},{"location":"spark-ddl/#alter-table-drop-column","title":"<code>ALTER TABLE ... DROP COLUMN</code>","text":"<p>To drop columns, use <code>ALTER TABLE ... DROP COLUMN</code>:</p> <pre><code>ALTER TABLE prod.db.sample DROP COLUMN id\nALTER TABLE prod.db.sample DROP COLUMN point.z\n</code></pre>"},{"location":"spark-ddl/#alter-table-sql-extensions","title":"<code>ALTER TABLE</code> SQL extensions","text":"<p>These commands are available in Spark 3 when using Iceberg SQL extensions.</p>"},{"location":"spark-ddl/#alter-table-add-partition-field","title":"<code>ALTER TABLE ... ADD PARTITION FIELD</code>","text":"<p>Iceberg supports adding new partition fields to a spec using <code>ADD PARTITION FIELD</code>:</p> <pre><code>ALTER TABLE prod.db.sample ADD PARTITION FIELD catalog -- identity transform\n</code></pre> <p>Partition transforms are also supported:</p> <pre><code>ALTER TABLE prod.db.sample ADD PARTITION FIELD bucket(16, id)\nALTER TABLE prod.db.sample ADD PARTITION FIELD truncate(4, data)\nALTER TABLE prod.db.sample ADD PARTITION FIELD years(ts)\n-- use optional AS keyword to specify a custom name for the partition field \nALTER TABLE prod.db.sample ADD PARTITION FIELD bucket(16, id) AS shard\n</code></pre> <p>Adding a partition field is a metadata operation and does not change any of the existing table data. New data will be written with the new partitioning, but existing data will remain in the old partition layout. Old data files will have null values for the new partition fields in metadata tables.</p> <p>Dynamic partition overwrite behavior will change when the table's partitioning changes because dynamic overwrite replaces partitions implicitly. To overwrite explicitly, use the new <code>DataFrameWriterV2</code> API.</p> <p>Note</p> <p>To migrate from daily to hourly partitioning with transforms, it is not necessary to drop the daily partition field. Keeping the field ensures existing metadata table queries continue to work.</p> <p>Danger</p> <p>Dynamic partition overwrite behavior will change when partitioning changes For example, if you partition by days and move to partitioning by hours, overwrites will overwrite hourly partitions but not days anymore.</p>"},{"location":"spark-ddl/#alter-table-drop-partition-field","title":"<code>ALTER TABLE ... DROP PARTITION FIELD</code>","text":"<p>Partition fields can be removed using <code>DROP PARTITION FIELD</code>:</p> <pre><code>ALTER TABLE prod.db.sample DROP PARTITION FIELD catalog\nALTER TABLE prod.db.sample DROP PARTITION FIELD bucket(16, id)\nALTER TABLE prod.db.sample DROP PARTITION FIELD truncate(4, data)\nALTER TABLE prod.db.sample DROP PARTITION FIELD years(ts)\nALTER TABLE prod.db.sample DROP PARTITION FIELD shard\n</code></pre> <p>Note that although the partition is removed, the column will still exist in the table schema.</p> <p>Dropping a partition field is a metadata operation and does not change any of the existing table data. New data will be written with the new partitioning, but existing data will remain in the old partition layout.</p> <p>Danger</p> <p>Dynamic partition overwrite behavior will change when partitioning changes For example, if you partition by days and move to partitioning by hours, overwrites will overwrite hourly partitions but not days anymore.</p> <p>Danger</p> <p>Be careful when dropping a partition field because it will change the schema of metadata tables, like <code>files</code>, and may cause metadata queries to fail or produce different results.</p>"},{"location":"spark-ddl/#alter-table-replace-partition-field","title":"<code>ALTER TABLE ... REPLACE PARTITION FIELD</code>","text":"<p>A partition field can be replaced by a new partition field in a single metadata update by using <code>REPLACE PARTITION FIELD</code>:</p> <pre><code>ALTER TABLE prod.db.sample REPLACE PARTITION FIELD ts_day WITH days(ts)\n-- use optional AS keyword to specify a custom name for the new partition field \nALTER TABLE prod.db.sample REPLACE PARTITION FIELD ts_day WITH days(ts) AS day_of_ts\n</code></pre>"},{"location":"spark-ddl/#alter-table-write-ordered-by","title":"<code>ALTER TABLE ... WRITE ORDERED BY</code>","text":"<p>Iceberg tables can be configured with a sort order that is used to automatically sort data that is written to the table in some engines. For example, <code>MERGE INTO</code> in Spark will use the table ordering.</p> <p>To set the write order for a table, use <code>WRITE ORDERED BY</code>:</p> <pre><code>ALTER TABLE prod.db.sample WRITE ORDERED BY category, id\n-- use optional ASC/DEC keyword to specify sort order of each field (default ASC)\nALTER TABLE prod.db.sample WRITE ORDERED BY category ASC, id DESC\n-- use optional NULLS FIRST/NULLS LAST keyword to specify null order of each field (default FIRST)\nALTER TABLE prod.db.sample WRITE ORDERED BY category ASC NULLS LAST, id DESC NULLS FIRST\n</code></pre> <p>Info</p> <p>Table write order does not guarantee data order for queries. It only affects how data is written to the table.</p> <p><code>WRITE ORDERED BY</code> sets a global ordering where rows are ordered across tasks, like using <code>ORDER BY</code> in an <code>INSERT</code> command:</p> <pre><code>INSERT INTO prod.db.sample\nSELECT id, data, category, ts FROM another_table\nORDER BY ts, category\n</code></pre> <p>To order within each task, not across tasks, use <code>LOCALLY ORDERED BY</code>:</p> <pre><code>ALTER TABLE prod.db.sample WRITE LOCALLY ORDERED BY category, id\n</code></pre>"},{"location":"spark-ddl/#alter-table-write-distributed-by-partition","title":"<code>ALTER TABLE ... WRITE DISTRIBUTED BY PARTITION</code>","text":"<p><code>WRITE DISTRIBUTED BY PARTITION</code> will request that each partition is handled by one writer, the default implementation is hash distribution.</p> <pre><code>ALTER TABLE prod.db.sample WRITE DISTRIBUTED BY PARTITION\n</code></pre> <p><code>DISTRIBUTED BY PARTITION</code> and <code>LOCALLY ORDERED BY</code> may be used together, to distribute by partition and locally order rows within each task.</p> <pre><code>ALTER TABLE prod.db.sample WRITE DISTRIBUTED BY PARTITION LOCALLY ORDERED BY category, id\n</code></pre>"},{"location":"spark-ddl/#alter-table-set-identifier-fields","title":"<code>ALTER TABLE ... SET IDENTIFIER FIELDS</code>","text":"<p>Iceberg supports setting identifier fields to a spec using <code>SET IDENTIFIER FIELDS</code>:</p> <pre><code>ALTER TABLE prod.db.sample SET IDENTIFIER FIELDS id\n-- single column\nALTER TABLE prod.db.sample SET IDENTIFIER FIELDS id, data\n-- multiple columns\n</code></pre> <p>identifier fields must be <code>NOT NULL</code>, The later <code>ALTER</code> statement will overwrite the previous setting.</p>"},{"location":"spark-ddl/#alter-table-drop-identifier-fields","title":"<code>ALTER TABLE ... DROP IDENTIFIER FIELDS</code>","text":"<p>Identifier fields can be removed using <code>DROP IDENTIFIER FIELDS</code>:</p> <pre><code>ALTER TABLE prod.db.sample DROP IDENTIFIER FIELDS id\n-- single column\nALTER TABLE prod.db.sample DROP IDENTIFIER FIELDS id, data\n-- multiple columns\n</code></pre> <p>Note that although the identifier is removed, the column will still exist in the table schema.</p>"},{"location":"spark-ddl/#branching-and-tagging-ddl","title":"Branching and Tagging DDL","text":""},{"location":"spark-ddl/#alter-table-create-branch","title":"<code>ALTER TABLE ... CREATE BRANCH</code>","text":"<p>Branches can be created via the <code>CREATE BRANCH</code> statement, which includes  the snapshot to create the branch at and an optional retention clause.</p> <pre><code>-- CREATE audit-branch at snapshot 1234 with default retention.\nALTER TABLE prod.db.sample CREATE BRANCH audit-branch\nAS OF VERSION 1234\n-- CREATE audit-branch at snapshot 1234, retain audit-branch for 31 days, and retain the latest 31 days. The latest 3 snapshot snapshots, and 2 days worth of snapshots \nALTER TABLE prod.db.sample CREATE BRANCH audit-branch\nAS OF VERSION 1234 RETAIN 30 DAYS WITH RETENTION 3 SNAPSHOTS 2 DAYS\n</code></pre>"},{"location":"spark-ddl/#alter-table-create-tag","title":"<code>ALTER TABLE ... CREATE TAG</code>","text":"<p>Tags can be created via the <code>CREATE TAG</code> statement, which includes  the snapshot to create the branch at and an optional retention clause.</p> <pre><code>-- CREATE historical-tag at snapshot 1234 with default retention.\nALTER TABLE prod.db.sample CREATE TAG historical-tag AS OF VERSION 1234\n-- CREATE historical-tag at snapshot 1234 and retain it for 1 year. \nALTER TABLE prod.db.sample CREATE TAG historical-tag AS OF VERSION 1234 RETAIN 365 DAYS\n</code></pre>"},{"location":"spark-ddl/#alter-table-replace-branch","title":"<code>ALTER TABLE ... REPLACE BRANCH</code>","text":"<p>The snapshot which a branch references can be updated via the <code>REPLACE BRANCH</code> sql. Retention can also be updated in this statement. </p> <pre><code>-- REPLACE audit-branch to reference snapshot 4567 and update the retention to 60 days\nALTER TABLE prod.db.sample REPLACE BRANCH audit-branch\nAS OF VERSION 4567 RETAIN 60 DAYS\n</code></pre>"},{"location":"spark-ddl/#alter-table-drop-branch","title":"<code>ALTER TABLE ... DROP BRANCH</code>","text":"<p>Branches can be removed via the <code>DROP BRANCH</code> sql</p> <pre><code>ALTER TABLE prod.db.sample DROP BRANCH audit-branch\n</code></pre>"},{"location":"spark-ddl/#alter-table-drop-tag","title":"<code>ALTER TABLE ... DROP TAG</code>","text":"<p>Tags can be removed via the <code>DROP TAG</code> sql</p> <pre><code>ALTER TABLE prod.db.sample DROP TAG historical-tag\n</code></pre>"},{"location":"spark-getting-started/","title":"Getting Started","text":""},{"location":"spark-getting-started/#getting-started","title":"Getting Started","text":"<p>The latest version of Iceberg is {{ icebergVersion }}.</p> <p>Spark is currently the most feature-rich compute engine for Iceberg operations.  We recommend you to get started with Spark to understand Iceberg concepts and features with examples. You can also view documentations of using Iceberg with other compute engine under the Multi-Engine Support page.</p>"},{"location":"spark-getting-started/#using-iceberg-in-spark-3","title":"Using Iceberg in Spark 3","text":"<p>To use Iceberg in a Spark shell, use the <code>--packages</code> option:</p> <pre><code>spark-shell --packages org.apache.iceberg:iceberg-spark-runtime-3.2_2.12:{{ icebergVersion }}\n</code></pre> <p>Info</p> <p>If you want to include Iceberg in your Spark installation, add the <code>iceberg-spark-runtime-3.2_2.12</code> Jar to Spark's <code>jars</code> folder.</p>"},{"location":"spark-getting-started/#adding-catalogs","title":"Adding catalogs","text":"<p>Iceberg comes with catalogs that enable SQL commands to manage tables and load them by name. Catalogs are configured using properties under <code>spark.sql.catalog.(catalog_name)</code>.</p> <p>This command creates a path-based catalog named <code>local</code> for tables under <code>$PWD/warehouse</code> and adds support for Iceberg tables to Spark's built-in catalog:</p> <pre><code>spark-sql --packages org.apache.iceberg:iceberg-spark-runtime-3.2_2.12:{{ icebergVersion }}\\\n--conf spark.sql.extensions=org.apache.iceberg.spark.extensions.IcebergSparkSessionExtensions \\\n--conf spark.sql.catalog.spark_catalog=org.apache.iceberg.spark.SparkSessionCatalog \\\n--conf spark.sql.catalog.spark_catalog.type=hive \\\n--conf spark.sql.catalog.local=org.apache.iceberg.spark.SparkCatalog \\\n--conf spark.sql.catalog.local.type=hadoop \\\n--conf spark.sql.catalog.local.warehouse=$PWD/warehouse\n</code></pre>"},{"location":"spark-getting-started/#creating-a-table","title":"Creating a table","text":"<p>To create your first Iceberg table in Spark, use the <code>spark-sql</code> shell or <code>spark.sql(...)</code> to run a <code>CREATE TABLE</code> command:</p> <pre><code>-- local is the path-based catalog defined above\nCREATE TABLE local.db.table (id bigint, data string) USING iceberg\n</code></pre> <p>Iceberg catalogs support the full range of SQL DDL commands, including:</p> <ul> <li><code>CREATE TABLE ... PARTITIONED BY</code></li> <li><code>CREATE TABLE ... AS SELECT</code></li> <li><code>ALTER TABLE</code></li> <li><code>DROP TABLE</code></li> </ul>"},{"location":"spark-getting-started/#writing","title":"Writing","text":"<p>Once your table is created, insert data using <code>INSERT INTO</code>:</p> <pre><code>INSERT INTO local.db.table VALUES (1, 'a'), (2, 'b'), (3, 'c');\nINSERT INTO local.db.table SELECT id, data FROM source WHERE length(data) = 1;\n</code></pre> <p>Iceberg also adds row-level SQL updates to Spark, <code>MERGE INTO</code> and <code>DELETE FROM</code>:</p> <pre><code>MERGE INTO local.db.target t USING (SELECT * FROM updates) u ON t.id = u.id\nWHEN MATCHED THEN UPDATE SET t.count = t.count + u.count\nWHEN NOT MATCHED THEN INSERT *\n</code></pre> <p>Iceberg supports writing DataFrames using the new v2 DataFrame write API:</p> <pre><code>spark.table(\"source\").select(\"id\", \"data\")\n.writeTo(\"local.db.table\").append()\n</code></pre> <p>The old <code>write</code> API is supported, but not recommended.</p>"},{"location":"spark-getting-started/#reading","title":"Reading","text":"<p>To read with SQL, use the an Iceberg table name in a <code>SELECT</code> query:</p> <pre><code>SELECT count(1) as count, data\nFROM local.db.table\nGROUP BY data\n</code></pre> <p>SQL is also the recommended way to inspect tables. To view all of the snapshots in a table, use the <code>snapshots</code> metadata table: <pre><code>SELECT * FROM local.db.table.snapshots\n</code></pre> <pre><code>+-------------------------+----------------+-----------+-----------+----------------------------------------------------+-----+\n| committed_at            | snapshot_id    | parent_id | operation | manifest_list                                      | ... |\n+-------------------------+----------------+-----------+-----------+----------------------------------------------------+-----+\n| 2019-02-08 03:29:51.215 | 57897183625154 | null      | append    | s3://.../table/metadata/snap-57897183625154-1.avro | ... |\n|                         |                |           |           |                                                    | ... |\n|                         |                |           |           |                                                    | ... |\n| ...                     | ...            | ...       | ...       | ...                                                | ... |\n+-------------------------+----------------+-----------+-----------+----------------------------------------------------+-----+\n</code></pre></p> <p>DataFrame reads are supported and can now reference tables by name using <code>spark.table</code>:</p> <pre><code>val df = spark.table(\"local.db.table\")\ndf.count()\n</code></pre>"},{"location":"spark-getting-started/#next-steps","title":"Next steps","text":"<p>Next, you can learn more about Iceberg tables in Spark:</p> <ul> <li>DDL commands: <code>CREATE</code>, <code>ALTER</code>, and <code>DROP</code></li> <li>Querying data: <code>SELECT</code> queries and metadata tables</li> <li>Writing data: <code>INSERT INTO</code> and <code>MERGE INTO</code></li> <li>Maintaining tables with stored procedures</li> </ul>"},{"location":"spark-procedures/","title":"Procedures","text":""},{"location":"spark-procedures/#spark-procedures","title":"Spark Procedures","text":"<p>To use Iceberg in Spark, first configure Spark catalogs. Stored procedures are only available when using Iceberg SQL extensions in Spark 3.</p>"},{"location":"spark-procedures/#usage","title":"Usage","text":"<p>Procedures can be used from any configured Iceberg catalog with <code>CALL</code>. All procedures are in the namespace <code>system</code>.</p> <p><code>CALL</code> supports passing arguments by name (recommended) or by position. Mixing position and named arguments is not supported.</p>"},{"location":"spark-procedures/#named-arguments","title":"Named arguments","text":"<p>All procedure arguments are named. When passing arguments by name, arguments can be in any order and any optional argument can be omitted.</p> <pre><code>CALL catalog_name.system.procedure_name(arg_name_2 =&gt; arg_2, arg_name_1 =&gt; arg_1)\n</code></pre>"},{"location":"spark-procedures/#positional-arguments","title":"Positional arguments","text":"<p>When passing arguments by position, only the ending arguments may be omitted if they are optional.</p> <pre><code>CALL catalog_name.system.procedure_name(arg_1, arg_2, ... arg_n)\n</code></pre>"},{"location":"spark-procedures/#snapshot-management","title":"Snapshot management","text":""},{"location":"spark-procedures/#rollback_to_snapshot","title":"<code>rollback_to_snapshot</code>","text":"<p>Roll back a table to a specific snapshot ID.</p> <p>To roll back to a specific time, use <code>rollback_to_timestamp</code>.</p> <p>Info</p> <p>This procedure invalidates all cached Spark plans that reference the affected table.</p>"},{"location":"spark-procedures/#usage_1","title":"Usage","text":"Argument Name Required? Type Description <code>table</code> \u2714\ufe0f string Name of the table to update <code>snapshot_id</code> \u2714\ufe0f long Snapshot ID to rollback to"},{"location":"spark-procedures/#output","title":"Output","text":"Output Name Type Description <code>previous_snapshot_id</code> long The current snapshot ID before the rollback <code>current_snapshot_id</code> long The new current snapshot ID"},{"location":"spark-procedures/#example","title":"Example","text":"<p>Roll back table <code>db.sample</code> to snapshot ID <code>1</code>:</p> <pre><code>CALL catalog_name.system.rollback_to_snapshot('db.sample', 1)\n</code></pre>"},{"location":"spark-procedures/#rollback_to_timestamp","title":"<code>rollback_to_timestamp</code>","text":"<p>Roll back a table to the snapshot that was current at some time.</p> <p>Info</p> <p>This procedure invalidates all cached Spark plans that reference the affected table.</p>"},{"location":"spark-procedures/#usage_2","title":"Usage","text":"Argument Name Required? Type Description <code>table</code> \u2714\ufe0f string Name of the table to update <code>timestamp</code> \u2714\ufe0f timestamp A timestamp to rollback to"},{"location":"spark-procedures/#output_1","title":"Output","text":"Output Name Type Description <code>previous_snapshot_id</code> long The current snapshot ID before the rollback <code>current_snapshot_id</code> long The new current snapshot ID"},{"location":"spark-procedures/#example_1","title":"Example","text":"<p>Roll back <code>db.sample</code> to a specific day and time. <pre><code>CALL catalog_name.system.rollback_to_timestamp('db.sample', TIMESTAMP '2021-06-30 00:00:00.000')\n</code></pre></p>"},{"location":"spark-procedures/#set_current_snapshot","title":"<code>set_current_snapshot</code>","text":"<p>Sets the current snapshot ID for a table.</p> <p>Unlike rollback, the snapshot is not required to be an ancestor of the current table state.</p> <p>Info</p> <p>This procedure invalidates all cached Spark plans that reference the affected table.</p>"},{"location":"spark-procedures/#usage_3","title":"Usage","text":"Argument Name Required? Type Description <code>table</code> \u2714\ufe0f string Name of the table to update <code>snapshot_id</code> \u2714\ufe0f long Snapshot ID to set as current"},{"location":"spark-procedures/#output_2","title":"Output","text":"Output Name Type Description <code>previous_snapshot_id</code> long The current snapshot ID before the rollback <code>current_snapshot_id</code> long The new current snapshot ID"},{"location":"spark-procedures/#example_2","title":"Example","text":"<p>Set the current snapshot for <code>db.sample</code> to 1: <pre><code>CALL catalog_name.system.set_current_snapshot('db.sample', 1)\n</code></pre></p>"},{"location":"spark-procedures/#cherrypick_snapshot","title":"<code>cherrypick_snapshot</code>","text":"<p>Cherry-picks changes from a snapshot into the current table state.</p> <p>Cherry-picking creates a new snapshot from an existing snapshot without altering or removing the original.</p> <p>Only append and dynamic overwrite snapshots can be cherry-picked.</p> <p>Info</p> <p>This procedure invalidates all cached Spark plans that reference the affected table.</p>"},{"location":"spark-procedures/#usage_4","title":"Usage","text":"Argument Name Required? Type Description <code>table</code> \u2714\ufe0f string Name of the table to update <code>snapshot_id</code> \u2714\ufe0f long The snapshot ID to cherry-pick"},{"location":"spark-procedures/#output_3","title":"Output","text":"Output Name Type Description <code>source_snapshot_id</code> long The table's current snapshot before the cherry-pick <code>current_snapshot_id</code> long The snapshot ID created by applying the cherry-pick"},{"location":"spark-procedures/#examples","title":"Examples","text":"<p>Cherry-pick snapshot 1 <pre><code>CALL catalog_name.system.cherrypick_snapshot('my_table', 1)\n</code></pre></p> <p>Cherry-pick snapshot 1 with named args <pre><code>CALL catalog_name.system.cherrypick_snapshot(snapshot_id =&gt; 1, table =&gt; 'my_table' )\n</code></pre></p>"},{"location":"spark-procedures/#metadata-management","title":"Metadata management","text":"<p>Many maintenance actions can be performed using Iceberg stored procedures.</p>"},{"location":"spark-procedures/#expire_snapshots","title":"<code>expire_snapshots</code>","text":"<p>Each write/update/delete/upsert/compaction in Iceberg produces a new snapshot while keeping the old data and metadata around for snapshot isolation and time travel. The <code>expire_snapshots</code> procedure can be used to remove older snapshots and their files which are no longer needed.</p> <p>This procedure will remove old snapshots and data files which are uniquely required by those old snapshots. This means the <code>expire_snapshots</code> procedure will never remove files which are still required by a non-expired snapshot.</p>"},{"location":"spark-procedures/#usage_5","title":"Usage","text":"Argument Name Required? Type Description <code>table</code> \u2714\ufe0f string Name of the table to update <code>older_than</code> \ufe0f timestamp Timestamp before which snapshots will be removed (Default: 5 days ago) <code>retain_last</code> int Number of ancestor snapshots to preserve regardless of <code>older_than</code> (defaults to 1) <code>max_concurrent_deletes</code> int Size of the thread pool used for delete file actions (by default, no thread pool is used) <code>stream_results</code> boolean When true, deletion files will be sent to Spark driver by RDD partition (by default, all the files will be sent to Spark driver). This option is recommended to set to <code>true</code> to prevent Spark driver OOM from large file size <code>snapshot_ids</code> array of long Array of snapshot IDs to expire. <p>If <code>older_than</code> and <code>retain_last</code> are omitted, the table's expiration properties will be used.</p>"},{"location":"spark-procedures/#output_4","title":"Output","text":"Output Name Type Description <code>deleted_data_files_count</code> long Number of data files deleted by this operation <code>deleted_position_delete_files_count</code> long Number of position delete files deleted by this operation <code>deleted_equality_delete_files_count</code> long Number of equality delete files deleted by this operation <code>deleted_manifest_files_count</code> long Number of manifest files deleted by this operation <code>deleted_manifest_lists_count</code> long Number of manifest List files deleted by this operation"},{"location":"spark-procedures/#examples_1","title":"Examples","text":"<p>Remove snapshots older than specific day and time, but retain the last 100 snapshots:</p> <pre><code>CALL hive_prod.system.expire_snapshots('db.sample', TIMESTAMP '2021-06-30 00:00:00.000', 100)\n</code></pre> <p>Remove snapshots with snapshot ID <code>123</code> (note that this snapshot ID should not be the current snapshot):</p> <pre><code>CALL hive_prod.system.expire_snapshots(table =&gt; 'db.sample', snapshot_ids =&gt; ARRAY(123))\n</code></pre>"},{"location":"spark-procedures/#remove_orphan_files","title":"<code>remove_orphan_files</code>","text":"<p>Used to remove files which are not referenced in any metadata files of an Iceberg table and can thus be considered \"orphaned\".</p>"},{"location":"spark-procedures/#usage_6","title":"Usage","text":"Argument Name Required? Type Description <code>table</code> \u2714\ufe0f string Name of the table to clean <code>older_than</code> \ufe0f timestamp Remove orphan files created before this timestamp (Defaults to 3 days ago) <code>location</code> string Directory to look for files in (defaults to the table's location) <code>dry_run</code> boolean When true, don't actually remove files (defaults to false) <code>max_concurrent_deletes</code> int Size of the thread pool used for delete file actions (by default, no thread pool is used)"},{"location":"spark-procedures/#output_5","title":"Output","text":"Output Name Type Description <code>orphan_file_location</code> String The path to each file determined to be an orphan by this command"},{"location":"spark-procedures/#examples_2","title":"Examples","text":"<p>List all the files that are candidates for removal by performing a dry run of the <code>remove_orphan_files</code> command on this table without actually removing them: <pre><code>CALL catalog_name.system.remove_orphan_files(table =&gt; 'db.sample', dry_run =&gt; true)\n</code></pre></p> <p>Remove any files in the <code>tablelocation/data</code> folder which are not known to the table <code>db.sample</code>. <pre><code>CALL catalog_name.system.remove_orphan_files(table =&gt; 'db.sample', location =&gt; 'tablelocation/data')\n</code></pre></p>"},{"location":"spark-procedures/#rewrite_data_files","title":"<code>rewrite_data_files</code>","text":"<p>Iceberg tracks each data file in a table. More data files leads to more metadata stored in manifest files, and small data files causes an unnecessary amount of metadata and less efficient queries from file open costs.</p> <p>Iceberg can compact data files in parallel using Spark with the <code>rewriteDataFiles</code> action. This will combine small files into larger files to reduce metadata overhead and runtime file open cost.</p>"},{"location":"spark-procedures/#usage_7","title":"Usage","text":"Argument Name Required? Type Description <code>table</code> \u2714\ufe0f string Name of the table to update <code>strategy</code> string Name of the strategy - binpack or sort. Defaults to binpack strategy <code>sort_order</code> string For Zorder use a comma separated list of columns within zorder(). (Supported in Spark 3.2 and Above) Example: zorder(c1,c2,c3). Else, Comma separated sort orders in the format (ColumnName SortDirection NullOrder). Where SortDirection can be ASC or DESC. NullOrder can be NULLS FIRST or NULLS LAST. Defaults to the table's sort order <code>options</code> \ufe0f map Options to be used for actions <code>where</code> \ufe0f string predicate as a string used for filtering the files. Note that all files that may contain data matching the filter will be selected for rewriting <p>See the <code>RewriteDataFiles</code> Javadoc,  <code>BinPackStrategy</code> Javadoc and  <code>SortStrategy</code> Javadoc for list of all the supported options for this action.</p>"},{"location":"spark-procedures/#output_6","title":"Output","text":"Output Name Type Description <code>rewritten_data_files_count</code> int Number of data which were re-written by this command <code>added_data_files_count</code> int Number of new data files which were written by this command"},{"location":"spark-procedures/#examples_3","title":"Examples","text":"<p>Rewrite the data files in table <code>db.sample</code> using the default rewrite algorithm of bin-packing to combine small files  and also split large files according to the default write size of the table. <pre><code>CALL catalog_name.system.rewrite_data_files('db.sample')\n</code></pre></p> <p>Rewrite the data files in table <code>db.sample</code> by sorting all the data on id and name  using the same defaults as bin-pack to determine which files to rewrite. <pre><code>CALL catalog_name.system.rewrite_data_files(table =&gt; 'db.sample', strategy =&gt; 'sort', sort_order =&gt; 'id DESC NULLS LAST,name ASC NULLS FIRST')\n</code></pre></p> <p>Rewrite the data files in table <code>db.sample</code> by zOrdering on column c1 and c2. Using the same defaults as bin-pack to determine which files to rewrite. <pre><code>CALL catalog_name.system.rewrite_data_files(table =&gt; 'db.sample', strategy =&gt; 'sort', sort_order =&gt; 'zorder(c1,c2)')\n</code></pre></p> <p>Rewrite the data files in table <code>db.sample</code> using bin-pack strategy in any partition where more than 2 or more files need to be rewritten. <pre><code>CALL catalog_name.system.rewrite_data_files(table =&gt; 'db.sample', options =&gt; map('min-input-files','2'))\n</code></pre></p> <p>Rewrite the data files in table <code>db.sample</code> and select the files that may contain data matching the filter (id = 3 and name = \"foo\") to be rewritten. <pre><code>CALL catalog_name.system.rewrite_data_files(table =&gt; 'db.sample', where =&gt; 'id = 3 and name = \"foo\"')\n</code></pre></p>"},{"location":"spark-procedures/#rewrite_manifests","title":"<code>rewrite_manifests</code>","text":"<p>Rewrite manifests for a table to optimize scan planning.</p> <p>Data files in manifests are sorted by fields in the partition spec. This procedure runs in parallel using a Spark job.</p> <p>See the <code>RewriteManifests</code> Javadoc to see more configuration options.</p> <p>Info</p> <p>This procedure invalidates all cached Spark plans that reference the affected table.</p>"},{"location":"spark-procedures/#usage_8","title":"Usage","text":"Argument Name Required? Type Description <code>table</code> \u2714\ufe0f string Name of the table to update <code>use_caching</code> \ufe0f boolean Use Spark caching during operation (defaults to true)"},{"location":"spark-procedures/#output_7","title":"Output","text":"Output Name Type Description <code>rewritten_manifests_count</code> int Number of manifests which were re-written by this command <code>added_mainfests_count</code> int Number of new manifest files which were written by this command"},{"location":"spark-procedures/#examples_4","title":"Examples","text":"<p>Rewrite the manifests in table <code>db.sample</code> and align manifest files with table partitioning. <pre><code>CALL catalog_name.system.rewrite_manifests('db.sample')\n</code></pre></p> <p>Rewrite the manifests in table <code>db.sample</code> and disable the use of Spark caching. This could be done to avoid memory issues on executors. <pre><code>CALL catalog_name.system.rewrite_manifests('db.sample', false)\n</code></pre></p>"},{"location":"spark-procedures/#table-migration","title":"Table migration","text":"<p>The <code>snapshot</code> and <code>migrate</code> procedures help test and migrate existing Hive or Spark tables to Iceberg.</p>"},{"location":"spark-procedures/#snapshot","title":"<code>snapshot</code>","text":"<p>Create a light-weight temporary copy of a table for testing, without changing the source table.</p> <p>The newly created table can be changed or written to without affecting the source table, but the snapshot uses the original table's data files.</p> <p>When inserts or overwrites run on the snapshot, new files are placed in the snapshot table's location rather than the original table location.</p> <p>When finished testing a snapshot table, clean it up by running <code>DROP TABLE</code>.</p> <p>Info</p> <p>Because tables created by <code>snapshot</code> are not the sole owners of their data files, they are prohibited from actions like <code>expire_snapshots</code> which would physically delete data files. Iceberg deletes, which only effect metadata, are still allowed. In addition, any operations which affect the original data files will disrupt the Snapshot's  integrity. DELETE statements executed against the original Hive table will remove original data files and the <code>snapshot</code> table will no longer be able to access them.</p> <p>See <code>migrate</code> to replace an existing table with an Iceberg table.</p>"},{"location":"spark-procedures/#usage_9","title":"Usage","text":"Argument Name Required? Type Description <code>source_table</code> \u2714\ufe0f string Name of the table to snapshot <code>table</code> \u2714\ufe0f string Name of the new Iceberg table to create <code>location</code> string Table location for the new table (delegated to the catalog by default) <code>properties</code> \ufe0f map Properties to add to the newly created table"},{"location":"spark-procedures/#output_8","title":"Output","text":"Output Name Type Description <code>imported_files_count</code> long Number of files added to the new table"},{"location":"spark-procedures/#examples_5","title":"Examples","text":"<p>Make an isolated Iceberg table which references table <code>db.sample</code> named <code>db.snap</code> at the catalog's default location for <code>db.snap</code>. <pre><code>CALL catalog_name.system.snapshot('db.sample', 'db.snap')\n</code></pre></p> <p>Migrate an isolated Iceberg table which references table <code>db.sample</code> named <code>db.snap</code> at a manually specified location <code>/tmp/temptable/</code>. <pre><code>CALL catalog_name.system.snapshot('db.sample', 'db.snap', '/tmp/temptable/')\n</code></pre></p>"},{"location":"spark-procedures/#migrate","title":"<code>migrate</code>","text":"<p>Replace a table with an Iceberg table, loaded with the source's data files.</p> <p>Table schema, partitioning, properties, and location will be copied from the source table.</p> <p>Migrate will fail if any table partition uses an unsupported format. Supported formats are Avro, Parquet, and ORC. Existing data files are added to the Iceberg table's metadata and can be read using a name-to-id mapping created from the original table schema.</p> <p>To leave the original table intact while testing, use <code>snapshot</code> to create new temporary table that shares source data files and schema.</p> <p>By default, the original table is retained with the name <code>table_BACKUP_</code>.</p>"},{"location":"spark-procedures/#usage_10","title":"Usage","text":"Argument Name Required? Type Description <code>table</code> \u2714\ufe0f string Name of the table to migrate <code>properties</code> \ufe0f map Properties for the new Iceberg table <code>drop_backup</code> boolean When true, the original table will not be retained as backup (defaults to false)"},{"location":"spark-procedures/#output_9","title":"Output","text":"Output Name Type Description <code>migrated_files_count</code> long Number of files appended to the Iceberg table"},{"location":"spark-procedures/#examples_6","title":"Examples","text":"<p>Migrate the table <code>db.sample</code> in Spark's default catalog to an Iceberg table and add a property 'foo' set to 'bar':</p> <pre><code>CALL catalog_name.system.migrate('spark_catalog.db.sample', map('foo', 'bar'))\n</code></pre> <p>Migrate <code>db.sample</code> in the current catalog to an Iceberg table without adding any additional properties: <pre><code>CALL catalog_name.system.migrate('db.sample')\n</code></pre></p>"},{"location":"spark-procedures/#add_files","title":"<code>add_files</code>","text":"<p>Attempts to directly add files from a Hive or file based table into a given Iceberg table. Unlike migrate or snapshot, <code>add_files</code> can import files from a specific partition or partitions and does not create a new Iceberg table. This command will create metadata for the new files and will not move them. This procedure will not analyze the schema  of the files to determine if they actually match the schema of the Iceberg table. Upon completion, the Iceberg table  will then treat these files as if they are part of the set of files  owned by Iceberg. This means any subsequent  <code>expire_snapshot</code> calls will be able to physically delete the added files. This method should not be used if  <code>migrate</code> or <code>snapshot</code> are possible.</p>"},{"location":"spark-procedures/#usage_11","title":"Usage","text":"Argument Name Required? Type Description <code>table</code> \u2714\ufe0f string Table which will have files added to <code>source_table</code> \u2714\ufe0f string Table where files should come from, paths are also possible in the form of `file_format`.`path` <code>partition_filter</code> \ufe0f map A map of partitions in the source table to import from <code>check_duplicate_files</code> \ufe0f boolean Whether to prevent files existing in the table from being added (defaults to true) <p>Warning : Schema is not validated, adding files with different schema to the Iceberg table will cause issues.</p> <p>Warning : Files added by this method can be physically deleted by Iceberg operations</p>"},{"location":"spark-procedures/#output_10","title":"Output","text":"Output Name Type Description <code>added_files_count</code> long The number of files added by this command <code>changed_partition_count</code> long The number of partitioned changed by this command <p>Warning</p> <p>changed_partition_count will be 0 when table property <code>compatibility.snapshot-id-inheritance.enabled</code> is set to true</p>"},{"location":"spark-procedures/#examples_7","title":"Examples","text":"<p>Add the files from table <code>db.src_table</code>, a Hive or Spark table registered in the session Catalog, to Iceberg table <code>db.tbl</code>. Only add files that exist within partitions where <code>part_col_1</code> is equal to <code>A</code>. <pre><code>CALL spark_catalog.system.add_files(\ntable =&gt; 'db.tbl',\nsource_table =&gt; 'db.src_tbl',\npartition_filter =&gt; map('part_col_1', 'A')\n)\n</code></pre></p> <p>Add files from a <code>parquet</code> file based table at location <code>path/to/table</code> to the Iceberg table <code>db.tbl</code>. Add all files regardless of what partition they belong to. <pre><code>CALL spark_catalog.system.add_files(\ntable =&gt; 'db.tbl',\nsource_table =&gt; '`parquet`.`path/to/table`'\n)\n</code></pre></p>"},{"location":"spark-procedures/#register_table","title":"<code>register_table</code>","text":"<p>Creates a catalog entry for a metadata.json file which already exists but does not have a corresponding catalog identifier.</p>"},{"location":"spark-procedures/#usage_12","title":"Usage","text":"Argument Name Required? Type Description <code>table</code> \u2714\ufe0f string Table which is to be registered <code>metadata_file</code> \u2714\ufe0f string Metadata file which is to be registered as a new catalog identifier <p>Warning</p> <p>Having the same metadata.json registered in more than one catalog can lead to missing updates, loss of data, and table corruption. Only use this procedure when the table is no longer registered in an existing catalog, or you are moving a table between catalogs.</p>"},{"location":"spark-procedures/#output_11","title":"Output","text":"Output Name Type Description <code>current_snapshot_id</code> long The current snapshot ID of the newly registered Iceberg table <code>total_records_count</code> long Total records count of the newly registered Iceberg table <code>total_data_files_count</code> long Total data files count of the newly registered Iceberg table"},{"location":"spark-procedures/#examples_8","title":"Examples","text":"<p>Register a new table as <code>db.tbl</code> to <code>spark_catalog</code> pointing to metadata.json file <code>path/to/metadata/file.json</code>. <pre><code>CALL spark_catalog.system.register_table(\ntable =&gt; 'db.tbl',\nmetadata_file =&gt; 'path/to/metadata/file.json'\n)\n</code></pre></p>"},{"location":"spark-procedures/#metadata-information","title":"Metadata information","text":""},{"location":"spark-procedures/#ancestors_of","title":"<code>ancestors_of</code>","text":"<p>Report the live snapshot IDs of parents of a specified snapshot</p>"},{"location":"spark-procedures/#usage_13","title":"Usage","text":"Argument Name Required? Type Description <code>table</code> \u2714\ufe0f string Name of the table to report live snapshot IDs <code>snapshot_id</code> \ufe0f long Use a specified snapshot to get the live snapshot IDs of parents <p>tip : Using snapshot_id</p> <p>Given snapshots history with roll back to B and addition of C' -&gt; D' <pre><code>A -&gt; B - &gt; C -&gt; D\n      \\ -&gt; C' -&gt; (D')\n</code></pre> Not specifying the snapshot ID would return A -&gt; B -&gt; C' -&gt; D', while providing the snapshot ID of D as an argument would return A-&gt; B -&gt; C -&gt; D</p>"},{"location":"spark-procedures/#output_12","title":"Output","text":"Output Name Type Description <code>snapshot_id</code> long the ancestor snapshot id <code>timestamp</code> long snapshot creation time"},{"location":"spark-procedures/#examples_9","title":"Examples","text":"<p>Get all the snapshot ancestors of current snapshots(default) <pre><code>CALL spark_catalog.system.ancestors_of('db.tbl')\n</code></pre></p> <p>Get all the snapshot ancestors by a particular snapshot <pre><code>CALL spark_catalog.system.ancestors_of('db.tbl', 1)\nCALL spark_catalog.system.ancestors_of(snapshot_id =&gt; 1, table =&gt; 'db.tbl')\n</code></pre></p>"},{"location":"spark-procedures/#change-data-capture","title":"Change Data Capture","text":""},{"location":"spark-procedures/#create_changelog_view","title":"<code>create_changelog_view</code>","text":"<p>Creates a view that contains the changes from a given table. </p>"},{"location":"spark-procedures/#usage_14","title":"Usage","text":"Argument Name Required? Type Description <code>table</code> \u2714\ufe0f string Name of the source table for the changelog <code>changelog_view</code> string Name of the view to create <code>options</code> map A map of Spark read options to use <code>compute_updates</code> boolean Whether to compute pre/post update images (see below for more information). Defaults to false. <code>identifier_columns</code> array The list of identifier columns to compute updates. If the argument <code>compute_updates</code> is set to true and <code>identifier_columns</code> are not provided, the table\u2019s current identifier fields will be used to compute updates. <code>remove_carryovers</code> boolean Whether to remove carry-over rows (see below for more information). Defaults to true. <p>Here is a list of commonly used Spark read options: * <code>start-snapshot-id</code>: the exclusive start snapshot ID. If not provided, it reads from the table\u2019s first snapshot inclusively.  * <code>end-snapshot-id</code>: the inclusive end snapshot id, default to table's current snapshot.                                                                                                                                           * <code>start-timestamp</code>: the exclusive start timestamp. If not provided, it reads from the table\u2019s first snapshot inclusively. * <code>end-timestamp</code>: the inclusive end timestamp, default to table's current snapshot.                                                                                  </p>"},{"location":"spark-procedures/#output_13","title":"Output","text":"Output Name Type Description <code>changelog_view</code> string The name of the created changelog view"},{"location":"spark-procedures/#examples_10","title":"Examples","text":"<p>Create a changelog view <code>tbl_changes</code> based on the changes that happened between snapshot <code>1</code> (exclusive) and <code>2</code> (inclusive). <pre><code>CALL spark_catalog.system.create_changelog_view(\ntable =&gt; 'db.tbl',\noptions =&gt; map('start-snapshot-id','1','end-snapshot-id', '2')\n)\n</code></pre></p> <p>Create a changelog view <code>my_changelog_view</code> based on the changes that happened between timestamp <code>1678335750489</code> (exclusive) and <code>1678992105265</code> (inclusive). <pre><code>CALL spark_catalog.system.create_changelog_view(\ntable =&gt; 'db.tbl',\noptions =&gt; map('start-timestamp','1678335750489','end-timestamp', '1678992105265'),\nchangelog_view =&gt; 'my_changelog_view'\n)\n</code></pre></p> <p>Create a changelog view that computes updates based on the identifier columns <code>id</code> and <code>name</code>. <pre><code>CALL spark_catalog.system.create_changelog_view(\ntable =&gt; 'db.tbl',\noptions =&gt; map('start-snapshot-id','1','end-snapshot-id', '2'),\nidentifier_columns =&gt; array('id', 'name')\n)\n</code></pre></p> <p>Once the changelog view is created, you can query the view to see the changes that happened between the snapshots. <pre><code>SELECT * FROM tbl_changes\n</code></pre> <pre><code>SELECT * FROM tbl_changes where _change_type = 'INSERT' AND id = 3 ORDER BY _change_ordinal\n</code></pre> Please note that the changelog view includes Change Data Capture(CDC) metadata columns that provide additional information about the changes being tracked. These columns are: - <code>_change_type</code>: the type of change. It has one of the following values: <code>INSERT</code>, <code>DELETE</code>, <code>UPDATE_BEFORE</code>, or <code>UPDATE_AFTER</code>. - <code>_change_ordinal</code>: the order of changes - <code>_commit_snapshot_id</code>: the snapshot ID where the change occurred</p> <p>Here is an example of corresponding results. It shows that the first snapshot inserted 2 records, and the second snapshot deleted 1 record. </p> id name _change_type _change_ordinal _change_snapshot_id 1 Alice INSERT 0 5390529835796506035 2 Bob INSERT 0 5390529835796506035 1 Alice DELETE 1 8764748981452218370"},{"location":"spark-procedures/#carry-over-rows","title":"Carry-over Rows","text":"<p>The procedure removes the carry-over rows by default. Carry-over rows are the result of row-level operations(<code>MERGE</code>, <code>UPDATE</code> and <code>DELETE</code>) when using copy-on-write. For example, given a file which contains row1 <code>(id=1, name='Alice')</code> and row2 <code>(id=2, name='Bob')</code>. A copy-on-write delete of row2 would require erasing this file and preserving row1 in a new file. The changelog table reports this as the following pair of rows, despite it not being an actual change to the table.</p> id name _change_type 1 Alice DELETE 1 Alice INSERT <p>By default, this view finds the carry-over rows and removes them from the result. User can disable this behavior by setting the <code>remove_carryovers</code> option to <code>false</code>.</p>"},{"location":"spark-procedures/#prepost-update-images","title":"Pre/Post Update Images","text":"<p>The procedure computes the pre/post update images if configured. Pre/post update images are converted from a pair of a delete row and an insert row. Identifier columns are used for determining whether an insert and a delete record refer to the same row. If the two records share the same values for the identity columns they are considered to be before and after states of the same row. You can either set identifier fields in the table schema or input them as the procedure parameters.</p> <p>The following example shows pre/post update images computation with an identifier column(<code>id</code>), where a row deletion and an insertion with the same <code>id</code> are treated as a single update operation. Specifically, suppose we have the following pair of rows:</p> id name _change_type 3 Robert DELETE 3 Dan INSERT <p>In this case, the procedure marks the row before the update as an <code>UPDATE_BEFORE</code> image and the row after the update as an <code>UPDATE_AFTER</code> image, resulting in the following pre/post update images:</p> id name _change_type 3 Robert UPDATE_BEFORE 3 Dan UPDATE_AFTER"},{"location":"spark-queries/","title":"Queries","text":""},{"location":"spark-queries/#spark-queries","title":"Spark Queries","text":"<p>To use Iceberg in Spark, first configure Spark catalogs. Iceberg uses Apache Spark's DataSourceV2 API for data source and catalog implementations.</p>"},{"location":"spark-queries/#querying-with-sql","title":"Querying with SQL","text":"<p>In Spark 3, tables use identifiers that include a catalog name.</p> <pre><code>SELECT * FROM prod.db.table; -- catalog: prod, namespace: db, table: table\n</code></pre> <p>Metadata tables, like <code>history</code> and <code>snapshots</code>, can use the Iceberg table name as a namespace.</p> <p>For example, to read from the <code>files</code> metadata table for <code>prod.db.table</code>:</p> <pre><code>SELECT * FROM prod.db.table.files;\n</code></pre> content file_path file_format spec_id partition record_count file_size_in_bytes column_sizes value_counts null_value_counts nan_value_counts lower_bounds upper_bounds key_metadata split_offsets equality_ids sort_order_id 0 s3:/.../table/data/00000-3-8d6d60e8-d427-4809-bcf0-f5d45a4aad96.parquet PARQUET 0 {1999-01-01, 01} 1 597 [1 -&gt; 90, 2 -&gt; 62] [1 -&gt; 1, 2 -&gt; 1] [1 -&gt; 0, 2 -&gt; 0] [] [1 -&gt; , 2 -&gt; c] [1 -&gt; , 2 -&gt; c] null [4] null null 0 s3:/.../table/data/00001-4-8d6d60e8-d427-4809-bcf0-f5d45a4aad96.parquet PARQUET 0 {1999-01-01, 02} 1 597 [1 -&gt; 90, 2 -&gt; 62] [1 -&gt; 1, 2 -&gt; 1] [1 -&gt; 0, 2 -&gt; 0] [] [1 -&gt; , 2 -&gt; b] [1 -&gt; , 2 -&gt; b] null [4] null null 0 s3:/.../table/data/00002-5-8d6d60e8-d427-4809-bcf0-f5d45a4aad96.parquet PARQUET 0 {1999-01-01, 03} 1 597 [1 -&gt; 90, 2 -&gt; 62] [1 -&gt; 1, 2 -&gt; 1] [1 -&gt; 0, 2 -&gt; 0] [] [1 -&gt; , 2 -&gt; a] [1 -&gt; , 2 -&gt; a] null [4] null null"},{"location":"spark-queries/#querying-with-dataframes","title":"Querying with DataFrames","text":"<p>To load a table as a DataFrame, use <code>table</code>:</p> <pre><code>val df = spark.table(\"prod.db.table\")\n</code></pre>"},{"location":"spark-queries/#catalogs-with-dataframereader","title":"Catalogs with DataFrameReader","text":"<p>Paths and table names can be loaded with Spark's <code>DataFrameReader</code> interface. How tables are loaded depends on how the identifier is specified. When using <code>spark.read.format(\"iceberg\").load(table)</code> or <code>spark.table(table)</code> the <code>table</code> variable can take a number of forms as listed below:</p> <ul> <li><code>file:///path/to/table</code>: loads a HadoopTable at given path</li> <li><code>tablename</code>: loads <code>currentCatalog.currentNamespace.tablename</code></li> <li><code>catalog.tablename</code>: loads <code>tablename</code> from the specified catalog.</li> <li><code>namespace.tablename</code>: loads <code>namespace.tablename</code> from current catalog</li> <li><code>catalog.namespace.tablename</code>: loads <code>namespace.tablename</code> from the specified catalog.</li> <li><code>namespace1.namespace2.tablename</code>: loads <code>namespace1.namespace2.tablename</code> from current catalog</li> </ul> <p>The above list is in order of priority. For example: a matching catalog will take priority over any namespace resolution.</p>"},{"location":"spark-queries/#time-travel","title":"Time travel","text":""},{"location":"spark-queries/#sql","title":"SQL","text":"<p>Spark 3.3 and later supports time travel in SQL queries using <code>TIMESTAMP AS OF</code> or <code>VERSION AS OF</code> clauses. The <code>VERSION AS OF</code> clause can contain a long snapshot ID or a string branch or tag name.</p> <p>Info</p> <p>Note: If the name of a branch or tag is the same as a snapshot ID, then the snapshot which is selected for time travel is the snapshot with the given snapshot ID. For example, consider the case where there is a tag named '1' and it references snapshot with ID 2.  If the version travel clause is <code>VERSION AS OF '1'</code>, time travel will be done to the snapshot with ID 1.  If this is not desired, rename the tag or branch with a well-defined prefix such as 'snapshot-1'.</p> <pre><code>-- time travel to October 26, 1986 at 01:21:00\nSELECT * FROM prod.db.table TIMESTAMP AS OF '1986-10-26 01:21:00';\n-- time travel to snapshot with id 10963874102873L\nSELECT * FROM prod.db.table VERSION AS OF 10963874102873;\n-- time travel to the head snapshot of audit-branch\nSELECT * FROM prod.db.table VERSION AS OF 'audit-branch';\n-- time travel to the snapshot referenced by the tag historical-snapshot\nSELECT * FROM prod.db.table VERSION AS OF 'historical-snapshot';\n</code></pre> <p>In addition, <code>FOR SYSTEM_TIME AS OF</code> and <code>FOR SYSTEM_VERSION AS OF</code> clauses are also supported:</p> <pre><code>SELECT * FROM prod.db.table FOR SYSTEM_TIME AS OF '1986-10-26 01:21:00';\nSELECT * FROM prod.db.table FOR SYSTEM_VERSION AS OF 10963874102873;\nSELECT * FROM prod.db.table FOR SYSTEM_VERSION AS OF 'audit-branch';\nSELECT * FROM prod.db.table FOR SYSTEM_VERSION AS OF 'historical-snapshot';\n</code></pre> <p>Timestamps may also be supplied as a Unix timestamp, in seconds:</p> <pre><code>-- timestamp in seconds\nSELECT * FROM prod.db.table TIMESTAMP AS OF 499162860;\nSELECT * FROM prod.db.table FOR SYSTEM_TIME AS OF 499162860;\n</code></pre>"},{"location":"spark-queries/#dataframe","title":"DataFrame","text":"<p>To select a specific table snapshot or the snapshot at some time in the DataFrame API, Iceberg supports four Spark read options:</p> <ul> <li><code>snapshot-id</code> selects a specific table snapshot</li> <li><code>as-of-timestamp</code> selects the current snapshot at a timestamp, in milliseconds</li> <li><code>branch</code> selects the head snapshot of the specified branch. Note that currently branch cannot be combined with as-of-timestamp.</li> <li><code>tag</code> selects the snapshot associated with the specified tag. Tags cannot be combined with <code>as-of-timestamp</code>.</li> </ul> <pre><code>// time travel to October 26, 1986 at 01:21:00\nspark.read\n.option(\"as-of-timestamp\", \"499162860000\")\n.format(\"iceberg\")\n.load(\"path/to/table\")\n</code></pre> <pre><code>// time travel to snapshot with ID 10963874102873L\nspark.read\n.option(\"snapshot-id\", 10963874102873L)\n.format(\"iceberg\")\n.load(\"path/to/table\")\n</code></pre> <pre><code>// time travel to tag historical-snapshot\nspark.read\n.option(SparkReadOptions.TAG, \"historical-snapshot\")\n.format(\"iceberg\")\n.load(\"path/to/table\")\n</code></pre> <pre><code>// time travel to the head snapshot of audit-branch\nspark.read\n.option(SparkReadOptions.BRANCH, \"audit-branch\")\n.format(\"iceberg\")\n.load(\"path/to/table\")\n</code></pre> <p>Info</p> <p>Spark 3.0 and earlier versions do not support using <code>option</code> with <code>table</code> in DataFrameReader commands. All options will be silently  ignored. Do not use <code>table</code> when attempting to time-travel or use other options. See SPARK-32592.</p>"},{"location":"spark-queries/#incremental-read","title":"Incremental read","text":"<p>To read appended data incrementally, use:</p> <ul> <li><code>start-snapshot-id</code> Start snapshot ID used in incremental scans (exclusive).</li> <li><code>end-snapshot-id</code> End snapshot ID used in incremental scans (inclusive). This is optional. Omitting it will default to the current snapshot.</li> </ul> <pre><code>// get the data added after start-snapshot-id (10963874102873L) until end-snapshot-id (63874143573109L)\nspark.read()\n.format(\"iceberg\")\n.option(\"start-snapshot-id\", \"10963874102873\")\n.option(\"end-snapshot-id\", \"63874143573109\")\n.load(\"path/to/table\")\n</code></pre> <p>Info</p> <p>Currently gets only the data from <code>append</code> operation. Cannot support <code>replace</code>, <code>overwrite</code>, <code>delete</code> operations. Incremental read works with both V1 and V2 format-version. Incremental read is not supported by Spark's SQL syntax.</p>"},{"location":"spark-queries/#inspecting-tables","title":"Inspecting tables","text":"<p>To inspect a table's history, snapshots, and other metadata, Iceberg supports metadata tables.</p> <p>Metadata tables are identified by adding the metadata table name after the original table name. For example, history for <code>db.table</code> is read using <code>db.table.history</code>.</p> <p>Info</p> <p>For Spark 3, prior to 3.2, the Spark session catalog does not support table names with multipart identifiers such as <code>catalog.database.table.metadata</code>. As a workaround, configure an <code>org.apache.iceberg.spark.SparkCatalog</code>, or use the Spark <code>DataFrameReader</code> API.</p>"},{"location":"spark-queries/#history","title":"History","text":"<p>To show table history:</p> <pre><code>SELECT * FROM prod.db.table.history;\n</code></pre> made_current_at snapshot_id parent_id is_current_ancestor 2019-02-08 03:29:51.215 5781947118336215154 NULL true 2019-02-08 03:47:55.948 5179299526185056830 5781947118336215154 true 2019-02-09 16:24:30.13 296410040247533544 5179299526185056830 false 2019-02-09 16:32:47.336 2999875608062437330 5179299526185056830 true 2019-02-09 19:42:03.919 8924558786060583479 2999875608062437330 true 2019-02-09 19:49:16.343 6536733823181975045 8924558786060583479 true <p>Info</p> <p>This shows a commit that was rolled back. The example has two snapshots with the same parent, and one is not an ancestor of the current table state.</p>"},{"location":"spark-queries/#metadata-log-entries","title":"Metadata Log Entries","text":"<p>To show table metadata log entries:</p> <pre><code>SELECT * from prod.db.table.metadata_log_entries;\n</code></pre> timestamp file latest_snapshot_id latest_schema_id latest_sequence_number 2022-07-28 10:43:52.93 s3://.../table/metadata/00000-9441e604-b3c2-498a-a45a-6320e8ab9006.metadata.json null null null 2022-07-28 10:43:57.487 s3://.../table/metadata/00001-f30823df-b745-4a0a-b293-7532e0c99986.metadata.json 170260833677645300 0 1 2022-07-28 10:43:58.25 s3://.../table/metadata/00002-2cc2837a-02dc-4687-acc1-b4d86ea486f4.metadata.json 958906493976709774 0 2"},{"location":"spark-queries/#snapshots","title":"Snapshots","text":"<p>To show the valid snapshots for a table:</p> <pre><code>SELECT * FROM prod.db.table.snapshots;\n</code></pre> committed_at snapshot_id parent_id operation manifest_list summary 2019-02-08 03:29:51.215 57897183625154 null append s3://.../table/metadata/snap-57897183625154-1.avro { added-records -&gt; 2478404, total-records -&gt; 2478404, added-data-files -&gt; 438, total-data-files -&gt; 438, spark.app.id -&gt; application_1520379288616_155055 } <p>You can also join snapshots to table history. For example, this query will show table history, with the application ID that wrote each snapshot:</p> <pre><code>select\nh.made_current_at,\ns.operation,\nh.snapshot_id,\nh.is_current_ancestor,\ns.summary['spark.app.id']\nfrom prod.db.table.history h\njoin prod.db.table.snapshots s\non h.snapshot_id = s.snapshot_id\norder by made_current_at\n</code></pre> made_current_at operation snapshot_id is_current_ancestor summary[spark.app.id] 2019-02-08 03:29:51.215 append 57897183625154 true application_1520379288616_155055 2019-02-09 16:24:30.13 delete 29641004024753 false application_1520379288616_151109 2019-02-09 16:32:47.336 append 57897183625154 true application_1520379288616_155055 2019-02-08 03:47:55.948 overwrite 51792995261850 true application_1520379288616_152431"},{"location":"spark-queries/#files","title":"Files","text":"<p>To show a table's current data files:</p> <pre><code>SELECT * FROM prod.db.table.files;\n</code></pre> content file_path file_format spec_id partition record_count file_size_in_bytes column_sizes value_counts null_value_counts nan_value_counts lower_bounds upper_bounds key_metadata split_offsets equality_ids sort_order_id 0 s3:/.../table/data/00000-3-8d6d60e8-d427-4809-bcf0-f5d45a4aad96.parquet PARQUET 0 {1999-01-01, 01} 1 597 [1 -&gt; 90, 2 -&gt; 62] [1 -&gt; 1, 2 -&gt; 1] [1 -&gt; 0, 2 -&gt; 0] [] [1 -&gt; , 2 -&gt; c] [1 -&gt; , 2 -&gt; c] null [4] null null 0 s3:/.../table/data/00001-4-8d6d60e8-d427-4809-bcf0-f5d45a4aad96.parquet PARQUET 0 {1999-01-01, 02} 1 597 [1 -&gt; 90, 2 -&gt; 62] [1 -&gt; 1, 2 -&gt; 1] [1 -&gt; 0, 2 -&gt; 0] [] [1 -&gt; , 2 -&gt; b] [1 -&gt; , 2 -&gt; b] null [4] null null 0 s3:/.../table/data/00002-5-8d6d60e8-d427-4809-bcf0-f5d45a4aad96.parquet PARQUET 0 {1999-01-01, 03} 1 597 [1 -&gt; 90, 2 -&gt; 62] [1 -&gt; 1, 2 -&gt; 1] [1 -&gt; 0, 2 -&gt; 0] [] [1 -&gt; , 2 -&gt; a] [1 -&gt; , 2 -&gt; a] null [4] null null"},{"location":"spark-queries/#manifests","title":"Manifests","text":"<p>To show a table's current file manifests:</p> <pre><code>SELECT * FROM prod.db.table.manifests;\n</code></pre> path length partition_spec_id added_snapshot_id added_data_files_count existing_data_files_count deleted_data_files_count partition_summaries s3://.../table/metadata/45b5290b-ee61-4788-b324-b1e2735c0e10-m0.avro 4479 0 6668963634911763636 8 0 0 [[false,null,2019-05-13,2019-05-15]] <p>Note: 1. Fields within <code>partition_summaries</code> column of the manifests table correspond to <code>field_summary</code> structs within manifest list, with the following order:     - <code>contains_null</code>     - <code>contains_nan</code>     - <code>lower_bound</code>     - <code>upper_bound</code> 2. <code>contains_nan</code> could return null, which indicates that this information is not available from the file's metadata.     This usually occurs when reading from V1 table, where <code>contains_nan</code> is not populated.</p>"},{"location":"spark-queries/#partitions","title":"Partitions","text":"<p>To show a table's current partitions:</p> <pre><code>SELECT * FROM prod.db.table.partitions;\n</code></pre> partition record_count file_count spec_id {20211001, 11} 1 1 0 {20211002, 11} 1 1 0 {20211001, 10} 1 1 0 {20211002, 10} 1 1 0 <p>Note: 1. For unpartitioned tables, the partitions table will contain only the record_count and file_count columns.</p> <ol> <li>The partitions metadata table shows partitions with data files or delete files in the current snapshot. However, delete files are not applied, and so in some cases partitions may be shown even though all their data rows are marked deleted by delete files.</li> </ol>"},{"location":"spark-queries/#all-metadata-tables","title":"All Metadata Tables","text":"<p>These tables are unions of the metadata tables specific to the current snapshot, and return metadata across all snapshots.</p> <p>Danger</p> <p>The \"all\" metadata tables may produce more than one row per data file or manifest file because metadata files may be part of more than one table snapshot.</p>"},{"location":"spark-queries/#all-data-files","title":"All Data Files","text":"<p>To show all of the table's data files and each file's metadata:</p> <pre><code>SELECT * FROM prod.db.table.all_data_files;\n</code></pre> content file_path file_format partition record_count file_size_in_bytes column_sizes value_counts null_value_counts nan_value_counts lower_bounds upper_bounds key_metadata split_offsets equality_ids sort_order_id 0 s3://.../dt=20210102/00000-0-756e2512-49ae-45bb-aae3-c0ca475e7879-00001.parquet PARQUET {20210102} 14 2444 {1 -&gt; 94, 2 -&gt; 17} {1 -&gt; 14, 2 -&gt; 14} {1 -&gt; 0, 2 -&gt; 0} {} {1 -&gt; 1, 2 -&gt; 20210102} {1 -&gt; 2, 2 -&gt; 20210102} null [4] null 0 0 s3://.../dt=20210103/00000-0-26222098-032f-472b-8ea5-651a55b21210-00001.parquet PARQUET {20210103} 14 2444 {1 -&gt; 94, 2 -&gt; 17} {1 -&gt; 14, 2 -&gt; 14} {1 -&gt; 0, 2 -&gt; 0} {} {1 -&gt; 1, 2 -&gt; 20210103} {1 -&gt; 3, 2 -&gt; 20210103} null [4] null 0 0 s3://.../dt=20210104/00000-0-a3bb1927-88eb-4f1c-bc6e-19076b0d952e-00001.parquet PARQUET {20210104} 14 2444 {1 -&gt; 94, 2 -&gt; 17} {1 -&gt; 14, 2 -&gt; 14} {1 -&gt; 0, 2 -&gt; 0} {} {1 -&gt; 1, 2 -&gt; 20210104} {1 -&gt; 3, 2 -&gt; 20210104} null [4] null 0"},{"location":"spark-queries/#all-manifests","title":"All Manifests","text":"<p>To show all of the table's manifest files:</p> <pre><code>SELECT * FROM prod.db.table.all_manifests;\n</code></pre> path length partition_spec_id added_snapshot_id added_data_files_count existing_data_files_count deleted_data_files_count partition_summaries s3://.../metadata/a85f78c5-3222-4b37-b7e4-faf944425d48-m0.avro 6376 0 6272782676904868561 2 0 0 [{false, false, 20210101, 20210101}] <p>Note: 1. Fields within <code>partition_summaries</code> column of the manifests table correspond to <code>field_summary</code> structs within manifest list, with the following order:     - <code>contains_null</code>     - <code>contains_nan</code>     - <code>lower_bound</code>     - <code>upper_bound</code> 2. <code>contains_nan</code> could return null, which indicates that this information is not available from the file's metadata.     This usually occurs when reading from V1 table, where <code>contains_nan</code> is not populated.</p>"},{"location":"spark-queries/#references","title":"References","text":"<p>To show a table's known snapshot references:</p> <pre><code>SELECT * FROM prod.db.table.refs;\n</code></pre> name type snapshot_id max_reference_age_in_ms min_snapshots_to_keep max_snapshot_age_in_ms main BRANCH 4686954189838128572 10 20 30 testTag TAG 4686954189838128572 10 null null"},{"location":"spark-queries/#inspecting-with-dataframes","title":"Inspecting with DataFrames","text":"<p>Metadata tables can be loaded using the DataFrameReader API:</p> <pre><code>// named metastore table\nspark.read.format(\"iceberg\").load(\"db.table.files\")\n// Hadoop path table\nspark.read.format(\"iceberg\").load(\"hdfs://nn:8020/path/to/table#files\")\n</code></pre>"},{"location":"spark-queries/#time-travel-with-metadata-tables","title":"Time Travel with Metadata Tables","text":"<p>To inspect a tables's metadata with the time travel feature:</p> <pre><code>-- get the table's file manifests at timestamp Sep 20, 2021 08:00:00\nSELECT * FROM prod.db.table.manifests TIMESTAMP AS OF '2021-09-20 08:00:00';\n-- get the table's partitions with snapshot id 10963874102873L\nSELECT * FROM prod.db.table.partitions VERSION AS OF 10963874102873;\n</code></pre> <p>Metadata tables can also be inspected with time travel using the DataFrameReader API:</p> <pre><code>// load the table's file metadata at snapshot-id 10963874102873 as DataFrame\nspark.read.format(\"iceberg\").option(\"snapshot-id\", 10963874102873L).load(\"db.table.files\")\n</code></pre>"},{"location":"spark-structured-streaming/","title":"Structured Streaming","text":""},{"location":"spark-structured-streaming/#spark-structured-streaming","title":"Spark Structured Streaming","text":"<p>Iceberg uses Apache Spark's DataSourceV2 API for data source and catalog implementations. Spark DSv2 is an evolving API with different levels of support in Spark versions.</p> <p>As of Spark 3, DataFrame reads and writes are supported.</p>"},{"location":"spark-structured-streaming/#streaming-reads","title":"Streaming Reads","text":"<p>Iceberg supports processing incremental data in spark structured streaming jobs which starts from a historical timestamp:</p> <pre><code>val df = spark.readStream\n.format(\"iceberg\")\n.option(\"stream-from-timestamp\", Long.toString(streamStartTimestamp))\n.load(\"database.table_name\")\n</code></pre> <p>Warning</p> <p>Iceberg only supports reading data from append snapshots. Overwrite snapshots cannot be processed and will cause an exception by default. Overwrites may be ignored by setting <code>streaming-skip-overwrite-snapshots=true</code>. Similarly, delete snapshots will cause an exception by default, and deletes may be ignored by setting <code>streaming-skip-delete-snapshots=true</code>.</p>"},{"location":"spark-structured-streaming/#streaming-writes","title":"Streaming Writes","text":"<p>To write values from streaming query to Iceberg table, use <code>DataStreamWriter</code>:</p> <pre><code>val tableIdentifier: String = ...\ndata.writeStream\n.format(\"iceberg\")\n.outputMode(\"append\")\n.trigger(Trigger.ProcessingTime(1, TimeUnit.MINUTES))\n.option(\"path\", tableIdentifier)\n.option(\"checkpointLocation\", checkpointPath)\n.start()\n</code></pre> <p>The <code>tableIdentifier</code> can be:</p> <ul> <li>The fully-qualified path to a HDFS table, like <code>hdfs://nn:8020/path/to/table</code></li> <li>A table name if the table is tracked by a catalog, like <code>database.table_name</code></li> </ul> <p>Iceberg doesn't support \"continuous processing\", as it doesn't provide the interface to \"commit\" the output.</p> <p>Iceberg supports <code>append</code> and <code>complete</code> output modes:</p> <ul> <li><code>append</code>: appends the rows of every micro-batch to the table</li> <li><code>complete</code>: replaces the table contents every micro-batch</li> </ul> <p>The table should be created in prior to start the streaming query. Refer SQL create table on Spark page to see how to create the Iceberg table.</p>"},{"location":"spark-structured-streaming/#writing-against-partitioned-table","title":"Writing against partitioned table","text":"<p>Iceberg requires the data to be sorted according to the partition spec per task (Spark partition) in prior to write against partitioned table. For batch queries you're encouraged to do explicit sort to fulfill the requirement (see here), but the approach would bring additional latency as repartition and sort are considered as heavy operations for streaming workload. To avoid additional latency, you can enable fanout writer to eliminate the requirement.</p> <pre><code>val tableIdentifier: String = ...\ndata.writeStream\n.format(\"iceberg\")\n.outputMode(\"append\")\n.trigger(Trigger.ProcessingTime(1, TimeUnit.MINUTES))\n.option(\"path\", tableIdentifier)\n.option(\"fanout-enabled\", \"true\")\n.option(\"checkpointLocation\", checkpointPath)\n.start()\n</code></pre> <p>Fanout writer opens the files per partition value and doesn't close these files till write task is finished. This functionality is discouraged for batch query, as explicit sort against output rows isn't expensive for batch workload.</p>"},{"location":"spark-structured-streaming/#maintenance-for-streaming-tables","title":"Maintenance for streaming tables","text":"<p>Streaming queries can create new table versions quickly, which creates lots of table metadata to track those versions. Maintaining metadata by tuning the rate of commits, expiring old snapshots, and automatically cleaning up metadata files is highly recommended.</p>"},{"location":"spark-structured-streaming/#tune-the-rate-of-commits","title":"Tune the rate of commits","text":"<p>Having high rate of commits would produce lots of data files, manifests, and snapshots which leads the table hard to maintain. We encourage having trigger interval 1 minute at minimum, and increase the interval if needed.</p> <p>The triggers section in Structured Streaming Programming Guide documents how to configure the interval.</p>"},{"location":"spark-structured-streaming/#expire-old-snapshots","title":"Expire old snapshots","text":"<p>Each micro-batch written to a table produces a new snapshot, which are tracked in table metadata until they are expired to remove the metadata and any data files that are no longer needed. Snapshots accumulate quickly with frequent commits, so it is highly recommended that tables written by streaming queries are regularly maintained.</p>"},{"location":"spark-structured-streaming/#compacting-data-files","title":"Compacting data files","text":"<p>The amount of data written in a micro batch is typically small, which can cause the table metadata to track lots of small files. Compacting small files into larger files reduces the metadata needed by the table, and increases query efficiency.</p>"},{"location":"spark-structured-streaming/#rewrite-manifests","title":"Rewrite manifests","text":"<p>To optimize write latency on streaming workload, Iceberg may write the new snapshot with a \"fast\" append that does not automatically compact manifests. This could lead lots of small manifest files. Manifests can be rewritten to optimize queries and to compact.</p>"},{"location":"spark-writes/","title":"Writes","text":""},{"location":"spark-writes/#spark-writes","title":"Spark Writes","text":"<p>To use Iceberg in Spark, first configure Spark catalogs.</p> <p>Some plans are only available when using Iceberg SQL extensions in Spark 3.</p> <p>Iceberg uses Apache Spark's DataSourceV2 API for data source and catalog implementations. Spark DSv2 is an evolving API with different levels of support in Spark versions:</p> Feature support Spark 3 Notes SQL insert into \u2714\ufe0f SQL merge into \u2714\ufe0f \u26a0 Requires Iceberg Spark extensions SQL insert overwrite \u2714\ufe0f SQL delete from \u2714\ufe0f \u26a0 Row-level delete requires Spark extensions SQL update \u2714\ufe0f \u26a0 Requires Iceberg Spark extensions DataFrame append \u2714\ufe0f DataFrame overwrite \u2714\ufe0f DataFrame CTAS and RTAS \u2714\ufe0f"},{"location":"spark-writes/#writing-with-sql","title":"Writing with SQL","text":"<p>Spark 3 supports SQL <code>INSERT INTO</code>, <code>MERGE INTO</code>, and <code>INSERT OVERWRITE</code>, as well as the new <code>DataFrameWriterV2</code> API.</p>"},{"location":"spark-writes/#insert-into","title":"<code>INSERT INTO</code>","text":"<p>To append new data to a table, use <code>INSERT INTO</code>.</p> <p><pre><code>INSERT INTO prod.db.table VALUES (1, 'a'), (2, 'b')\n</code></pre> <pre><code>INSERT INTO prod.db.table SELECT ...\n</code></pre></p>"},{"location":"spark-writes/#merge-into","title":"<code>MERGE INTO</code>","text":"<p>Spark 3 added support for <code>MERGE INTO</code> queries that can express row-level updates.</p> <p>Iceberg supports <code>MERGE INTO</code> by rewriting data files that contain rows that need to be updated in an <code>overwrite</code> commit.</p> <p><code>MERGE INTO</code> is recommended instead of <code>INSERT OVERWRITE</code> because Iceberg can replace only the affected data files, and because the data overwritten by a dynamic overwrite may change if the table's partitioning changes.</p>"},{"location":"spark-writes/#merge-into-syntax","title":"<code>MERGE INTO</code> syntax","text":"<p><code>MERGE INTO</code> updates a table, called the target table, using a set of updates from another query, called the source. The update for a row in the target table is found using the <code>ON</code> clause that is like a join condition.</p> <pre><code>MERGE INTO prod.db.target t   -- a target table\nUSING (SELECT ...) s          -- the source updates\nON t.id = s.id                -- condition to find updates for target rows\nWHEN ...                      -- updates\n</code></pre> <p>Updates to rows in the target table are listed using <code>WHEN MATCHED ... THEN ...</code>. Multiple <code>MATCHED</code> clauses can be added with conditions that determine when each match should be applied. The first matching expression is used.</p> <pre><code>WHEN MATCHED AND s.op = 'delete' THEN DELETE\nWHEN MATCHED AND t.count IS NULL AND s.op = 'increment' THEN UPDATE SET t.count = 0\nWHEN MATCHED AND s.op = 'increment' THEN UPDATE SET t.count = t.count + 1\n</code></pre> <p>Source rows (updates) that do not match can be inserted:</p> <pre><code>WHEN NOT MATCHED THEN INSERT *\n</code></pre> <p>Inserts also support additional conditions:</p> <pre><code>WHEN NOT MATCHED AND s.event_time &gt; still_valid_threshold THEN INSERT (id, count) VALUES (s.id, 1)\n</code></pre> <p>Only one record in the source data can update any given row of the target table, or else an error will be thrown.</p>"},{"location":"spark-writes/#insert-overwrite","title":"<code>INSERT OVERWRITE</code>","text":"<p><code>INSERT OVERWRITE</code> can replace data in the table with the result of a query. Overwrites are atomic operations for Iceberg tables.</p> <p>The partitions that will be replaced by <code>INSERT OVERWRITE</code> depends on Spark's partition overwrite mode and the partitioning of a table. <code>MERGE INTO</code> can rewrite only affected data files and has more easily understood behavior, so it is recommended instead of <code>INSERT OVERWRITE</code>.</p>"},{"location":"spark-writes/#overwrite-behavior","title":"Overwrite behavior","text":"<p>Spark's default overwrite mode is static, but dynamic overwrite mode is recommended when writing to Iceberg tables. Static overwrite mode determines which partitions to overwrite in a table by converting the <code>PARTITION</code> clause to a filter, but the <code>PARTITION</code> clause can only reference table columns.</p> <p>Dynamic overwrite mode is configured by setting <code>spark.sql.sources.partitionOverwriteMode=dynamic</code>.</p> <p>To demonstrate the behavior of dynamic and static overwrites, consider a <code>logs</code> table defined by the following DDL:</p> <pre><code>CREATE TABLE prod.my_app.logs (\nuuid string NOT NULL,\nlevel string NOT NULL,\nts timestamp NOT NULL,\nmessage string)\nUSING iceberg\nPARTITIONED BY (level, hours(ts))\n</code></pre>"},{"location":"spark-writes/#dynamic-overwrite","title":"Dynamic overwrite","text":"<p>When Spark's overwrite mode is dynamic, partitions that have rows produced by the <code>SELECT</code> query will be replaced.</p> <p>For example, this query removes duplicate log events from the example <code>logs</code> table.</p> <pre><code>INSERT OVERWRITE prod.my_app.logs\nSELECT uuid, first(level), first(ts), first(message)\nFROM prod.my_app.logs\nWHERE cast(ts as date) = '2020-07-01'\nGROUP BY uuid\n</code></pre> <p>In dynamic mode, this will replace any partition with rows in the <code>SELECT</code> result. Because the date of all rows is restricted to 1 July, only hours of that day will be replaced.</p>"},{"location":"spark-writes/#static-overwrite","title":"Static overwrite","text":"<p>When Spark's overwrite mode is static, the <code>PARTITION</code> clause is converted to a filter that is used to delete from the table. If the <code>PARTITION</code> clause is omitted, all partitions will be replaced.</p> <p>Because there is no <code>PARTITION</code> clause in the query above, it will drop all existing rows in the table when run in static mode, but will only write the logs from 1 July.</p> <p>To overwrite just the partitions that were loaded, add a <code>PARTITION</code> clause that aligns with the <code>SELECT</code> query filter:</p> <pre><code>INSERT OVERWRITE prod.my_app.logs\nPARTITION (level = 'INFO')\nSELECT uuid, first(level), first(ts), first(message)\nFROM prod.my_app.logs\nWHERE level = 'INFO'\nGROUP BY uuid\n</code></pre> <p>Note that this mode cannot replace hourly partitions like the dynamic example query because the <code>PARTITION</code> clause can only reference table columns, not hidden partitions.</p>"},{"location":"spark-writes/#delete-from","title":"<code>DELETE FROM</code>","text":"<p>Spark 3 added support for <code>DELETE FROM</code> queries to remove data from tables.</p> <p>Delete queries accept a filter to match rows to delete.</p> <pre><code>DELETE FROM prod.db.table\nWHERE ts &gt;= '2020-05-01 00:00:00' and ts &lt; '2020-06-01 00:00:00'\nDELETE FROM prod.db.all_events\nWHERE session_time &lt; (SELECT min(session_time) FROM prod.db.good_events)\nDELETE FROM prod.db.orders AS t1\nWHERE EXISTS (SELECT oid FROM prod.db.returned_orders WHERE t1.oid = oid)\n</code></pre> <p>If the delete filter matches entire partitions of the table, Iceberg will perform a metadata-only delete. If the filter matches individual rows of a table, then Iceberg will rewrite only the affected data files.</p>"},{"location":"spark-writes/#update","title":"<code>UPDATE</code>","text":"<p>Spark 3.1 added support for <code>UPDATE</code> queries that update matching rows in tables.</p> <p>Update queries accept a filter to match rows to update.</p> <pre><code>UPDATE prod.db.table\nSET c1 = 'update_c1', c2 = 'update_c2'\nWHERE ts &gt;= '2020-05-01 00:00:00' and ts &lt; '2020-06-01 00:00:00'\nUPDATE prod.db.all_events\nSET session_time = 0, ignored = true\nWHERE session_time &lt; (SELECT min(session_time) FROM prod.db.good_events)\nUPDATE prod.db.orders AS t1\nSET order_status = 'returned'\nWHERE EXISTS (SELECT oid FROM prod.db.returned_orders WHERE t1.oid = oid)\n</code></pre> <p>For more complex row-level updates based on incoming data, see the section on <code>MERGE INTO</code>.</p>"},{"location":"spark-writes/#writing-to-branches","title":"Writing to Branches","text":"<p>Branch writes can be performed via SQL by providing a branch identifier, <code>branch_yourBranch</code> in the operation. Branch writes can also be performed as part of a write-audit-publish (WAP) workflow by specifying the <code>spark.wap.branch</code> config. Note WAP branch and branch identifier cannot both be specified. Also, the branch must exist before performing the write.  The operation does not create the branch if it does not exist.  For more information on branches please refer to branches.</p> <pre><code>-- INSERT (1,' a') (2, 'b') into the audit branch.\nINSERT INTO prod.db.table.branch_audit VALUES (1, 'a'), (2, 'b');\n-- MERGE INTO audit branch\nMERGE INTO prod.db.table.branch_audit t USING (SELECT ...) s        ON t.id = s.id          WHEN ...\n-- UPDATE audit branch\nUPDATE prod.db.table.branch_audit AS t1\nSET val = 'c'\n-- DELETE FROM audit branch\nDELETE FROM prod.dbl.table.branch_audit WHERE id = 2;\n-- WAP Branch write\nSET spark.wap.branch = audit-branch\nINSERT INTO prod.db.table VALUES (3, 'c');\n</code></pre>"},{"location":"spark-writes/#writing-with-dataframes","title":"Writing with DataFrames","text":"<p>Spark 3 introduced the new <code>DataFrameWriterV2</code> API for writing to tables using data frames. The v2 API is recommended for several reasons:</p> <ul> <li>CTAS, RTAS, and overwrite by filter are supported</li> <li>All operations consistently write columns to a table by name</li> <li>Hidden partition expressions are supported in <code>partitionedBy</code></li> <li>Overwrite behavior is explicit, either dynamic or by a user-supplied filter</li> <li>The behavior of each operation corresponds to SQL statements<ul> <li><code>df.writeTo(t).create()</code> is equivalent to <code>CREATE TABLE AS SELECT</code></li> <li><code>df.writeTo(t).replace()</code> is equivalent to <code>REPLACE TABLE AS SELECT</code></li> <li><code>df.writeTo(t).append()</code> is equivalent to <code>INSERT INTO</code></li> <li><code>df.writeTo(t).overwritePartitions()</code> is equivalent to dynamic <code>INSERT OVERWRITE</code></li> </ul> </li> </ul> <p>The v1 DataFrame <code>write</code> API is still supported, but is not recommended.</p> <p>Danger</p> <p>When writing with the v1 DataFrame API in Spark 3, use <code>saveAsTable</code> or <code>insertInto</code> to load tables with a catalog. Using <code>format(\"iceberg\")</code> loads an isolated table reference that will not automatically refresh tables used by queries.</p>"},{"location":"spark-writes/#appending-data","title":"Appending data","text":"<p>To append a dataframe to an Iceberg table, use <code>append</code>:</p> <pre><code>val data: DataFrame = ...\ndata.writeTo(\"prod.db.table\").append()\n</code></pre>"},{"location":"spark-writes/#overwriting-data","title":"Overwriting data","text":"<p>To overwrite partitions dynamically, use <code>overwritePartitions()</code>:</p> <pre><code>val data: DataFrame = ...\ndata.writeTo(\"prod.db.table\").overwritePartitions()\n</code></pre> <p>To explicitly overwrite partitions, use <code>overwrite</code> to supply a filter:</p> <pre><code>data.writeTo(\"prod.db.table\").overwrite($\"level\" === \"INFO\")\n</code></pre>"},{"location":"spark-writes/#creating-tables","title":"Creating tables","text":"<p>To run a CTAS or RTAS, use <code>create</code>, <code>replace</code>, or <code>createOrReplace</code> operations:</p> <pre><code>val data: DataFrame = ...\ndata.writeTo(\"prod.db.table\").create()\n</code></pre> <p>If you have replaced the default Spark catalog (<code>spark_catalog</code>) with Iceberg's <code>SparkSessionCatalog</code>, do:</p> <pre><code>val data: DataFrame = ...\ndata.writeTo(\"db.table\").using(\"iceberg\").create()\n</code></pre> <p>Create and replace operations support table configuration methods, like <code>partitionedBy</code> and <code>tableProperty</code>:</p> <pre><code>data.writeTo(\"prod.db.table\")\n.tableProperty(\"write.format.default\", \"orc\")\n.partitionedBy($\"level\", days($\"ts\"))\n.createOrReplace()\n</code></pre> <p>The Iceberg table location can also be specified by the <code>location</code> table property:</p> <pre><code>data.writeTo(\"prod.db.table\")\n.tableProperty(\"location\", \"/path/to/location\")\n.createOrReplace()\n</code></pre>"},{"location":"spark-writes/#writing-distribution-modes","title":"Writing Distribution Modes","text":"<p>Iceberg's default Spark writers require that the data in each spark task is clustered by partition values. This  distribution is required to minimize the number of file handles that are held open while writing. By default, starting in Iceberg 1.2.0, Iceberg also requests that Spark pre-sort data to be written to fit this distribution. The request to Spark is done through the table property <code>write.distribution-mode</code> with the value <code>hash</code>.</p> <p>Let's go through writing the data against below sample table:</p> <pre><code>CREATE TABLE prod.db.sample (\nid bigint,\ndata string,\ncategory string,\nts timestamp)\nUSING iceberg\nPARTITIONED BY (days(ts), category)\n</code></pre> <p>To write data to the sample table, data needs to be sorted by <code>days(ts), category</code> but this is taken care of automatically by the default <code>hash</code> distribution. Previously this would have required manually sorting, but this  is no longer the case.</p> <pre><code>INSERT INTO prod.db.sample\nSELECT id, data, category, ts FROM another_table\n</code></pre> <p>There are 3 options for <code>write.distribution-mode</code></p> <ul> <li><code>none</code> - This is the previous default for Iceberg. This mode does not request any shuffles or sort to be performed automatically by Spark. Because no work is done  automatically by Spark, the data must be manually sorted by partition value. The data must be sorted either within  each spark task, or globally within the entire dataset. A global sort will minimize the number of output files. A sort can be avoided by using the Spark write fanout property but this will cause all  file handles to remain open until each write task has completed.</li> <li><code>hash</code> - This mode is the new default and requests that Spark uses a hash-based exchange to shuffle the incoming write data before writing. Practically, this means that each row is hashed based on the row's partition value and then placed in a corresponding Spark task based upon that value. Further division and coalescing of tasks may take place because of Spark's Adaptive Query planning.</li> <li><code>range</code> - This mode requests that Spark perform a range based exchanged to shuffle the data before writing. This is a two stage procedure which is more expensive than the <code>hash</code> mode. The first stage samples the data to  be written based on the partition and sort columns. The second stage uses the range information to shuffle the input data into Spark  tasks. Each task gets an exclusive range of the input data which clusters the data by partition and also globally sorts. While this is more expensive than the hash distribution, the global ordering can be beneficial for read performance if sorted columns are used during queries. This mode is used by default if a table is created with a  sort-order. Further division and coalescing of tasks may take place because of Spark's Adaptive Query planning.</li> </ul>"},{"location":"spark-writes/#controlling-file-sizes","title":"Controlling File Sizes","text":"<p>When writing data to Iceberg with Spark, it's important to note that Spark cannot write a file larger than a Spark  task and a file cannot span an Iceberg partition boundary. This means although Iceberg will always roll over a file  when it grows to <code>write.target-file-size-bytes</code>, but unless the Spark task is  large enough that will not happen. The size of the file created on disk will also be much smaller than the Spark task  since the on disk data will be both compressed and in columnar format as opposed to Spark's uncompressed row  representation. This means a 100 megabyte Spark task will create a file much smaller than 100 megabytes even if that task is writing to a single Iceberg partition. If the task writes to multiple partitions, the files will be even smaller than that.</p> <p>To control what data ends up in each Spark task use a <code>write distribution mode</code>  or manually repartition the data. </p> <p>To adjust Spark's task size it is important to become familiar with Spark's various Adaptive Query Execution (AQE)  parameters. When the <code>write.distribution-mode</code> is not <code>none</code>, AQE will control the coalescing and splitting of Spark tasks during the exchange to try to create tasks of <code>spark.sql.adaptive.advisoryPartitionSizeInBytes</code> size. These  settings will also affect any user performed re-partitions or sorts.  It is important again to note that this is the in-memory Spark row size and not the on disk columnar-compressed size, so a larger value than the target file size will need to be specified. The ratio of  in-memory size to on disk size is data dependent. Future work in Spark should allow Iceberg to automatically adjust this parameter at write time to match the <code>write.target-file-size-bytes</code>.</p>"},{"location":"spark-writes/#type-compatibility","title":"Type compatibility","text":"<p>Spark and Iceberg support different set of types. Iceberg does the type conversion automatically, but not for all combinations, so you may want to understand the type conversion in Iceberg in prior to design the types of columns in your tables.</p>"},{"location":"spark-writes/#spark-type-to-iceberg-type","title":"Spark type to Iceberg type","text":"<p>This type conversion table describes how Spark types are converted to the Iceberg types. The conversion applies on both creating Iceberg table and writing to Iceberg table via Spark.</p> Spark Iceberg Notes boolean boolean short integer byte integer integer integer long long float float double double date date timestamp timestamp with timezone char string varchar string string string binary binary decimal decimal struct struct array list map map <p>Info</p> <p>The table is based on representing conversion during creating table. In fact, broader supports are applied on write. Here're some points on write:</p> <ul> <li>Iceberg numeric types (<code>integer</code>, <code>long</code>, <code>float</code>, <code>double</code>, <code>decimal</code>) support promotion during writes. e.g. You can write Spark types <code>short</code>, <code>byte</code>, <code>integer</code>, <code>long</code> to Iceberg type <code>long</code>.</li> <li>You can write to Iceberg <code>fixed</code> type using Spark <code>binary</code> type. Note that assertion on the length will be performed.</li> </ul>"},{"location":"spark-writes/#iceberg-type-to-spark-type","title":"Iceberg type to Spark type","text":"<p>This type conversion table describes how Iceberg types are converted to the Spark types. The conversion applies on reading from Iceberg table via Spark.</p> Iceberg Spark Note boolean boolean integer integer long long float float double double date date time Not supported timestamp with timezone timestamp timestamp without timezone Not supported string string uuid string fixed binary binary binary decimal decimal struct struct list array map map"},{"location":"table-migration/","title":"Overview","text":""},{"location":"table-migration/#table-migration","title":"Table Migration","text":"<p>Apache Iceberg supports converting existing tables in other formats to Iceberg tables. This section introduces the general concept of table migration, its approaches, and existing implementations in Iceberg.</p>"},{"location":"table-migration/#migration-approaches","title":"Migration Approaches","text":"<p>There are two methods for executing table migration: full data migration and in-place metadata migration.</p> <p>Full data migration involves copying all data files from the source table to the new Iceberg table. This method makes the new table fully isolated from the source table, but is slower and doubles the space. In practice, users can use operations like Create-Table-As-Select, INSERT, and Change-Data-Capture pipelines to perform such migration.</p> <p>In-place metadata migration preserves the existing data files while incorporating Iceberg metadata on top of them. This method is not only faster but also eliminates the need for data duplication. However, the new table and the source table are not fully isolated. In other words, if any processes vacuum data files from the source table, the new table will also be affected.</p> <p>In this doc, we will describe more about in-place metadata migration.</p> <p></p> <p>Apache Iceberg supports the in-place metadata migration approach, which includes three important actions: Snapshot Table, Migrate Table, and Add Files.</p>"},{"location":"table-migration/#snapshot-table","title":"Snapshot Table","text":"<p>The Snapshot Table action creates a new iceberg table with a different name and with the same schema and partitioning as the source table, leaving the source table unchanged during and after the action.</p> <ul> <li>Create a new Iceberg table with the same metadata (schema, partition spec, etc.) as the source table and a different name. Readers and Writers on the source table can continue to work.</li> </ul> <p></p> <ul> <li>Commit all data files across all partitions to the new Iceberg table. The source table remains unchanged. Readers can be switched to the new Iceberg table.</li> </ul> <p></p> <ul> <li>Eventually, all writers can be switched to the new Iceberg table. Once all writers are transitioned to the new Iceberg table, the migration process will be considered complete.</li> </ul>"},{"location":"table-migration/#migrate-table","title":"Migrate Table","text":"<p>The Migrate Table action also creates a new Iceberg table with the same schema and partitioning as the source table. However, during the action execution, it locks and drops the source table from the catalog. Consequently, Migrate Table requires all modifications working on the source table to be stopped before the action is performed.</p> <p>Stop all writers interacting with the source table. Readers that also support Iceberg may continue reading.</p> <p></p> <ul> <li>Create a new Iceberg table with the same identifier and metadata (schema, partition spec, etc.) as the source table. Rename the source table for a backup in case of failure and rollback.</li> </ul> <p></p> <ul> <li>Commit all data files across all partitions to the new Iceberg table. Drop the source table. Writers can start writing to the new Iceberg table.</li> </ul> <p></p>"},{"location":"table-migration/#add-files","title":"Add Files","text":"<p>After the initial step (either Snapshot Table or Migrate Table), it is common to find some data files that have not been migrated. These files often originate from concurrent writers who continue writing to the source table during or after the migration process. In practice, these files can be new data files in Hive tables or new snapshots (versions) of Delta Lake tables. The Add Files action is essential for incorporating these files into the Iceberg table.</p>"},{"location":"table-migration/#migrating-from-different-table-formats","title":"Migrating From Different Table Formats","text":"<ul> <li>From Hive to Iceberg</li> <li>From Delta Lake to Iceberg</li> </ul>"}]}